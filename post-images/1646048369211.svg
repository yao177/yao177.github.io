<?xml version="1.0" encoding="UTF-8" standalone="no"?><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" contentScriptType="application/ecmascript" contentStyleType="text/css" height="527px" preserveAspectRatio="none" style="width:1060px;height:527px;background:#FFFFFF;" version="1.1" viewBox="0 0 1060 527" width="1060px" zoomAndPan="magnify"><defs><filter height="300%" id="f14sq0nswg634j" width="300%" x="-1" y="-1"><feGaussianBlur result="blurOut" stdDeviation="2.0"/><feColorMatrix in="blurOut" result="blurOut2" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 .4 0"/><feOffset dx="4.0" dy="4.0" in="blurOut2" result="blurOut3"/><feBlend in="SourceGraphic" in2="blurOut3" mode="normal"/></filter></defs><g><text fill="#000000" font-family="sans-serif" font-size="18" lengthAdjust="spacing" textLength="283" x="387.75" y="27.4023">项目：concurrent-spring-startup</text><ellipse cx="132.5" cy="41.1992" fill="#000000" filter="url(#f14sq0nswg634j)" rx="10" ry="10" style="stroke:none;stroke-width:1.0;"/><rect fill="#FFFFFF" filter="url(#f14sq0nswg634j)" height="164.6914" style="stroke:#000000;stroke-width:2.0;" width="876" x="11" y="61.1992"/><path d="M94,61.1992 L94,70.6875 L84,80.6875 L11,80.6875 " fill="none" style="stroke:#000000;stroke-width:2.0;"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="73" x="14" y="75.7344">依赖Spring</text><path d="M264,101.4277 L264,117.7383 L244,121.7383 L264,125.7383 L264,142.0488 A0,0 0 0 0 264,142.0488 L877,142.0488 A0,0 0 0 0 877,142.0488 L877,111.4277 L867,101.4277 L264,101.4277 A0,0 0 0 0 264,101.4277 " fill="#FBFB77" filter="url(#f14sq0nswg634j)" style="stroke:#A80036;stroke-width:1.0;"/><path d="M867,101.4277 L867,111.4277 L877,111.4277 L867,101.4277 " fill="#FBFB77" style="stroke:#A80036;stroke-width:1.0;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="592" x="270" y="118.9961">实现了BeanPostProcessor，负责校验Bean能否被代理和将代理对象替换原有Bean并注入Spring容器；</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="487" x="270" y="134.3066">实现了ApplicationListener，会在Spring启动完成之前等待所有异步方法执行完毕。</text><rect fill="#FEFECE" filter="url(#f14sq0nswg634j)" height="48.1016" rx="12.5" ry="12.5" style="stroke:#A80036;stroke-width:1.5;" width="223" x="21" y="97.6875"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="64" x="31" y="119.2891">Spring 调用</text><text fill="#000000" font-family="monospace" font-size="12" lengthAdjust="spacing" textLength="203" x="31" y="132.959">ConcurrentSpringConfiguration</text><path d="M236,177.1846 L236,185.8398 L216,189.8398 L236,193.8398 L236,202.4951 A0,0 0 0 0 236,202.4951 L699,202.4951 A0,0 0 0 0 699,202.4951 L699,187.1846 L689,177.1846 L236,177.1846 A0,0 0 0 0 236,177.1846 " fill="#FBFB77" filter="url(#f14sq0nswg634j)" style="stroke:#A80036;stroke-width:1.0;"/><path d="M689,177.1846 L689,187.1846 L699,187.1846 L689,177.1846 " fill="#FBFB77" style="stroke:#A80036;stroke-width:1.0;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="442" x="242" y="194.7529">负责装配代理对象，包括代理方法的装备策略、生成代理对象的具体逻辑等。</text><rect fill="#FEFECE" filter="url(#f14sq0nswg634j)" height="48.1016" rx="12.5" ry="12.5" style="stroke:#A80036;stroke-width:1.5;" width="167" x="49" y="165.7891"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="60" x="59" y="187.3906">获得代理类</text><text fill="#000000" font-family="monospace" font-size="12" lengthAdjust="spacing" textLength="147" x="59" y="201.0605">ConcurrentBeanFactory</text><rect fill="#FFFFFF" filter="url(#f14sq0nswg634j)" height="232.793" style="stroke:#000000;stroke-width:2.0;" width="1025.5" x="18" y="235.8906"/><path d="M95,235.8906 L95,245.3789 L85,255.3789 L18,255.3789 " fill="none" style="stroke:#000000;stroke-width:2.0;"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="67" x="21" y="250.4258">依赖CGLIB</text><path d="M218.5,283.7744 L218.5,292.4297 L198.5,296.4297 L218.5,300.4297 L218.5,309.085 A0,0 0 0 0 218.5,309.085 L1033.5,309.085 A0,0 0 0 0 1033.5,309.085 L1033.5,293.7744 L1023.5,283.7744 L218.5,283.7744 A0,0 0 0 0 218.5,283.7744 " fill="#FBFB77" filter="url(#f14sq0nswg634j)" style="stroke:#A80036;stroke-width:1.0;"/><path d="M1023.5,283.7744 L1023.5,293.7744 L1033.5,293.7744 L1023.5,283.7744 " fill="#FBFB77" style="stroke:#A80036;stroke-width:1.0;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="794" x="224.5" y="301.3428">组件生成的动态代理类所实现的接口。该接口包含一个Object类型的getter和setter，目的是用于管理动态代理类所代理的原有bean引用。</text><rect fill="#FEFECE" filter="url(#f14sq0nswg634j)" height="48.1016" rx="12.5" ry="12.5" style="stroke:#A80036;stroke-width:1.5;" width="132" x="66.5" y="272.3789"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="60" x="76.5" y="293.9805">创建代理类</text><text fill="#000000" font-family="monospace" font-size="12" lengthAdjust="spacing" textLength="112" x="76.5" y="307.6504">WrappedProxyBean</text><path d="M257,351.876 L257,360.5313 L237,364.5313 L257,368.5313 L257,377.1865 A0,0 0 0 0 257,377.1865 L973,377.1865 A0,0 0 0 0 973,377.1865 L973,361.876 L963,351.876 L257,351.876 A0,0 0 0 0 257,351.876 " fill="#FBFB77" filter="url(#f14sq0nswg634j)" style="stroke:#A80036;stroke-width:1.0;"/><path d="M963,351.876 L963,361.876 L973,361.876 L963,351.876 " fill="#FBFB77" style="stroke:#A80036;stroke-width:1.0;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="695" x="263" y="369.4443">实现了CGLIB的MethodInterceptor接口，在代理对象方法被调用时按照指定的策略执行代理方法（WrappedMethod）。</text><rect fill="#FEFECE" filter="url(#f14sq0nswg634j)" height="48.1016" rx="12.5" ry="12.5" style="stroke:#A80036;stroke-width:1.5;" width="209" x="28" y="340.4805"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="72" x="38" y="362.082">方法策略路由</text><text fill="#000000" font-family="monospace" font-size="12" lengthAdjust="spacing" textLength="189" x="38" y="375.752">ConcurrentMethodInterceptor</text><path d="M208,419.9775 L208,428.6328 L188,432.6328 L208,436.6328 L208,445.2881 A0,0 0 0 0 208,445.2881 L616,445.2881 A0,0 0 0 0 616,445.2881 L616,429.9775 L606,419.9775 L208,419.9775 A0,0 0 0 0 208,419.9775 " fill="#FBFB77" filter="url(#f14sq0nswg634j)" style="stroke:#A80036;stroke-width:1.0;"/><path d="M606,419.9775 L606,429.9775 L616,429.9775 L606,419.9775 " fill="#FBFB77" style="stroke:#A80036;stroke-width:1.0;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="387" x="214" y="437.5459">WrappedMethod定义了代理类方法被调用时程序实际执行的逻辑。</text><rect fill="#FEFECE" filter="url(#f14sq0nswg634j)" height="48.1016" rx="12.5" ry="12.5" style="stroke:#A80036;stroke-width:1.5;" width="111" x="77" y="408.582"/><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="72" x="87" y="430.1836">执行代理方法</text><text fill="#000000" font-family="monospace" font-size="12" lengthAdjust="spacing" textLength="91" x="87" y="443.8535">WrappedMethod</text><ellipse cx="132.5" cy="499.6836" fill="#FFFFFF" filter="url(#f14sq0nswg634j)" rx="11" ry="11" style="stroke:#000000;stroke-width:1.0;"/><ellipse cx="132.5" cy="499.6836" fill="#000000" rx="6" ry="6" style="stroke:#7F7F7F;stroke-width:1.0;"/><line style="stroke:#A80036;stroke-width:1.5;" x1="132.5" x2="132.5" y1="145.7891" y2="165.7891"/><polygon fill="#A80036" points="128.5,155.7891,132.5,165.7891,136.5,155.7891,132.5,159.7891" style="stroke:#A80036;stroke-width:1.0;"/><line style="stroke:#A80036;stroke-width:1.5;" x1="132.5" x2="132.5" y1="51.1992" y2="97.6875"/><polygon fill="#A80036" points="128.5,87.6875,132.5,97.6875,136.5,87.6875,132.5,91.6875" style="stroke:#A80036;stroke-width:1.0;"/><line style="stroke:#A80036;stroke-width:1.5;" x1="132.5" x2="132.5" y1="320.4805" y2="340.4805"/><polygon fill="#A80036" points="128.5,330.4805,132.5,340.4805,136.5,330.4805,132.5,334.4805" style="stroke:#A80036;stroke-width:1.0;"/><line style="stroke:#A80036;stroke-width:1.5;" x1="132.5" x2="132.5" y1="388.582" y2="408.582"/><polygon fill="#A80036" points="128.5,398.582,132.5,408.582,136.5,398.582,132.5,402.582" style="stroke:#A80036;stroke-width:1.0;"/><line style="stroke:#A80036;stroke-width:1.5;" x1="132.5" x2="132.5" y1="213.8906" y2="272.3789"/><polygon fill="#A80036" points="128.5,262.3789,132.5,272.3789,136.5,262.3789,132.5,266.3789" style="stroke:#A80036;stroke-width:1.0;"/><line style="stroke:#A80036;stroke-width:1.5;" x1="132.5" x2="132.5" y1="456.6836" y2="488.6836"/><polygon fill="#A80036" points="128.5,478.6836,132.5,488.6836,136.5,478.6836,132.5,482.6836" style="stroke:#A80036;stroke-width:1.0;"/><!--MD5=[e6e37848c200027b27222108e642b7f9]
@startuml 优化启动流程
title 项目：concurrent-spring-startup
start
partition 依赖Spring {
    :Spring 调用
    <code>
    ConcurrentSpringConfiguration
    </code>;
    note right
    实现了BeanPostProcessor，负责校验Bean能否被代理和将代理对象替换原有Bean并注入Spring容器；
    实现了ApplicationListener，会在Spring启动完成之前等待所有异步方法执行完毕。
    end note
    :获得代理类
    <code>
    ConcurrentBeanFactory
    </code>;
    note right
    负责装配代理对象，包括代理方法的装备策略、生成代理对象的具体逻辑等。
    end note
}
partition 依赖CGLIB {
    :创建代理类
    <code>
    WrappedProxyBean
    </code>;
    note right
    组件生成的动态代理类所实现的接口。该接口包含一个Object类型的getter和setter，目的是用于管理动态代理类所代理的原有bean引用。
    end note
    :方法策略路由
    <code>
    ConcurrentMethodInterceptor
    </code>;
    note right
    实现了CGLIB的MethodInterceptor接口，在代理对象方法被调用时按照指定的策略执行代理方法（WrappedMethod）。
    end note
    :执行代理方法
    <code>
    WrappedMethod
    </code>;
    note right
    WrappedMethod定义了代理类方法被调用时程序实际执行的逻辑。
    end note
}
stop
@enduml

PlantUML version 1.2022.0(Wed Jan 12 00:16:42 CST 2022)
(GPL source distribution)
Java Runtime: OpenJDK Runtime Environment
JVM: OpenJDK 64-Bit Server VM
Default Encoding: UTF-8
Language: zh
Country: CN
--></g></svg>