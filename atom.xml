<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://yao177.github.io</id>
    <title>York Zhang&apos;s Blog</title>
    <updated>2022-03-01T06:05:14.915Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://yao177.github.io"/>
    <link rel="self" href="https://yao177.github.io/atom.xml"/>
    <subtitle>&lt;b&gt;E&lt;/b&gt;·rror = &lt;b&gt;m&lt;/b&gt;·ore * &lt;b&gt;c²&lt;/b&gt;·ode</subtitle>
    <logo>https://yao177.github.io/images/avatar.png</logo>
    <icon>https://yao177.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, York Zhang&apos;s Blog</rights>
    <entry>
        <title type="html"><![CDATA[Java 框架｜Spring 启动加速器]]></title>
        <id>https://yao177.github.io/post/concurrent-spring-startup/</id>
        <link href="https://yao177.github.io/post/concurrent-spring-startup/">
        </link>
        <updated>2021-11-23T06:20:13.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2">写在前面</a></li>
<li><a href="#%E9%A1%B9%E7%9B%AE%E8%83%8C%E6%99%AF">项目背景</a></li>
<li><a href="#%E7%9F%A5%E8%AF%86%E8%83%8C%E6%99%AF">知识背景</a>
<ul>
<li><a href="#spring">Spring</a>
<ul>
<li><a href="#spring-%E7%AE%80%E8%BF%B0">Spring 简述</a></li>
<li><a href="#spring-%E5%85%B3%E9%94%AE%E7%BB%84%E4%BB%B6">Spring 关键组件</a>
<ul>
<li><a href="#beanfactory">BeanFactory</a></li>
<li><a href="#applicationcontext">ApplicationContext</a></li>
<li><a href="#beanpostprocessor">BeanPostProcessor</a></li>
<li><a href="#instantiationawarebeanpostprocessor">InstantiationAwareBeanPostProcessor</a></li>
</ul>
</li>
<li><a href="#spring-%E5%AE%B9%E5%99%A8%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B">Spring 容器启动过程</a></li>
<li><a href="#spring-%E4%B8%8E%E6%9C%AC%E9%A1%B9%E7%9B%AE%E7%9A%84%E8%81%94%E7%B3%BB">Spring 与本项目的联系</a></li>
</ul>
</li>
<li><a href="#cglib">CGLIB</a>
<ul>
<li><a href="#cglib-%E7%AE%80%E8%BF%B0">CGLIB 简述</a></li>
<li><a href="#cglib-%E7%9A%84%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B">CGLIB 的使用示例</a></li>
<li><a href="#cglib-%E5%92%8C-jdk-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%9A%84%E5%8C%BA%E5%88%AB">CGLIB 和 JDK 动态代理的区别</a></li>
<li><a href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">注意事项</a></li>
<li><a href="#cglib-%E4%B8%8E%E6%9C%AC%E9%A1%B9%E7%9B%AE%E7%9A%84%E8%81%94%E7%B3%BB">CGLIB 与本项目的联系</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF">设计思路</a>
<ul>
<li><a href="#%E6%8F%90%E5%87%BA%E7%9B%AE%E5%89%8D%E7%9A%84%E9%97%AE%E9%A2%98%E5%92%8C%E5%AF%B9%E5%BA%94%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88">提出目前的问题和对应解决方案：</a></li>
</ul>
</li>
<li><a href="#%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D">原理介绍</a>
<ul>
<li><a href="#%E9%A1%B9%E7%9B%AE%E6%A6%82%E8%A7%88">项目概览</a></li>
<li><a href="#%E5%88%9B%E5%BB%BA%E4%BB%A3%E7%90%86%E6%B5%81%E7%A8%8B">创建代理流程</a></li>
<li><a href="#%E5%89%8D%E7%BD%AE%E6%A0%A1%E9%AA%8C">前置校验</a>
<ul>
<li><a href="#%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96-bean-%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E6%B3%95">如何获取 Bean 的初始化方法</a></li>
<li><a href="#%E6%A0%A1%E9%AA%8C%E7%B1%BB%E5%9E%8B">校验类型</a></li>
</ul>
</li>
<li><a href="#%E8%A3%85%E9%85%8D%E4%BB%A3%E7%90%86%E6%96%B9%E6%B3%95%E7%AD%96%E7%95%A5">装配代理方法策略</a></li>
<li><a href="#%E5%AF%B9-factorybean-%E7%9A%84%E7%89%B9%E6%AE%8A%E5%A4%84%E7%90%86">对 FactoryBean 的特殊处理</a></li>
<li><a href="#%E5%88%9B%E5%BB%BA%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1">创建代理对象</a></li>
<li><a href="#%E5%9C%BA%E6%99%AF%E7%A4%BA%E4%BE%8B">场景示例</a></li>
</ul>
</li>
<li><a href="#%E9%A3%8E%E9%99%A9%E8%AF%84%E4%BC%B0">风险评估</a>
<ul>
<li><a href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%A1%8C%E4%B8%BA%E5%92%8C%E5%8E%9F%E6%9C%89-bean-%E7%9A%84%E5%B1%9E%E6%80%A7-%E8%A1%8C%E4%B8%BA%E4%B8%80%E8%87%B4">如何保证代理对象的行为和原有 Bean 的属性、行为一致？</a></li>
<li><a href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%E4%B8%8D%E4%BC%9A%E9%94%99%E4%B9%B1">如何保证代理对象方法执行顺序不会错乱？</a></li>
<li><a href="#%E5%85%B6%E4%BB%96%E5%8F%AF%E8%83%BD%E7%9A%84%E9%A3%8E%E9%99%A9%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3">其他可能的风险如何解决？</a></li>
</ul>
</li>
<li><a href="#%E6%80%BB%E7%BB%93">总结</a></li>
</ul>
</p>
<h1 id="写在前面">写在前面</h1>
<p>Spring 官网自豪地对自家产品评价到：快速、简单、安全。「快速」被其列为了第一位，可见这是 Spring 最引以为傲的特性。<br>
<img src="https://yao177.github.io/post-images/1646029531559.jpeg" alt="Spring 官网介绍" loading="lazy"><br>
「快速」意味着快速开发、快速启动、快速运行……而对于「快速启动」这一点，开发人员也许还有可乘之机。</p>
<h1 id="项目背景">项目背景</h1>
<p>服务部署虽然通常给开发人员提供了宝贵的休息时间，但服务启动时间过长，也势必会影响开发效率，增大回滚时的风险。<br>
Spring Bean 初始化耗时占 Spring 启动时间的70%，若能优化 Spring Bean 的初始化时间，则会达到提高服务启动速度的目的。<br>
concurrent-spring-startup 是一个旨在让 Spring 通过并行化来提高启动速度的项目，无代码侵入，绿色健康可食用。</p>
<h1 id="知识背景">知识背景</h1>
<h2 id="spring">Spring</h2>
<h3 id="spring-简述">Spring 简述</h3>
<p>Spring 框架可以被理解为一个容器，它帮我们管理了应用程序所需要的所有 Bean。<br>
例如：我们会在项目里的很多地方用到同一个数据库连接池，我们只需要将它声明为一个 Spring Bean。Spring 启动时，会将这个 bean 创建并小心翼翼地保护好。在任何我们需要的时候，向它索取即可。<br>
Spring 的启动过程涉及非常多的逻辑。本文围绕 Bean 的生命周期来对这一过程做介绍。Spring 的启动可以简单理解为下面三部曲：<br>
创建 Spring 容器 -&gt; 扫描所有 Bean 定义 -&gt; 创建所有 Bean<br>
<img src="https://yao177.github.io/post-images/1646036988133.svg" alt="Spring 简易启动流程" loading="lazy"></p>
<h3 id="spring-关键组件">Spring 关键组件</h3>
<h4 id="beanfactory">BeanFactory</h4>
<p>即 Spring 用来管理 Bean 的容器，用户可以按照名称、类型等信息来获取指定的 Bean。<br>
在这个接口的不同实现中，Spring 管理了不同类型Bean的生命周期（实例化、初始化、销毁）。它容纳了 Spring 中各个Bean的实例、Bean 的定义（来自 XML 或代码）。<br>
它是 Spring 框架的核心接口。<br>
其本身只包含获取 Bean 的方法，而其具体实现类有一些重要方法：</p>
<ul>
<li><code>getBean (String beanName)</code><br>
从Spring 容器中获取指定名称的Bean实例。若还没有创建，则创建之。事实上，Spring 正是通过这个方法来创建 Bean 的。</li>
<li><code>populateBean (String beanName, RootBeanDefinition mbd, BeanWrapper bw)</code><br>
用于 Bean 的实例化。getBean 被执行时，Spring 会调用 populateBean 进行 bean 的创建。参数 mbd 即 bean 的属性定义，例如我们在 XML 里面设置的字段和值。若 bean 依赖了其它 bean，它还会触发其它 bean 的创建和注入。</li>
</ul>
<h4 id="applicationcontext">ApplicationContext</h4>
<p>BeanFactory 接口的子类，拓展了很多功能供开发者使用，例如手动注入 bean、获取 bean、获取 bean的指定属性等。<br>
它内部持有另一个 BeanFactory 的引用，并全权负责这个 BeanFactory 的生命周期（实例化、初始化、销毁）。因此它对 BeanFactory 接口的实现都是基于这个内部BeanFactory的。也就是说，ApplicationContext 是专门给外部使用的（Springboot、开发者），而它所提供的花里胡哨的功能具体实现是由内部的 beanFactory 去完成的。<br>
事实上 ApplicationContext 其实不用实现BeanFactory接口，它已经提供了<code>getAutowireCapableBeanFactory</code>方法来获得“真正的 BeanFactory”。也许是为了不让开发者在两个接口中来回切换，只关注一个 Spring 组件，于是一并把 BeanFactory 接口实现了。明白这一点可以让读者理解 ApplicationContext 和 BeanFactory 的关系。<br>
在它的实现类中，有一些重要的方法：</p>
<ul>
<li><code>refresh()</code><br>
大名鼎鼎的refresh方法即为Spring容器启动的入口。该方法会完整地创建自己持有的BeanFactory，并执行它的初始化动作（例如扫描Bean定义、实例化所有Bean、初始化所有Bean、添加各类处理器和监听器）。如果已经存在一个初始化完毕的BeanFactory，那就先销毁它，“推翻重来”。</li>
<li><code>loadBeanDefinitions(DefaultListableBeanFactory factory)</code><br>
在refresh方法里执行。ApplicationContext 会扫描所有定义 Bean 的地方（XML、注解、Groovy 等），并将其放置到内部持有的这个 factory 里面（通常是一个 Map&lt;String, BeanDefinition&gt;）。</li>
</ul>
<h4 id="beanpostprocessor">BeanPostProcessor</h4>
<p>Bean初始化前后的「钩子」。它有两个方法：</p>
<ul>
<li><code>postProcessBeforeInitialization(Object bean, String beanName)</code><br>
在具体的Bean初始化前被 Spring 容器调用，并对 Bean 进行一系列操作。例如 <code>ApplicationContextAwareProcessor</code> 的该方法会根据 bean 的类型，为各个 Spring 基础组件设置默认的属性。</li>
<li><code>postProcessAfterInitialization(Object bean, String beanName)</code><br>
在具体的 Bean 初始化完成后被 Spring 容器调用，允许对 Bean 进行一系列后置的操作。<br>
注意，Spring 容器将会把这两个方法返回值作为新的 Bean 来替代原有的 Bean。本项目正是利用了这个特性来完成 Bean 的“偷天换日”。</li>
</ul>
<h4 id="instantiationawarebeanpostprocessor">InstantiationAwareBeanPostProcessor</h4>
<p>BeanPostProcessor 的子类。它新增了方法：</p>
<ul>
<li><code>postProcessPropertyValues(PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName)</code><br>
该方法会在 bean 属性组装时调用。这里的属性（pvs）来自于用户在 XML 中或代码里指定的 Bean 的字段或属性。事实上，Spring 正是利用它来完成了依赖注入，例如它的实现之一——<code>AutowiredAnnotationBeanPostProcessor</code> 会在这个方法里将 bean 中被 @Autowired 和 @Value 标记的字段注入具体的值或者对象。</li>
</ul>
<h3 id="spring-容器启动过程">Spring 容器启动过程</h3>
<p>有了上文的基础，Spring 容器的启动流程可以进一步描述为：<br>
<img src="https://yao177.github.io/post-images/1646040974089.svg" alt="Spring 启动流程" loading="lazy"></p>
<h3 id="spring-与本项目的联系">Spring 与本项目的联系</h3>
<ul>
<li>本项目利用 Spring 的<code>BeanPostProcessor</code>来将原有 Bean 替换为自定义动态代理对象</li>
<li>利用<code>ApplicationListener</code>来保证 Spring 启动完成前所有的异步方法执行完成</li>
</ul>
<h2 id="cglib">CGLIB</h2>
<h3 id="cglib-简述">CGLIB 简述</h3>
<p>CGLIB 是一个运行时的字节码生成工具。<br>
在平时，字节码文件都是编译时创建的。而 CGLIB 可以在运行时创建字节码，故称作“动态”代理。<br>
CGLIB 可以用来为某个类创建一个子类，并在其方法（非全部）被调用时进行拦截，执行自己的逻辑。<br>
在 Spring 的 AOP 场景中，CGLIB 被大量使用。</p>
<h3 id="cglib-的使用示例">CGLIB 的使用示例</h3>
<pre><code class="language-Java">public class CglibTest {
    public void print() {
        System.out.println(&quot;CglibTest#print be invoked&quot;);
    }

    public static void main(String[] args) {
        Enhancer enhancer = new Enhancer(); //CGLIB的工具类
        enhancer.setSuperclass(CglibTest.class); //需要设置一个父类
        enhancer.setCallback(new MethodInterceptor() { //方法拦截器，o为代理对象，method为被调用的方法，objects为方法参数，methodProxy为代理方法，通常用于执行父类（原类）方法
            @Override
            public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {
                System.out.println(&quot;CglibTestProxy#print be invoked&quot;);
                methodProxy.invokeSuper(o, objects); //执行父类方法
                return null;
            }
        });
        CglibTest cglibTest = (CglibTest) enhancer.create(); //创建代理对象
        cglibTest.print(); //执行方法
    }
}
</code></pre>
<p>输出结果</p>
<pre><code class="language-Shell">CglibTestProxy#print invoked
CglibTest#print invoked
</code></pre>
<p>运行示意图：<br>
<img src="https://yao177.github.io/post-images/1646041699356.svg" alt="cglib 代理流程" loading="lazy"></p>
<h3 id="cglib-和-jdk-动态代理的区别">CGLIB 和 JDK 动态代理的区别</h3>
<ul>
<li>使用区别：CGLIB 支持直接代理现成的类；JDK 只支持接口代理，应用场景被大打折扣。</li>
<li>效率区别：CGLIB 比 JDK 动态代理快出不止一个数量级。原因是拦截器入参中的 MethodProxy 里面会直接用原父类的引用进行方法调用，而非通过 Method 对象反射调用。<br>
读者可以简单理解为<code>super.print()</code>远比<code>super.class.getMethod(&quot;print&quot;).invoke()</code>快很多。这块实现较为复杂，由于篇幅限制，可以通过 <a href="https://zhuanlan.zhihu.com/p/106069224">CGLIB 动态代理的使用和分析</a> 简单了解。</li>
</ul>
<h3 id="注意事项">注意事项</h3>
<p>由于 CGLIB 本质是实现一个子类，因此它不能代理 final 修饰的类；<br>
由于 private、final 方法不能被继承，因此它的拦截器无法获取 private、final 修饰的方法；<br>
不要在<code>MethodProxy</code>中直接调用 invoke，这会导致循环调用，重复进入拦截器。应当只调用其<code>invokeSuper</code>方法。</p>
<h3 id="cglib-与本项目的联系">CGLIB 与本项目的联系</h3>
<p>利用 CGLIB 实现原有 Bean 的动态代理，配置自定义的方法策略。</p>
<h1 id="设计思路">设计思路</h1>
<p>由知识背景知，一个原生的 Spring 启动流程已在上文中举出。<br>
由项目背景得知，这个过程中耗时最长的是 Bean 的初始化。RPC 客户端与服务端建立连接、各个中间件连接池的创建等都在各自的 Bean 初始化中完成。这中间不乏复杂的计算逻辑和耗时的 IO 操作。倘若我们将 Bean 的初始化改成异步执行，那将实现 bean 的并行初始化，加快启动速度。</p>
<h2 id="提出目前的问题和对应解决方案">提出目前的问题和对应解决方案：</h2>
<ol>
<li>Bean 本身的初始化方法都是同步的，如何实现异步？——使用 CGLIB 代理，当执行初始化方法时放入线程池异步执行；</li>
<li>如何让 Spring 的 Bean 替换成我们的动态代理对象？——实现<code>BeanPostProcessor#postProcessBeforeInitialization</code>方法来在bean初始化前进行替换；</li>
<li>如何让保证 Bean 在被其他组件使用时，不会出现 Bean 未初始化完成的情况？——让 Bean 其他方法执行时同步等待其初始化完成；</li>
<li>如何保证 Spring 启动后，所有的 Bean 都初始化完成？——实现<code>ApplicationListener</code>来等待 Spring 启动完成通知，等待所有 Bean 初始化完成。<br>
至此，我们已经形成了解决思路，下节介绍项目具体实现。</li>
</ol>
<h1 id="原理介绍">原理介绍</h1>
<h2 id="项目概览">项目概览</h2>
<figure data-type="image" tabindex="1"><img src="https://yao177.github.io/post-images/1646048369211.svg" alt="优化启动流程" loading="lazy"></figure>
<h2 id="创建代理流程">创建代理流程</h2>
<figure data-type="image" tabindex="2"><img src="https://yao177.github.io/post-images/1646049504592.svg" alt="创建代理流程" loading="lazy"></figure>
<h2 id="前置校验">前置校验</h2>
<p>前置校验分为两部分，一是 Bean 的类能否创建 CGLIB 代理，二是该 Bean 的初始化方法能否被 CGLIB 代理。</p>
<h3 id="如何获取-bean-的初始化方法">如何获取 Bean 的初始化方法</h3>
<p>Spring Bean 有三种初始化方法（按执行顺序）：</p>
<ol>
<li><code>@PostConstruct</code>注解标记的方法<br>
获得方式：通过扫描类的方法注解可以过滤出。</li>
<li><code>InitializingBean</code>的<code>afterPropertiesSet</code>方法<br>
获得方式：直接反射获得之。</li>
<li>XML 中指定的<code>init-method</code>方法<br>
获得方式：反射获取该 Bean 的 <code>AbstractBeanDefinition</code> 的 <code>initMethodName</code> 字段。</li>
</ol>
<h3 id="校验类型">校验类型</h3>
<ol>
<li>该类能否被 CGLIB 代理
<ul>
<li>有无参构造函数</li>
<li>该类必须被声明为非 final 的</li>
<li>该类不能是 JDK 代理类或者 CGLIB 代理类</li>
</ul>
</li>
<li>该 Bean 的初始化方法能否被 CGLIB 代理
<ul>
<li>该方法必须被声明为非 final 的</li>
<li>该方法必须为非 static 或 private 的</li>
</ul>
</li>
</ol>
<h2 id="装配代理方法策略">装配代理方法策略</h2>
<blockquote>
<p>什么是代理方法策略：<br>
在代理对象被外部调用时，代理方法策略能将原有方法路由到不同的代理方法，以此确定方法的真正执行过程。</p>
</blockquote>
<p>在项目中，该策略实体是一个<code>ConcurrentHashMap</code>，key值为Method，value为WrappedMethod。<br>
<em>注：下表中original bean表示代理类持有的原bean的引用，method表示该方法策略被命中时，代理类被外部调用的方法</em></p>
<table>
<thead>
<tr>
<th>Bean 原有方法</th>
<th>代理策略</th>
<th>执行流程</th>
<th>附加说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>初始化方法</td>
<td>AsyncMethod</td>
<td>等待其依赖的 AsyncMethod 执行完毕后，在线程池中注册异步任务，对 original bean 执行 method。</td>
<td>该策略是项目能加速的原因。<br>其通过持有一个依赖的 AsyncMethod 引用，来保证初始化方法执行顺序是不变的。</td>
</tr>
<tr>
<td>Object.class的方法<br><code>FactoryBean#getObjectType</code></td>
<td>SyncMethod</td>
<td>直接令original bean执行method。</td>
<td>FactoryBean#getObjectType 的注释中明确说明，若方法返回 null 则表明该 bean 还未被初始化，因此提前调用是不违背 Spring 规范的。通过直接调用它来预测 FactoryBean#getObject 的返回类型，创建代理对象。</td>
</tr>
<tr>
<td>FactoryBean#getObject</td>
<td>ObjectProxyMethod</td>
<td>返回一个动态代理对象，该对象在被实际调用方法时必须等待其 FactoryBean 代理对象的所有 AsyncMethod 完成。</td>
<td>FactoryBean 初始化完成后，会调用 getObject，将返回值注入到 Spring 容器中。因此我们通过返回代理对象，在对象实际被调用的时候再等待 FactoryBean 初始化完成，来实现一个“懒加载”，增加并发度。</td>
</tr>
<tr>
<td>WrappedProxyBean#getOriginalBean<br>WrappedProxyBean#setOriginalBean</td>
<td>OriginalBeanGetterMethod<br>OriginalBeanSetterMethod</td>
<td>返回/设置该代理对象持有的original bean</td>
<td>这个组件内的所有代理对象都将实现 WrappedProxyBean 接口，用于返回/设置该代理对象持有的 original bean。</td>
</tr>
<tr>
<td>其余方法</td>
<td>DefaultMethod</td>
<td>等待该代理类的所有 AsyncMethod 完成时，执行 method。</td>
<td>其他方法调用时，必须等待所有 AsyncMethod 执行完成，以保证执行顺序不改变。</td>
</tr>
</tbody>
</table>
<p>下图是代理对象被执行时，代理方法策略的匹配过程。<br>
<img src="https://yao177.github.io/post-images/1646106362899.svg" alt="代理方法策略匹配流程" loading="lazy"></p>
<h2 id="对-factorybean-的特殊处理">对 FactoryBean 的特殊处理</h2>
<p>FactoryBean有两个重要方法：<code>getObject</code>、<code>getObjectType</code>。顾名思义，FactoryBean 是用来创建 Bean 的，因此在 FactoryBean 本身被创建后，Spring 会调用其 getObject 方法来获得一个新的 Bean，并注入到 Spring 容器中完成其整个生命周期。而 getObjectType 用于 FactoryBean 声明它所生产的 Bean 的类型。<br>
若我们不对 getObject 方法做处理，则在其被调用时，将会阻塞 Spring 线程。如图：<br>
<img src="https://yao177.github.io/post-images/1646106611326.svg" alt="阻塞spring流程" loading="lazy"><br>
如果我们令 FactoryBean 返回一个动态代理对象，并令动态代理对象被实际调用方法时，再等待 FactoryBean 初始化完成，则：<br>
<img src="https://yao177.github.io/post-images/1646106809424.svg" alt="不阻塞spring流程" loading="lazy"><br>
可以看到，对 getObject 的调用并没有阻塞 Spring 主线程，从而提高了启动速度。</p>
<h2 id="创建代理对象">创建代理对象</h2>
<ol>
<li>将 bean 的类型作为父类，将装配了代理方法策略的 MethodInterceptor 作为拦截器，利用 CGLIB 的 Enhancer 生成代理对象；</li>
<li>将该 Enhancer 实例存入缓存中，供之后相同类型的 Bean 直接使用，以此跳过前置校验和方法装配阶段；</li>
<li>将代理对象返回给 Spring 容器。</li>
</ol>
<h2 id="场景示例">场景示例</h2>
<p>假设有如下两个 Bean：</p>
<pre><code class="language-Java">@Bean
public class RpcClient implements FactoryBean, InitializingBean {
    RpcClient() {
    }
    public void afterPropertiesSet() {
        // do some socket work
    }
    public Object getObject() {
        return new RpcService();
    }
    public Class getObjectType() {
        return RpcService.class;
    }
    // other method
}
</code></pre>
<pre><code class="language-Java">@Bean
public Manger {
  @Resource
  RpcService rpcService;
  
  public String getName(int id) {
    return rpcService.getName(int id);
}
</code></pre>
<pre><code class="language-Java">public interface RpcService {
  String getName(int id);
}
</code></pre>
<p>当 Spring 启动时，本项目做以下事情：</p>
<ul>
<li>异步执行 RpcClient 的初始化方法，并返回 rpcClientProxy 给 Spring 容器；</li>
<li>Spring 执行 rpcClientProxy 的 getObject 方法，得到 rpcServiceProxy；</li>
<li>解决 Manger 依赖时，将 rpcServiceProxy 注入到 rpcService 字段；</li>
<li>当项目启动结束前，本项目将会等待 rpcClientProxy 的异步方法执行完毕。<br>
当<code>Manger#getName</code>被调用时：<br>
<img src="https://yao177.github.io/post-images/1646112526954.svg" alt="Manger#getName" loading="lazy"></li>
</ul>
<p>当 Spring 启动完成前，本项目会等待所有的异步方法执行完毕。因此当用户请求打入时，并不存在等待的过程。</p>
<h1 id="风险评估">风险评估</h1>
<p>本项目人为修改了部分 Spring 加载 Bean 的流程，因此不可避免地需要进行一些风险评估。</p>
<h2 id="如何保证代理对象的行为和原有-bean-的属性-行为一致">如何保证代理对象的行为和原有 Bean 的属性、行为一致？</h2>
<p>代理对象没有修改原有 Bean 的方法逻辑，它持有一个原有 bean 的引用，任何方法调用最终都会调用原有 bean 方法，因此属性和行为是没有变动的。</p>
<h2 id="如何保证代理对象方法执行顺序不会错乱">如何保证代理对象方法执行顺序不会错乱？</h2>
<p>本项目通过为所有的异步方法指定执行顺序，来保证它们不会并发执行；而对于其他方法，除能直接执行的方法 (Object.class 的方法、getObjectType 方法) 外，其余均需要等待初始化完成，保证了 Bean 相关代码的执行顺序。</p>
<h2 id="其他可能的风险如何解决">其他可能的风险如何解决？</h2>
<p>在初始化方法中操作 BeanFactory 可能导致项目死锁，无法启动。<br>
任何通过 BeanFactory 获取或操作 Bean 的行为都会被 Spring 并发控制。具体实现是通过 synchronized 获取 singletonObjects（<code>ConcurrentHashMap&lt;String, Object&gt;</code>，存放所有单例 Bean 的容器）的对象锁来避免同时操作单例 Bean 容器。<br>
由于 BeanPostprocessor 处于 Bean 加载的上下文中，因此总是持有 singletonObjects 的对象锁；若 Bean 在初始化方法中利用 beanFactory 操作其他 Bean ，则会导致如下情况：<br>
<img src="https://yao177.github.io/post-images/1646113568033.svg" alt="对象锁" loading="lazy"><br>
因此本项目通过死锁超时检测，当主线程序阻塞一定时间后（例如20s），抛出导致死锁的类名，用户可以在注解中通过 exclude 指定不为该类创建动态代理。</p>
<h1 id="总结">总结</h1>
<p>至此，项目已介绍完成，想随便聊聊。<br>
本质上，这个项目就是利用了懒加载特性，先有个壳，再加载真正的 Bean 实体；其实这个思想在算法中也很常见，例如二分思想的经典算法——线段树，利用 lazy propagation (惰性传播) 在父节点打上修改的标记而不直接修改，只有真正访问到时才往子节点进行传递，提升了效率。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java 基础｜快速失败机制]]></title>
        <id>https://yao177.github.io/post/java-ji-chu-orkuai-su-shi-bai-ji-zhi/</id>
        <link href="https://yao177.github.io/post/java-ji-chu-orkuai-su-shi-bai-ji-zhi/">
        </link>
        <updated>2020-09-15T12:56:55.000Z</updated>
        <content type="html"><![CDATA[<h1 id="基本介绍">基本介绍</h1>
<p>在使用迭代器对集合对象进行遍历的时候，如果 A 线程对集合进行遍历，正好 B 线程对集合进行修改（增加、删除、修改）则 A 线程会抛出 <code>ConcurrentModificationException</code> 异常。</p>
<h1 id="原理">原理</h1>
<p>迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount 变量。集合在被遍历期间如果内容发生变化，就会改变 modCount 的值。每当迭代器使用 hashNext()/next() 遍历下一个元素之前，都会检测 modCount 变量是否为 expectedmodCount 值，是的话就返回遍历；否则抛出异常，终止遍历。</p>
<h2 id="为什么-util-中的集合类遍历时不会快速失败">为什么 util 中的集合类遍历时不会快速失败？</h2>
<p>异常的抛出条件是检测到 modCount ≠ expectedmodCount 这个条件，而遍历时发生变化会同事给 expectedmodCount 值 +1，因此不会出现问题</p>
<h2 id="javautil-中哪些集合不能在多线程下使用">java.util 中哪些集合不能在多线程下使用？</h2>
<p>都不可以，都是快速失败的，不能在多线程下发生并发修改</p>
<h1 id="安全失败">安全失败</h1>
<p>采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。</p>
<p>因此，安全失败时，迭代器不能访问修改后的内容</p>
<p>java.util.concurrent 都是安全失败，可以在多线程下并发使用和修改</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java 基础｜几个小疑惑]]></title>
        <id>https://yao177.github.io/post/java-ji-chu-orji-ge-xiao-yi-huo/</id>
        <link href="https://yao177.github.io/post/java-ji-chu-orji-ge-xiao-yi-huo/">
        </link>
        <updated>2020-09-15T12:53:48.000Z</updated>
        <content type="html"><![CDATA[<h1 id="为什么要有-object-类">为什么要有 Object 类？</h1>
<p>可以理解为一个基础的模版类，提供 <code>hashcode()</code>、<code>compareTo()</code>、<code>toString()</code> 等基础函数模版</p>
<h1 id="对象变量和引用的关系">对象变量和引用的关系？</h1>
<p>每个对象变量都属于一个类型</p>
<p>子类引用赋给超类时，OK</p>
<p>超类引用赋给子类时，必须进行类型转换（类似 C++ 中的 dynamic_cast 操作）；先用 instanceof 检验一下是否可以转换</p>
<pre><code class="language-java">if (staff[1] instanceof Manager) {	
		boss = (Manager) staff[1]; // OK	...
}
String c = (String) staff[1]; // Fail
</code></pre>
<ul>
<li>只能在继承层次内进行类型转换</li>
<li>在将超类转换成子类之前，应该使用 instanceof 进行检查</li>
<li>多态的动态绑定机制可以自动找到响应方法，只有在使用「特定方法」时才会需要类型转换——超类的设计不够合理</li>
</ul>
<h1 id="null-检查应该在什么时候">null 检查应该在什么时候</h1>
<p>给别人前，拿到之后</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java 基础｜OOP 面向对象]]></title>
        <id>https://yao177.github.io/post/java-ji-chu-ormian-xiang-dui-xiang/</id>
        <link href="https://yao177.github.io/post/java-ji-chu-ormian-xiang-dui-xiang/">
        </link>
        <updated>2020-09-15T12:51:04.000Z</updated>
        <content type="html"><![CDATA[<h1 id="基础">基础</h1>
<p>数据第一位，适合规模较大的使用场景</p>
<ul>
<li>行为 behavior：public 方法</li>
<li>状态 state：被动通过调用方法改变</li>
<li>标识 identity</li>
</ul>
<p>开发流程：设计类，添加方法</p>
<h3 id="类间关系">类间关系</h3>
<ul>
<li>依赖「uses-a」</li>
<li>聚合「has-a」</li>
<li>继承「is-a」</li>
</ul>
<p>这是 PlantUML 的中文教程，可以用纯代码的方式画 UML 图（原理类似于 Markdown 语法）</p>
<p>PlantUML_Language_Reference_Guide_zh.pdf2.00MB</p>
<h3 id="对象引用">对象引用</h3>
<p>比较像 C++ 中的对象指针，不拷贝无副本</p>
<p>想要实现深拷贝需要使用 clone 方法</p>
<p>clone 真的是深拷贝吗？尝试后发现，引用类型属性更改后同时更改 -&gt; 浅拷贝！</p>
<p>想要深拷贝，必须实现 Cloneable，并覆写 clone 方法 -&gt; 代码繁琐</p>
<p>搜索后得知，可以使用序列化对象的方法——将对象转成二进制流，然后再把二进制流反序列成一个java对象，这时候反序列化生成的对象是一个全新的对象，里面的信息与原对象一样，但是所有内容都是一份新的</p>
<p>所有类都需要实现 Serializable 接口，以便进行序列化操作</p>
<pre><code class="language-java">public class DeepClone implements Serializable{
		private static final long serialVersionUID = 1L;
		/** 
			* 利用序列化和反序列化进行对象的深拷贝 
			* @return * @throws Exception 
			*/	
		protected Object deepClone() throws Exception{	
		//序列化	
		ByteArrayOutputStream bos = new ByteArrayOutputStream();	
		ObjectOutputStream oos = new ObjectOutputStream(bos);	
		oos.writeObject(this);	
		//反序列化	
		ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray());	
		ObjectInputStream ois = new ObjectInputStream(bis);	
		return ois.readObject();	
		}
}
</code></pre>
<h3 id="更改器-访问器">更改器 访问器</h3>
<p>Date 类、LocalDate 类、GregorianCalendar 类</p>
<p>访问器方法：LocalDate 在调用 plusDays 方法后会生成一个新的对象，而不会更改本来的 LocalDate 对象（类似 toUpperCase）</p>
<p>更改器方法：GregorianCalendar 类调用 add 方法时就会更改现有对象状态</p>
<h3 id="对象创建-方法">对象创建 方法</h3>
<ul>
<li>在堆中</li>
<li>需要用 new 操作符</li>
<li>区别于 C++（<code>Object::Fuction()</code>），直接在类内部定义即可（JVM 决定是否内联）</li>
</ul>
<h3 id="封装">封装</h3>
<p>一个私有数据域 + 一个公有域访问器方法 + 一个公有域更改器方法</p>
<p>不要编写返回引用可变对象的访问器方法｜一个可变数据域的拷贝，实在需要必须先 clone</p>
<p>public &gt; default（默认，package 内） &gt; protected &gt; private</p>
<h3 id="final-修饰符">final 修饰符</h3>
<ol>
<li>应修饰「基本类型」/「不可变类」的数据域</li>
<li>若修饰一个可变类，只是限制了不可以引用其它对象，但该对象可以更改</li>
</ol>
<h3 id="static-修饰符">static 修饰符</h3>
<ol>
<li>静态域（private static 数据域）：类对象共享，可修改，只能用类名+方法访问</li>
<li>静态常量（public static final 数据域）：Math.PI, System.Out</li>
<li>静态方法（static 方法）：无 this 参数 -&gt; 不能访问实例域；可以访问静态域，可以用对象变量调用</li>
<li>工厂方法（工厂模式——定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行）：使用静态方法构造对象</li>
<li>main 方法：每个类都可以有一个 main 方法（常用于测试），可单独运行也可运行这个项目</li>
</ol>
<h3 id="修饰符顺序">修饰符顺序</h3>
<p>Java 语言规范建议按以下顺序列出修饰符：</p>
<ol>
<li>Annotations</li>
<li>public</li>
<li>protected</li>
<li>private</li>
<li>abstract</li>
<li>static</li>
<li>final</li>
<li>transient</li>
<li>volatile</li>
<li>synchronized</li>
<li>native</li>
<li>strictfp</li>
</ol>
<h3 id="方法の参数">方法の参数</h3>
<p>基本类型复制拷贝，对象引用使用引用值（依然是值，相当于一个 final）即不能进行新的引用</p>
<h1 id="对象构造">对象构造</h1>
<h3 id="重载-overloading-resolution">重载 overloading resolution</h3>
<p>唯一性——方法签名（signature）</p>
<ul>
<li>方法名</li>
<li>参数类型</li>
<li><s>返回类型</s></li>
</ul>
<p>和 C++ 中一样，如果方法名和参数类型都一致而返回类型不一致，就会报错——重复定义方法</p>
<h3 id="构造函数">构造函数</h3>
<ol>
<li>默认构造为默认数值</li>
</ol>
<ul>
<li>数值：0</li>
<li>布尔值：False</li>
<li>对象引用：null</li>
</ul>
<p>不推荐使用默认构造，因为当使用 getXxx 方法时，会获得一个 null 引用</p>
<p>this 可以调用另一个构造起</p>
<ol start="2">
<li>如果写了构造器，那就必须包括一个无参构造 / 显式域初始化（声明中赋值）/ 初始化块（{这里进行初始化}）</li>
</ol>
<p>静态初始化块可以方便得对静态域进行初始化</p>
<pre><code class="language-java">// static initialization block
static {	
		Random generator = new Random();	
		nextId = generator.nextInt(1000);
}
</code></pre>
<p>析构：因为 GC 机制，Java 不支持析构器</p>
<h3 id="导入类">导入类</h3>
<p>import package 中，「<em>」只可以导入一个包，而不可以使用 import java.</em> 或者 import java.<em>.</em>；与 C++ 中不同的是，include 必须添加以载入外部特性，而 Java 中给全包名可以不使用 import，类似于 using namespace。也可以导入静态方法和静态域，import lang.System.out;</p>
<p>类放入包，package com.x.xx.xxx 对应文件目录为 com/x/xx/xxx 中，如果不匹配，虚拟机就找不到类（可编译不可运行）。</p>
<h3 id="类设计">类设计</h3>
<ol>
<li>
<p>数据私有</p>
</li>
<li>
<p>数据初始化</p>
</li>
<li>
<p>用其它类代替多个相关的基本类型：便于处理</p>
<pre><code class="language-java">private String street;
private String city;
private String state;
private int zip;
// turn to class Address
private Address addr;
</code></pre>
</li>
<li>
<p>不是所有的域都需要独立的域访问器和域更改器：会有一些私有不想被外界修改的实例域</p>
</li>
<li>
<p>将职责过多的类进行分解</p>
</li>
<li>
<p>类名和方法名能够体现他们的职责：类名通常是带有形容词修饰的名次，方法通常是动宾结构</p>
</li>
<li>
<p>优先使用不可变的类：计算生成返回新值，而不是修改更新原来的值；一些情况会很奇怪</p>
</li>
</ol>
<h1 id="继承">继承</h1>
<p>superclass 超类，subclass 子类；通用方法放超类，特殊用途放子类</p>
<h3 id="覆盖-override">覆盖 override</h3>
<pre><code class="language-java">public class Manager extends Employee {	
		... 
		public double getSalary() {	
				return salary + bonus; // won't work	
				return getSalary() + bonus; // still won't work	
				return super.getSalary() + bonus; // works	
				... 
				} 
		...
}
</code></pre>
<ul>
<li>使用 super 调用超类的方法</li>
<li>不是引用，不能赋给另一个对象变量</li>
<li>也可用 super 调用超类的构造器</li>
</ul>
<h2 id="多态">多态</h2>
<ul>
<li>同一个变量可以引用一个超类对象，也可以引用它的任一子类对象</li>
<li>置换法则：程序中出现超类对象的任何地方都可以用子类对象置换</li>
<li>子类的引用可以转为超类的引用，但超类的引用无法赋给子类变量</li>
<li>子类数组引用可以转换为超类数组引用，再赋值为超类时会导致类型错误</li>
<li>private、static、final 方法时，准确知道调用哪个方法，称为静态绑定（static binding）</li>
<li>动态绑定（dynamic binding），VM 维护一个方法表（method table）查找调用方法</li>
<li>子类方法不能低于超类方法的可见性，尽量将通用域和方法都放在超类中</li>
<li>调用方法过程：VM 提取类的实际类型的<em>方法表</em>，然后搜索定义该方法签名的类（此时）</li>
</ul>
<h3 id="抽象类">抽象类</h3>
<ul>
<li>占位，不可实例化，具体实现在子类中</li>
<li>抽象类对象只能引用非抽象子类对象；</li>
</ul>
<h3 id="object-所有类的超类">Object 所有类的超类</h3>
<p>定义子类 equals 需要先调用超类的 equals，再比较子类中的实例域</p>
<p>防止可能为 null，使用 Objects.equals 方法判断</p>
<p>equals 要求：自反性、对称性、传递性、一致性</p>
<p>覆盖超类方法时使用 @Override 进行标记</p>
<p>默认的 hashCode 散列码为对象的存储地址（String 有着相同的散列码，StringBuilder 没有定义所以不同）；Objects.hash 可以提供多个参数；Arrays.hashCode</p>
<p>toString：类名 + [域值]；x.toString == &quot;&quot;+x 会自动调用 toString；Arrays.toString / Array.deepToString 多维数组</p>
<h3 id="泛型数组列表">泛型数组列表</h3>
<p>ArrayList&lt;type_parameter&gt;() 采用类型参数的泛型类，类似 C++ 中的 vector 模版，确认大小不再变化后可以调用 trimToSize 方法，让 GC 回收多余的存储空间；使用 add、get、set 访问和修改</p>
<h3 id="包装器-自动装箱">包装器 &amp; 自动装箱</h3>
<p>前六个有共同的超类 Number，Void 即 null</p>
<p>可自动拆箱、装箱；包装器对象比较时调用 equals 方法；装箱时 null 会报空指针异常；包装器都是 final 不可变的</p>
<h3 id="参数数量可变的方法">参数数量可变的方法</h3>
<p>fuction(String mine, Object... args) {}</p>
<p>防止重载相同的错误 <a href="https://www.cnblogs.com/lanxuezaipiao/p/3190673.html">https://www.cnblogs.com/lanxuezaipiao/p/3190673.html</a></p>
<h1 id="几个小问题">几个小问题</h1>
<ol>
<li>什么时候用继承，继承和组合的关系是什么：is、has聚合/contain组合</li>
<li>什么是多态，在继承的体系中是怎么样的，为什么要用多态：同样方法，不同对象，不同实现；子类方法被超类所用，维护扩展</li>
<li>重载和重写的区别：都是多态</li>
<li>值传递和引用传递：基本类型传值，对象传地址（值）</li>
<li>自动拆装箱的使用（什么时候）：表达式计算——先拆再算后装，类型转换 toString</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java 基础｜Java 集合]]></title>
        <id>https://yao177.github.io/post/java-ji-chu-orjava-ji-he/</id>
        <link href="https://yao177.github.io/post/java-ji-chu-orjava-ji-he/">
        </link>
        <updated>2020-09-15T10:09:15.000Z</updated>
        <content type="html"><![CDATA[<h1 id="总述">总述</h1>
<ul>
<li><em>Collection</em>
<ul>
<li><em>List</em>：有序可重
<ul>
<li><em>LinkedList</em></li>
<li><em>ArrayList</em></li>
</ul>
</li>
<li><em>Set</em>：不可重
<ul>
<li><em>HashSet</em>：无序；类 HashMap</li>
<li><em>LinkedHashSet</em>：有序；类 LinkedHashMap</li>
<li><em>TreeSet</em>：无序；类 TreeMap</li>
</ul>
</li>
</ul>
</li>
<li><em>Map</em>：不可重
<ul>
<li><em>HashMap</em>：无序</li>
<li><em>LinkedHashMap</em>：有序</li>
<li><em>TreeMap</em>：无序</li>
</ul>
</li>
</ul>
<hr>
<h1 id="单独详解">单独详解</h1>
<h2 id="linkedlist">LinkedList</h2>
<figure data-type="image" tabindex="1"><img src="https://yao177.github.io/post-images/1600164949835.png" alt="LinkedList 类图" loading="lazy"></figure>
<h3 id="基本介绍">基本介绍</h3>
<ol>
<li>双向链表，头尾双指针</li>
<li>队列使用：头进尾出，FIFO；栈使用：头进头出，FILO</li>
<li>无限扩容</li>
<li>功能上类似 ArrayList + ArrayDeque</li>
</ol>
<h3 id="是否有虚拟头节点">是否有虚拟头节点？</h3>
<ol>
<li>无</li>
<li>添加和删除时会判断是否为唯一节点</li>
</ol>
<h3 id="反转链表操作">反转链表操作</h3>
<ol>
<li>
<p>递归，空间复杂度 O(1)</p>
<pre><code class="language-java">public ListNode Reverse(ListNode list) {
    if (list == null) return null; // first question

    if (list.next == null) return list; // second question

    // third question - in Lisp this is easy, but we don't have cons
    // so we grab the second element (which will be the last after we reverse it)

    ListNode secondElem = list.next;

    // bug fix - need to unlink list from the rest or you will get a cycle
    list.next = null;

    // then we reverse everything from the second element on
    ListNode reverseRest = Reverse(secondElem);

    // then we join the two lists
    secondElem.Next = list;

    return reverseRest;
}
</code></pre>
</li>
<li>
<p>双指针</p>
</li>
<li>
<p>当成栈，推入另一个栈，空间复杂度 O(N)</p>
</li>
</ol>
<h3 id="时间复杂度">时间复杂度</h3>
<ul>
<li>随机访问：O(N)</li>
<li>查找：O(N)</li>
<li>插入删除
<ul>
<li>头尾：O(1)</li>
<li>中部：O(N)</li>
</ul>
</li>
</ul>
<h2 id="arraylist">ArrayList</h2>
<figure data-type="image" tabindex="2"><img src="https://yao177.github.io/post-images/1600164973242.png" alt="ArrayList 类图" loading="lazy"></figure>
<h3 id="基本介绍-2">基本介绍</h3>
<ol>
<li>较普通数组来讲，具有动态扩展的能力，因此也可称之为「动态数组」</li>
<li>默认长度为 10，扩容每次是 1.5 倍（<code>oldCapacity + (oldCapacity &gt;&gt; 1)</code>）</li>
<li>删除元素不会缩容，最后一位置 <code>nul</code>便于 GC 回收</li>
<li>并集<code>addAll()</code>，交集<code>retainAll()</code>，单向差集<code>removeAll()</code></li>
</ol>
<h3 id="初始化">初始化</h3>
<ul>
<li>new ArrayList()：从 10 开始，逐步扩容</li>
<li>new ArrayList(0)：从 0 开始，到 1，逐步扩容</li>
</ul>
<h3 id="如何插入元素如何扩容">如何插入元素？如何扩容</h3>
<ol>
<li>检查是否需要扩容</li>
<li><code>elementData</code>为<code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code>则初始化容量为<code>DEFAULT_CAPACITY</code>也就是 10</li>
<li>新容量是老容量的1.5倍（<code>oldCapacity + (oldCapacity &gt;&gt; 1)</code>）；如果加了这么多容量发现比需要的容量还小，则以需要的容量为准；如果超过新容量超过最大容量，则使用最大容量</li>
<li>创建新容量的数组并把老数组拷贝到新数组</li>
</ol>
<p>PS：有个注意点，扩容函数传入的是 oldCap + 1，保证了数组大小小于 2 的情况下不会不扩容</p>
<h2 id="hashset">HashSet</h2>
<figure data-type="image" tabindex="3"><img src="https://yao177.github.io/post-images/1600165004129.png" alt="HashSet 类图" loading="lazy"></figure>
<p>一个 HashMap，key 为值、value 为<code>PRESENT</code></p>
<h2 id="linkedhashset">LinkedHashSet</h2>
<p>一个 LinkedHashMap，key 为值、value 为<code>PRESENT</code></p>
<h2 id="treeset">TreeSet</h2>
<p>一个 TreeMap，key 为值、value 为<code>PRESENT</code></p>
<h2 id="hashmap">HashMap</h2>
<figure data-type="image" tabindex="4"><img src="https://yao177.github.io/post-images/1600165019290.png" alt="HashMap 类图" loading="lazy"></figure>
<h3 id="基本介绍-3">基本介绍</h3>
<ol>
<li>key-value 存储结构，数组 + 链表 + 红黑树的结构</li>
<li>查询和修改速度很快，能达到 O(1) 的平均时间复杂度</li>
<li>容量为数组长度，默认 16，最大为 2^30，达到 64 时可以树化；装载因子用来计算容量达到多少时进行扩容，默认装载因子为 0.75</li>
<li>数组容量≥64 &amp; 链表长度≥8 进行树化，链表长度≤6 时反树化</li>
</ol>
<h3 id="节点">节点</h3>
<ul>
<li>
<p>链表节点<code>Node</code></p>
<pre><code class="language-java">static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {
    final int hash;
    final K key;
    V value;
    Node&lt;K,V&gt; next;
}
</code></pre>
</li>
<li>
<p>红黑树节点<code>TreeNode</code></p>
<pre><code class="language-java">// 位于HashMap中
static final class TreeNode&lt;K,V&gt; extends LinkedHashMap.Entry&lt;K,V&gt; {
    TreeNode&lt;K,V&gt; parent;  // red-black tree links
    TreeNode&lt;K,V&gt; left;
    TreeNode&lt;K,V&gt; right;
    TreeNode&lt;K,V&gt; prev;    // needed to unlink next upon deletion
    boolean red;
}

// 位于LinkedHashMap中，典型的双向链表节点
static class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; {
    Entry&lt;K,V&gt; before, after;
    Entry(int hash, K key, V value, Node&lt;K,V&gt; next) {
        super(hash, key, value, next);
    }
}
</code></pre>
</li>
</ul>
<h3 id="hash-过程">Hash 过程</h3>
<p>key 为 null，hash 值为 0</p>
<p>高 16 位与整个 hash 值异或，为了使计算出的 hash 更分散</p>
<p><code>n % k == n &amp; (k - 1)</code></p>
<p>解决 hash 冲突的办法是「拉链法」，而 Java 的 ThreadLocalMap、Python 的 dict 则使用了开放寻址法</p>
<h3 id="插入节点过程">插入节点过程</h3>
<ol>
<li>计算 key 的 hash</li>
<li>桶数量为 0，则初始化桶</li>
<li>三种情况
<ol>
<li>key 所在桶无元素，直接插入</li>
<li>key 所在桶的第一个元素的 key 与待插入的 key 相同，说明找到了元素，转到「5」</li>
<li>第一个元素为树节点，调用<code>putTreeVal()</code></li>
</ol>
</li>
<li>不是这三种情况，则遍历桶对应的链表查找 key 是否存在
<ol>
<li>找到了对应 key 的元素，转到「5」</li>
<li>没找到对应 key 的元素，则在链表最后插入一个新节点并判断是否需要树化</li>
</ol>
</li>
<li>找到了对应 key 的元素，则判断是否需要替换旧值，并直接返回旧值</li>
<li>如果插入了元素，则数量 +1 并判断是否需要扩容</li>
</ol>
<h3 id="尾插法">尾插法</h3>
<p>Java 7 及之前是头插法：后面的值被查找的概率更大一些</p>
<p>尾插法：扩容分链前后链表顺序不变，保持了之前节点的引用关系，防止 1-&gt;2-&gt;1 的死链产生</p>
<p>依旧不是线程安全的，put / get 依旧没有同步锁，会出现 ABA 的问题</p>
<h3 id="扩容机制">扩容机制</h3>
<p>桶为空的话，第一次加入元素时进行初始化</p>
<p>扩容门槛为传入的初始容量往上取最近的 2^n</p>
<p>拷贝原数组</p>
<h2 id="linkedhashmap">LinkedHashMap</h2>
<figure data-type="image" tabindex="5"><img src="https://yao177.github.io/post-images/1600165037900.png" alt="LinkedHashMap 类图" loading="lazy"></figure>
<h3 id="accessorder-是什么">accessOrder 是什么</h3>
<p>先看看在哪里使用了</p>
<pre><code class="language-java">public V get(Object key) {
    Node&lt;K,V&gt; e;
    if ((e = getNode(hash(key), key)) == null)
        return null;
    if (accessOrder)
        afterNodeAccess(e);
    return e.value;
}
</code></pre>
<p>看一下 <code>afterNodeAccess()</code>的代码，可以看到最大的不同就是，调用 get 方法时，都会将访问的 Node 移动到尾部，成为尾节点，也就是控制了访问顺序。</p>
<p>因此，置为 true 后，则使用 LRU 调度算法（最近最少使用）。</p>
<h2 id="treemap">TreeMap</h2>
<figure data-type="image" tabindex="6"><img src="https://yao177.github.io/post-images/1600165054964.png" alt="TreeMap 类图" loading="lazy"></figure>
<h3 id="基本介绍-4">基本介绍</h3>
<ul>
<li>实现了 SortedMap 接口，因此是经过排序的</li>
<li>只使用到了红黑树，所以时间复杂度为 O(log N)</li>
</ul>
<h3 id="排序问题">排序问题</h3>
<p>红黑树根据 key 进行排序，有两种方式</p>
<ol>
<li>key 实现 Comparable 接口</li>
<li>构造时传入比较器</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java 基础｜Java String]]></title>
        <id>https://yao177.github.io/post/java-ji-chu-orjava-string/</id>
        <link href="https://yao177.github.io/post/java-ji-chu-orjava-string/">
        </link>
        <updated>2020-09-15T10:05:50.000Z</updated>
        <content type="html"><![CDATA[<h1 id="string-字符串">String 字符串</h1>
<p>Unicode 字符序列</p>
<p>C++ 中的 <code>char*</code></p>
<pre><code class="language-java">substring(start_index, first_excluded_index)
length(substring(a, b)) = b - a
str_a.equals(str_b) = (str_a.compareTo(str_b) == 0)
str_a.equalsIgnore(str_b)
</code></pre>
<h2 id="不可变">不可变</h2>
<ul>
<li>用 <code>String.substring()</code> 和 <code>+</code> 拼接后重新赋值</li>
<li>效率？→ 字符串共享
<ul>
<li>仅字符串常量，其他+/substring 生成的不共享 → <code>==</code> 不能用来测试相等性</li>
</ul>
</li>
<li>怎么不可变？（用 C++ 的 <code>char*</code> 比较好理解）</li>
<li>指向的位置上的字符串内存不可变，</li>
</ul>
<h2 id="vs-equals-vs-compareto"><code>==</code> VS <code>equals()</code> VS <code>compareTo()</code></h2>
<pre><code class="language-java">// equals 源码
public boolean equals(Object anObject) {
    if (this == anObject) { // 内存位置一致
        return true;
    }
    if (anObject instanceof String) {
        String anotherString = (String) anObject; // 其它类型先转换为 String 类型
        int n = value.length;
        if (n == anotherString.value.length) {
            char v1[] = value;
            char v2[] = anotherString.value;
            int i = 0;
            while (n-- != 0) {
                if (v1[i] != v2[i]) return false;
                i++;
            }
            return true;
        }
    }
    return false;
}

// compareTo 源码
public int compareTo(String anotherString) {
		int len1 = value.length; int len2 = anotherString.value.length; 
		int lim = Math.min(len1, len2); 
		char v1[] = value; char v2[] = anotherString.value; 
		int k = 0; 
		while (k &lt; lim) { // 字典序大小比较 
				char c1 = v1[k]; 
				char c2 = v2[k]; 
				if (c1 != c2) { 
							return c1 - c2; 
				} 
				k++; 
		} 
		return len1 - len2;
}
</code></pre>
<p>equals 类似 C++ 中的 <code>==</code>，compareTo 类似 <code>strcmp</code></p>
<ul>
<li>返回值不同
<ul>
<li>equals 只判断是否相同</li>
<li>compareTo 判断大小比较，正大负小=同</li>
</ul>
</li>
<li>比较类型不同
<ul>
<li>equals 可以和非字符串进行比较，转换为 String 类型</li>
<li>compareTo 只能和字符串变量比较</li>
</ul>
</li>
<li>效率
<ul>
<li>equals 比 compareTo 稍微快一些（加了一些前置判断），如果只判断是否相等建议使用 equals</li>
</ul>
</li>
<li>使用范围
<ul>
<li>Object 自带 equals 方法，基本都可用（默认实现为 <code>==</code>）</li>
<li>实现了 Comparable 接口的类才有 compareTo 方法</li>
</ul>
</li>
</ul>
<h2 id="空串和-null-串">空串（&quot;&quot;）和 null 串</h2>
<p>空串，长度为「0」、内容为「空」的 String 对象</p>
<p>null 串，无对象（类似于“空指针”），不是 String 对象，不可以使用 String 的方法</p>
<p><code>if (str != null &amp;&amp; str.length() != 0) {...} if (str != null &amp;&amp; !str.equals(&quot;&quot;)) {...}</code></p>
<h2 id="码点-代码单元">码点、代码单元</h2>
<p>char 是「一个采用 UTF-16 编码表示的代码单元」，用来表示 Unicode 码点。</p>
<p>UTF-16 有一些用两个字节表示一个符号的情况，</p>
<p>编号为 U+D800 至 U+DBFF 的规定为「High Surrogates」，共 102 4个；编号为 U+DC00 至 U+DFFF 的规定为「Low Surrogates」，也是 1024 个；他们组合出现，就又可以多表示 1048576 种字符。</p>
<p>一个字符对应一个码点，因此有可能是 1 也有可能是 2 个字节</p>
<h2 id="stringbuilder-vs-stringbuffer">StringBuilder vs StringBuffer</h2>
<p>用于 String 拼接的 <code>+</code> 即是 SringBuilder，查看字节码可知</p>
<pre><code class="language-java">LINENUMBER 28 L3
NEW java/lang/StringBuilder
DUP
INVOKESPECIAL java/lang/StringBuilder.&lt;init&gt; ()V
ALOAD 0
INVOKEVIRTUAL java/lang/StringBuilder.append (Ljava/lang/String;)Ljava/lang/StringBuilder;
ALOAD 1
INVOKEVIRTUAL java/lang/StringBuilder.append (Ljava/lang/String;)Ljava/lang/StringBuilder;
INVOKEVIRTUAL java/lang/StringBuilder.toString ()Ljava/lang/String;
ASTORE 3
</code></pre>
<p>也就是说，调用了</p>
<pre><code class="language-java">c = a + b;
c = new StringBuilder().append(a).append(b).toString();
// 如果有性能需求
c = new StringBuilder(a.length() + b.length()).append(a).append(b).toString();
// 可正确调整缓冲区大小，并防止 JVM 重新调整缓冲区大小并创建垃圾以进行收集
</code></pre>
<p>顺便看一下StringBuilder.append()的源码：</p>
<pre><code class="language-java">public AbstractStringBuilder append(String str) {
    if (str == null) {
        return appendNull();
    }
    int len = str.length();
    ensureCapacityInternal(count + len);
    putStringAt(count, str);
    count += len;
    return this;
}

private final void putStringAt(int index, String str) {
    if (getCoder() != str.coder()) {
        inflate();
    }
    str.getBytes(value, index, coder);
}

void getBytes(byte dst[], int dstBegin, byte coder) {
    if (coder() == coder) {
        System.arraycopy(value, 0, dst, dstBegin &lt;&lt; coder, value.length);
    } else { // this.coder == LATIN &amp;&amp; coder == UTF16 
        StringLatin1.inflate(value, 0, dst, dstBegin, value.length);
    }
}
</code></pre>
<p>有点类似 C++ 中 strcpy 的做法，直接拷贝内存地址上的内容</p>
<p>关于<em>线程安全</em>，StringBuilder 是不安全的，StringBuffer 是安全的；StringBuffer 源码中每个方法都添加了 <strong>synchronized</strong> 关键字，举个例子</p>
<pre><code class="language-java">public synchronized StringBuffer append(String str) {
    toStringCache = null;
    super.append(str);
    return this;
}
</code></pre>
<p>~~如果手动添加 <strong>synchronized</strong> 关键字呢？~~不要这样使用</p>
<pre><code class="language-java">public class Foo { // safe ? 
    private final static StringBuilder builder;

    public static void foo() { // safe ? 
        builder = new StringBuilder();
    }

    public static void foo(final String a) { // unsafe ? 
        builder.append(a);
    }

    public synchronized void bar(final String a) { // safe ? 
        builder.append(a);
    }
}
</code></pre>
<h1 id="结论">结论</h1>
<p><strong>直接使用 StringBuilder 局部变量，用完即销毁就可以！</strong></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数据库｜ES 基础]]></title>
        <id>https://yao177.github.io/post/es-ji-chu/</id>
        <link href="https://yao177.github.io/post/es-ji-chu/">
        </link>
        <updated>2020-09-15T10:00:34.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/5.1/index.html">Elasticsearch Reference</a></p>
<h1 id="安装">安装</h1>
<pre><code class="language-bash">curl -L -O https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-5.3.3.tar.gz
tar -xvf elasticsearch-5.3.3.tar.gz
cd elasticsearch-5.3.3/bin
./elasticsearch
</code></pre>
<p>当看到 &quot;[node_name] started&quot;，代表 node 已经启动了</p>
<h1 id="使用">使用</h1>
<p>node -&gt; indice -&gt; document</p>
<p>ES 使用 RESTful API 的风格进行操作</p>
<pre><code class="language-bash">curl -X &lt;action&gt; '&lt;protocol&gt;://:/?&lt;query_string&gt;' -H'&lt;content_type&gt;' -d'&lt;body&gt;'
</code></pre>
<p><action> 主要有 GET、PUT、POST、DELETE</p>
<p><protocol> 服务器 IP/domain+port</p>
<p>&lt;query_string&gt; 查询语句</p>
<p>&lt;content_type&gt; 主要是 json 格式</p>
<body> 一个 json 字符串
<pre><code class="language-bash"># example
curl -X PUT &quot;localhost:9200/customer/external/1?pretty&amp;pretty&quot; -H 'Content-Type: application/json' -d'
{ &quot;name&quot;: &quot;John Doe&quot;
}
'
</code></pre>
<h2 id="看">看</h2>
<h3 id="查看节点">查看节点</h3>
<pre><code class="language-bash">curl -X GET &quot;localhost:9200/_cat/nodes?v&amp;pretty&quot;
</code></pre>
<ul>
<li>green：完全正常，有备份</li>
<li>yellow：单机状态，可以使用（one node, no replica）</li>
<li>red：存在故障</li>
</ul>
<h3 id="查看索引">查看索引</h3>
<pre><code class="language-bash">curl -X GET &quot;localhost:9200/_cat/indices?v&amp;pretty&quot;
</code></pre>
<h3 id="查看数据">查看数据</h3>
<p>indice + id</p>
<pre><code class="language-bash">curl -X GET &quot;localhost:9200/&lt;indice_name&gt;/external/&lt;id&gt;?pretty&amp;pretty&quot;
</code></pre>
<h2 id="增">增</h2>
<h3 id="创建索引">创建索引</h3>
<pre><code class="language-bash">curl -X PUT &quot;localhost:9200/&lt;indice_name&gt;?pretty&amp;pretty&quot;
</code></pre>
<h3 id="存入数据">存入数据</h3>
<p>indice + id + json</p>
<pre><code class="language-bash">curl -X PUT &quot;localhost:9200/&lt;indice_name&gt;/external/&lt;id&gt;?pretty&amp;pretty&quot; -H 'Content-Type: application/json' -d'
{ &quot;name&quot;: &quot;John Doe&quot;
}
'
</code></pre>
<p>无索引的话 es 会自动生成一个</p>
<h2 id="删">删</h2>
<h3 id="删除索引">删除索引</h3>
<pre><code class="language-bash">curl -X DELETE &quot;localhost:9200/&lt;indice_name&gt;?pretty&amp;pretty&quot;
</code></pre>
<h3 id="删除数据">删除数据</h3>
<p>indice + id</p>
<pre><code class="language-bash">curl -X DELETE &quot;localhost:9200/&lt;indice_name&gt;/external/&lt;id&gt;?pretty&amp;pretty&quot;
</code></pre>
<p>也可使用 delete_by_query API</p>
<h2 id="改">改</h2>
<h3 id="修改替换值">修改/替换值</h3>
<pre><code class="language-bash">curl -X POST &quot;localhost:9200/&lt;indice_name&gt;/external/1/_update?pretty&amp;pretty&quot; -H 'Content-Type: application/json' -d'
{ &quot;doc&quot;: { &quot;name&quot;: &quot;Jane Doe&quot; }
}
'
</code></pre>
<p>PUT 也可</p>
<h3 id="增加-field">增加 field</h3>
<pre><code class="language-bash">curl -X POST &quot;localhost:9200/customer/external/1/_update?pretty&amp;pretty&quot; -H 'Content-Type: application/json' -d'
{ &quot;doc&quot;: { &quot;name&quot;: &quot;Jane Doe&quot;, &quot;age&quot;: 20 }
}
'
</code></pre>
<h3 id="使用-script-修改">使用 script 修改</h3>
<pre><code class="language-bash">curl -X POST &quot;localhost:9200/customer/external/1/_update?pretty&amp;pretty&quot; -H 'Content-Type: application/json' -d'
{ &quot;script&quot; : &quot;ctx._source.age += 5&quot;
}
'
</code></pre>
<h2 id="查">查</h2>
<h3 id="使用-_bulk-批量操作">使用 _bulk 批量操作</h3>
<p>POST <indice>/doc/_bulk</p>
<p>错误不会暂停，返回每个操作的成功与否</p>
<pre><code class="language-bash">curl -X POST &quot;localhost:9200/customer/external/_bulk?pretty&amp;pretty&quot; -H 'Content-Type: application/json' -d'
{&quot;index&quot;:{&quot;_id&quot;:&quot;1&quot;}}
{&quot;name&quot;: &quot;John Doe&quot; }
{&quot;index&quot;:{&quot;_id&quot;:&quot;2&quot;}}
{&quot;name&quot;: &quot;Jane Doe&quot; }
'
</code></pre>
<h3 id="_search-查询接口">_search 查询接口</h3>
<p>GET <indice>/_search</p>
<ul>
<li>sort：排序输出</li>
<li>分页：from + size</li>
<li>_source：返回指定字段</li>
<li>must == &amp;，should == |，同理 not，且可嵌套</li>
</ul>
<h3 id="query-dsl">Query DSL</h3>
<p>匹配用</p>
<ul>
<li>match_all</li>
<li>match</li>
</ul>
<p>计算出 score（匹配度）也就是相关度</p>
<pre><code class="language-bash">curl -X GET &quot;localhost:9200/bank/_search?pretty&quot; -H 'Content-Type: application/json' -d'
{ &quot;query&quot;: { &quot;bool&quot;: { &quot;must&quot;: [ { &quot;match&quot;: { &quot;address&quot;: &quot;mill lane&quot; } } ] } }
}
'
</code></pre>
<h3 id="filter-dsl">Filter DSL</h3>
<p>筛选用，速度快效率高，可复用</p>
<pre><code class="language-bash">curl -X GET &quot;localhost:9200/bank/_search?pretty&quot; -H 'Content-Type: application/json' -d'
{ &quot;query&quot;: { &quot;bool&quot;: { &quot;filter&quot;: [ { &quot;match&quot;: { &quot;address&quot;: &quot;mill lane&quot; } } ] } }
}
'
</code></pre>
<h3 id="agg-聚合搜索">agg 聚合搜索</h3>
<p>类似 group by，可嵌套</p>
<p>排序在 agg 里进行实现</p>
<pre><code class="language-bash">PUT /ecommerce/_mapping/product
{ &quot;properties&quot;: { &quot;tags&quot;:{ &quot;type&quot;: &quot;text&quot;, &quot;fielddata&quot;: true } }
}
GET /ecommerce/product/_search
{ &quot;size&quot;: 0, &quot;aggs&quot;: { &quot;all_tags&quot;: { &quot;terms&quot;: { &quot;field&quot;: &quot;tags&quot;, &quot;order&quot;: { &quot;avg_price&quot;: &quot;asc&quot; } }, &quot;aggs&quot;: { &quot;avg_price&quot;: { &quot;avg&quot;: { &quot;field&quot;: &quot;price&quot; } } } } }
}
</code></pre>
<p>tag 需要先自定义 fielddata / keyword</p>
<p>在 order 里进行排序，asc/desc</p>
<p>可实现「分组-统计-排序」</p>
<h1 id="解惑">解惑</h1>
<h2 id="version-的作用">version 的作用</h2>
<ul>
<li><s>保留历史记录</s></li>
<li><s>版本控制</s></li>
<li>解决数据冲突——乐观锁（更新时判断数据有没有被修改，即无锁）</li>
</ul>
<p>通过**「引用计数」**解决 CAS（内存位置值 == 预期原值 ? 更新值 : 不操作）机制导致的 ABA（值更改后再变回原值）问题（还可以使用时间戳）。</p>
<h2 id="多种查询语句">多种查询语句</h2>
<ul>
<li>match：分词后模糊搜索</li>
<li>term：不分词，精确查找</li>
<li>match_phase：包含所有分词 + 顺序一致</li>
<li>query_string：所有字段进行 match</li>
</ul>
<h2 id="agg-聚合搜索后排序">agg 聚合搜索后排序</h2>
<p>排序选项在 agg 内：&quot;order&quot;</p>
<p>ElasticSearch</p>
<p>ElasticSearch</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java 集合｜Integer 在 HashSet 为何“有序”]]></title>
        <id>https://yao177.github.io/post/integer-zai-hashset-wei-he-you-xu/</id>
        <link href="https://yao177.github.io/post/integer-zai-hashset-wei-he-you-xu/">
        </link>
        <updated>2020-09-15T07:54:55.000Z</updated>
        <content type="html"><![CDATA[<h1 id="现象">现象</h1>
<p>今天试着把 Integer 作为 key 添加进 HashSet，居然……</p>
<pre><code class="language-java">import java.util.*;
  
public class HashSetDemo {
    public static void main(String[] args) {
        
        Set&lt;Integer&gt; hs = new HashSet&lt;Integer&gt;();

        for (int i = 0; i &lt; 10000; i++) {
            hs.add(i);
        }

        for (Integer s : hs) {
            System.out.print(s + &quot; &quot;);
        }
    }
}
  
// Results
0 1 2 3 ... 9997 9998 9999
</code></pre>
<h1 id="分析">分析</h1>
<p>很奇怪！</p>
<p>Integer 的 hashCode 方法返回值就是本身（整数的值与整数本身一样唯一，所以它是一个足够好的散列）</p>
<p>因此 (h = key.hashCode()) ^ (h &gt;&gt; 16) 和 key ^ (key &gt;&gt; 16) 的值是一样的，经过扰动函数（低位的随机性加强，更好地避免冲突）后。</p>
<pre><code>a = 2         | 0000 0000 0000 0000 0000 0000 0000 0010
a.hashCode()  | 0000 0000 0000 0000 0000 0000 0000 0010
a &gt;&gt; 16       |                     0000 0000 0000 0000
a ^ (a &gt;&gt; 16) | 0000 0000 0000 0000 0000 0000 0000 0010
n = 2 ^ 4 - 1 | 0000 0000 0000 0000 0000 0000 0000 1111
a &amp; n         | 0000 0000 0000 0000 0000 0000 0000 0010 ---- 2
-----
a = 18        | 0000 0000 0000 0000 0000 0000 0001 0010
a.hashCode()  | 0000 0000 0000 0000 0000 0000 0001 0010
a &gt;&gt; 16       |                     0000 0000 0000 0000
a ^ (a &gt;&gt; 16) | 0000 0000 0000 0000 0000 0000 0001 0010
n = 2 ^ 4 - 1 | 0000 0000 0000 0000 0000 0000 0000 1111
a &amp; n         | 0000 0000 0000 0000 0000 0000 0000 0010 ---- 2
</code></pre>
<p>发现 2 和 18 的 hash 值都是 2，按理说应该要冲突的，却正常输出了</p>
<pre><code class="language-java">import java.util.*;
  
public class HashSetDemo {
    public static void main(String[] args) {
        
        Set&lt;Integer&gt; hs = new HashSet&lt;Integer&gt;();

        for (int i = 0; i &lt;= 18; i++) {
            hs.add(i);
        
        for (Integer s : hs) {
            System.out.print(s + &quot; &quot;);
        }
    }
}
  
// Results
0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18
</code></pre>
<p>再试试</p>
<pre><code class="language-java">import java.util.*;
  
public class HashSetDemo {
    public static void main(String[] args) {
        
        Set&lt;Integer&gt; hs = new HashSet&lt;Integer&gt;();

        hs.add(1);
		hs.add(2);
		hs.add(3);
		hs.add(4);
		hs.add(18);
        
        for (Integer s : hs) {
            System.out.print(s + &quot; &quot;);
        }
    }
}
  
// Results
1 18 2 3 4
</code></pre>
<p>恍然大悟，我忽略了数组长度问题</p>
<p>重新计算了下，扩容之后 2 和 18 就没有 hash 碰撞了</p>
<h1 id="结论">结论</h1>
<p>其实 HashSet 就是无序的，插入 1-n 后有序输出其实就是因为 Integer 的 hashCode 就是自身，取模后自然按照自然序在数组中排列，也就出现了开头「有序输出」的现象</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java 集合｜HashMap 扩容时的 rehash 过程]]></title>
        <id>https://yao177.github.io/post/hashmap-kuo-rong-shi-de-rehash-guo-cheng/</id>
        <link href="https://yao177.github.io/post/hashmap-kuo-rong-shi-de-rehash-guo-cheng/">
        </link>
        <updated>2020-09-15T05:36:23.000Z</updated>
        <content type="html"><![CDATA[<h1 id="分化链表">分化链表</h1>
<p><code>(e.hash &amp; oldCap) == 0</code>的元素放在低位链表，<code>(e.hash &amp; oldCap) != 0</code>的元素放在高位链表；低位链表在新桶的位置和旧桶中一样，高位链表在新桶的位置是原来的位置+旧容量</p>
<pre><code class="language-java">Node&lt;K,V&gt; loHead = null, loTail = null;
Node&lt;K,V&gt; hiHead = null, hiTail = null;
Node&lt;K,V&gt; next;
do {
    next = e.next;
    if ((e.hash &amp; oldCap) == 0) {
        if (loTail == null)
            loHead = e;
        else
            loTail.next = e;
        loTail = e;
    }
    else {
        if (hiTail == null)
            hiHead = e;
        else
            hiTail.next = e;
        hiTail = e;
    }
} while ((e = next) != null);
if (loTail != null) {
    loTail.next = null;
    newTab[j] = loHead;
}
if (hiTail != null) {
    hiTail.next = null;
    newTab[j + oldCap] = hiHead;
}
</code></pre>
<h3 id="原理">原理</h3>
<p>首先，一个基础知识，对 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span> 取模可以优化为对 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">2^{n-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span> 进行与运算，比较好理解，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">2^{n-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span> 也就是 n-1 个 1 的二进制数，与运算之后就得到了原数二进制的后 n-1 位结果，也就是取模</p>
<p>其次，分链时不需要像 JDK 1.7 那样重新计算 hash，只需要看新增的 bit 是 0 还是 1 就好了，0 的话索引不变，1 的话变为原索引 + 原容量，下面是一些计算</p>
<pre><code class="language-java">oldCap = 1 &lt;&lt; k
oldCap - 1 = 0b11...1 // k-1 个 1
oldIndex = e.hash % oldCap
				 = e.hash &amp; (oldCap - 1)
newCap = oldCap &lt;&lt; 1
newIndex = e.hash % newCap 
				 = e.hash &amp; (newCap - 1) 
				 = e.hash &amp; ((oldCap &lt;&lt; 1) - 1) 
				 = e.hash &amp; (oldCap - 1) + e.hash &amp; oldCap
</code></pre>
<h1 id="拆树">拆树</h1>
<p>拆树时本质上和分链是一样的，<code>HashMap.TreeNode</code>继承于<code>LinkedHashMap.Entry</code>继承于<code>HashMap.Node</code>，也就是说是有<code>next</code>引用的，而不是普通二叉树的前序/中序/后序遍历</p>
<p>同样，拆树后也会和分链一样变成两个链表，然后再进行判断是否需要将新链表树化</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java 集合｜试验 new ArrayList(0) 初始化]]></title>
        <id>https://yao177.github.io/post/shi-yan-new-arraylist0-chu-shi-hua/</id>
        <link href="https://yao177.github.io/post/shi-yan-new-arraylist0-chu-shi-hua/">
        </link>
        <updated>2020-09-15T05:27:28.000Z</updated>
        <content type="html"><![CDATA[<p>只知道 new ArrayList(0) 的不同点在于 new ArrayList() 在添加第一个元素时会初始化为 10 个空间，但只知晓前者的概念，而我又想探究一下到底如何扩容</p>
<p>正好最近刚学习了反射，就用反射来看一下 <code>elementData</code> 的实际大小</p>
<pre><code class="language-java">import java.lang.reflect.Field;
import java.util.ArrayList;

public class Main {

    public static void main( String[] args )
    {
        int pre;
        final int max = 30;

        ArrayList&lt;Integer&gt; arrayList1 = new ArrayList&lt;&gt;();
        pre = -1;
        for (int i = 0; i &lt; max; ++i) {
            int now = getArrayListCapacity(arrayList1);
            if (now != pre) {
                pre = now;
                System.out.print(pre + &quot; &quot;);
            }
            arrayList1.add(0);
        }
        System.out.println();

        ArrayList&lt;Integer&gt; arrayList2 = new ArrayList&lt;&gt;(0);
        pre = -1;
        for (int i = 0; i &lt; max; ++i) {
            int now = getArrayListCapacity(arrayList2);
            if (now != pre) {
                pre = now;
                System.out.print(pre + &quot; &quot;);
            }
            arrayList2.add(0);
        }
    }

    public static int getArrayListCapacity(ArrayList&lt;?&gt; arrayList) {
        Class&lt;ArrayList&gt; arrayListClass = ArrayList.class;
        try {
            Field field = arrayListClass.getDeclaredField(&quot;elementData&quot;);
            field.setAccessible(true);
            Object[] objects = (Object[])field.get(arrayList);
            return objects.length;
        } catch (NoSuchFieldException e) {
            e.printStackTrace();
            return -1;
        } catch (IllegalAccessException e) {
            e.printStackTrace();
            return -1;
        }
    }
}

---
Results:
0 10 15 22 33
0 1 2 3 4 6 9 13 19 28 42
</code></pre>
<p>都说是 1.5 倍扩容，甚至展示出了源码 <code>oldCapacity + (oldCapacity &gt;&gt; 1)</code>，但是按理说 0 应该也会扩容为 0 呀（0 的 1.5 倍不是 0 吗，1 的 1.5 倍不是 1 吗，都不对）</p>
<p>不过，这些教程都忽略了一个重要的点，传入的不是 <code>size</code> 而是 <code>size + 1</code>，从而解决了这个问题，再拿 <code>size + 1</code> vs <code>newCapacity</code>。</p>
]]></content>
    </entry>
</feed>