<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://yao177.github.io</id>
    <title>York Zhang</title>
    <updated>2020-11-04T03:12:21.773Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://yao177.github.io"/>
    <link rel="self" href="https://yao177.github.io/atom.xml"/>
    <subtitle>&lt;b&gt;E&lt;/b&gt;·rror = &lt;b&gt;m&lt;/b&gt;·ore * &lt;b&gt;c²&lt;/b&gt;·ode</subtitle>
    <logo>https://yao177.github.io/images/avatar.png</logo>
    <icon>https://yao177.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, York Zhang</rights>
    <entry>
        <title type="html"><![CDATA[Java 基础｜快速失败机制]]></title>
        <id>https://yao177.github.io/post/java-ji-chu-orkuai-su-shi-bai-ji-zhi/</id>
        <link href="https://yao177.github.io/post/java-ji-chu-orkuai-su-shi-bai-ji-zhi/">
        </link>
        <updated>2020-09-15T12:56:55.000Z</updated>
        <content type="html"><![CDATA[<h1 id="基本介绍">基本介绍</h1>
<p>在使用迭代器对集合对象进行遍历的时候，如果 A 线程对集合进行遍历，正好 B 线程对集合进行修改（增加、删除、修改）则 A 线程会抛出 <code>ConcurrentModificationException</code> 异常。</p>
<h1 id="原理">原理</h1>
<p>迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount 变量。集合在被遍历期间如果内容发生变化，就会改变 modCount 的值。每当迭代器使用 hashNext()/next() 遍历下一个元素之前，都会检测 modCount 变量是否为 expectedmodCount 值，是的话就返回遍历；否则抛出异常，终止遍历。</p>
<h2 id="为什么-util-中的集合类遍历时不会快速失败">为什么 util 中的集合类遍历时不会快速失败？</h2>
<p>异常的抛出条件是检测到 modCount ≠ expectedmodCount 这个条件，而遍历时发生变化会同事给 expectedmodCount 值 +1，因此不会出现问题</p>
<h2 id="javautil-中哪些集合不能在多线程下使用">java.util 中哪些集合不能在多线程下使用？</h2>
<p>都不可以，都是快速失败的，不能在多线程下发生并发修改</p>
<h1 id="安全失败">安全失败</h1>
<p>采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。</p>
<p>因此，安全失败时，迭代器不能访问修改后的内容</p>
<p>java.util.concurrent 都是安全失败，可以在多线程下并发使用和修改</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java 基础｜几个小疑惑]]></title>
        <id>https://yao177.github.io/post/java-ji-chu-orji-ge-xiao-yi-huo/</id>
        <link href="https://yao177.github.io/post/java-ji-chu-orji-ge-xiao-yi-huo/">
        </link>
        <updated>2020-09-15T12:53:48.000Z</updated>
        <content type="html"><![CDATA[<h1 id="为什么要有-object-类">为什么要有 Object 类？</h1>
<p>可以理解为一个基础的模版类，提供 <code>hashcode()</code>、<code>compareTo()</code>、<code>toString()</code> 等基础函数模版</p>
<h1 id="对象变量和引用的关系">对象变量和引用的关系？</h1>
<p>每个对象变量都属于一个类型</p>
<p>子类引用赋给超类时，OK</p>
<p>超类引用赋给子类时，必须进行类型转换（类似 C++ 中的 dynamic_cast 操作）；先用 instanceof 检验一下是否可以转换</p>
<pre><code class="language-java">if (staff[1] instanceof Manager) {	
		boss = (Manager) staff[1]; // OK	...
}
String c = (String) staff[1]; // Fail
</code></pre>
<ul>
<li>只能在继承层次内进行类型转换</li>
<li>在将超类转换成子类之前，应该使用 instanceof 进行检查</li>
<li>多态的动态绑定机制可以自动找到响应方法，只有在使用「特定方法」时才会需要类型转换——超类的设计不够合理</li>
</ul>
<h1 id="null-检查应该在什么时候">null 检查应该在什么时候</h1>
<p>给别人前，拿到之后</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java 基础｜OOP 面向对象]]></title>
        <id>https://yao177.github.io/post/java-ji-chu-ormian-xiang-dui-xiang/</id>
        <link href="https://yao177.github.io/post/java-ji-chu-ormian-xiang-dui-xiang/">
        </link>
        <updated>2020-09-15T12:51:04.000Z</updated>
        <content type="html"><![CDATA[<h1 id="基础">基础</h1>
<p>数据第一位，适合规模较大的使用场景</p>
<ul>
<li>行为 behavior：public 方法</li>
<li>状态 state：被动通过调用方法改变</li>
<li>标识 identity</li>
</ul>
<p>开发流程：设计类，添加方法</p>
<h3 id="类间关系">类间关系</h3>
<ul>
<li>依赖「uses-a」</li>
<li>聚合「has-a」</li>
<li>继承「is-a」</li>
</ul>
<p>这是 PlantUML 的中文教程，可以用纯代码的方式画 UML 图（原理类似于 Markdown 语法）</p>
<p>PlantUML_Language_Reference_Guide_zh.pdf2.00MB</p>
<h3 id="对象引用">对象引用</h3>
<p>比较像 C++ 中的对象指针，不拷贝无副本</p>
<p>想要实现深拷贝需要使用 clone 方法</p>
<p>clone 真的是深拷贝吗？尝试后发现，引用类型属性更改后同时更改 -&gt; 浅拷贝！</p>
<p>想要深拷贝，必须实现 Cloneable，并覆写 clone 方法 -&gt; 代码繁琐</p>
<p>搜索后得知，可以使用序列化对象的方法——将对象转成二进制流，然后再把二进制流反序列成一个java对象，这时候反序列化生成的对象是一个全新的对象，里面的信息与原对象一样，但是所有内容都是一份新的</p>
<p>所有类都需要实现 Serializable 接口，以便进行序列化操作</p>
<pre><code class="language-java">public class DeepClone implements Serializable{
		private static final long serialVersionUID = 1L;
		/** 
			* 利用序列化和反序列化进行对象的深拷贝 
			* @return * @throws Exception 
			*/	
		protected Object deepClone() throws Exception{	
		//序列化	
		ByteArrayOutputStream bos = new ByteArrayOutputStream();	
		ObjectOutputStream oos = new ObjectOutputStream(bos);	
		oos.writeObject(this);	
		//反序列化	
		ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray());	
		ObjectInputStream ois = new ObjectInputStream(bis);	
		return ois.readObject();	
		}
}
</code></pre>
<h3 id="更改器-访问器">更改器 访问器</h3>
<p>Date 类、LocalDate 类、GregorianCalendar 类</p>
<p>访问器方法：LocalDate 在调用 plusDays 方法后会生成一个新的对象，而不会更改本来的 LocalDate 对象（类似 toUpperCase）</p>
<p>更改器方法：GregorianCalendar 类调用 add 方法时就会更改现有对象状态</p>
<h3 id="对象创建-方法">对象创建 方法</h3>
<ul>
<li>在堆中</li>
<li>需要用 new 操作符</li>
<li>区别于 C++（<code>Object::Fuction()</code>），直接在类内部定义即可（JVM 决定是否内联）</li>
</ul>
<h3 id="封装">封装</h3>
<p>一个私有数据域 + 一个公有域访问器方法 + 一个公有域更改器方法</p>
<p>不要编写返回引用可变对象的访问器方法｜一个可变数据域的拷贝，实在需要必须先 clone</p>
<p>public &gt; default（默认，package 内） &gt; protected &gt; private</p>
<h3 id="final-修饰符">final 修饰符</h3>
<ol>
<li>应修饰「基本类型」/「不可变类」的数据域</li>
<li>若修饰一个可变类，只是限制了不可以引用其它对象，但该对象可以更改</li>
</ol>
<h3 id="static-修饰符">static 修饰符</h3>
<ol>
<li>静态域（private static 数据域）：类对象共享，可修改，只能用类名+方法访问</li>
<li>静态常量（public static final 数据域）：Math.PI, System.Out</li>
<li>静态方法（static 方法）：无 this 参数 -&gt; 不能访问实例域；可以访问静态域，可以用对象变量调用</li>
<li>工厂方法（工厂模式——定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行）：使用静态方法构造对象</li>
<li>main 方法：每个类都可以有一个 main 方法（常用于测试），可单独运行也可运行这个项目</li>
</ol>
<h3 id="修饰符顺序">修饰符顺序</h3>
<p>Java 语言规范建议按以下顺序列出修饰符：</p>
<ol>
<li>Annotations</li>
<li>public</li>
<li>protected</li>
<li>private</li>
<li>abstract</li>
<li>static</li>
<li>final</li>
<li>transient</li>
<li>volatile</li>
<li>synchronized</li>
<li>native</li>
<li>strictfp</li>
</ol>
<h3 id="方法の参数">方法の参数</h3>
<p>基本类型复制拷贝，对象引用使用引用值（依然是值，相当于一个 final）即不能进行新的引用</p>
<h1 id="对象构造">对象构造</h1>
<h3 id="重载-overloading-resolution">重载 overloading resolution</h3>
<p>唯一性——方法签名（signature）</p>
<ul>
<li>方法名</li>
<li>参数类型</li>
<li><s>返回类型</s></li>
</ul>
<p>和 C++ 中一样，如果方法名和参数类型都一致而返回类型不一致，就会报错——重复定义方法</p>
<h3 id="构造函数">构造函数</h3>
<ol>
<li>默认构造为默认数值</li>
</ol>
<ul>
<li>数值：0</li>
<li>布尔值：False</li>
<li>对象引用：null</li>
</ul>
<p>不推荐使用默认构造，因为当使用 getXxx 方法时，会获得一个 null 引用</p>
<p>this 可以调用另一个构造起</p>
<ol start="2">
<li>如果写了构造器，那就必须包括一个无参构造 / 显式域初始化（声明中赋值）/ 初始化块（{这里进行初始化}）</li>
</ol>
<p>静态初始化块可以方便得对静态域进行初始化</p>
<pre><code class="language-java">// static initialization block
static {	
		Random generator = new Random();	
		nextId = generator.nextInt(1000);
}
</code></pre>
<p>析构：因为 GC 机制，Java 不支持析构器</p>
<h3 id="导入类">导入类</h3>
<p>import package 中，「<em>」只可以导入一个包，而不可以使用 import java.</em> 或者 import java.<em>.</em>；与 C++ 中不同的是，include 必须添加以载入外部特性，而 Java 中给全包名可以不使用 import，类似于 using namespace。也可以导入静态方法和静态域，import lang.System.out;</p>
<p>类放入包，package com.x.xx.xxx 对应文件目录为 com/x/xx/xxx 中，如果不匹配，虚拟机就找不到类（可编译不可运行）。</p>
<h3 id="类设计">类设计</h3>
<ol>
<li>
<p>数据私有</p>
</li>
<li>
<p>数据初始化</p>
</li>
<li>
<p>用其它类代替多个相关的基本类型：便于处理</p>
<pre><code class="language-java">private String street;
private String city;
private String state;
private int zip;
// turn to class Address
private Address addr;
</code></pre>
</li>
<li>
<p>不是所有的域都需要独立的域访问器和域更改器：会有一些私有不想被外界修改的实例域</p>
</li>
<li>
<p>将职责过多的类进行分解</p>
</li>
<li>
<p>类名和方法名能够体现他们的职责：类名通常是带有形容词修饰的名次，方法通常是动宾结构</p>
</li>
<li>
<p>优先使用不可变的类：计算生成返回新值，而不是修改更新原来的值；一些情况会很奇怪</p>
</li>
</ol>
<h1 id="继承">继承</h1>
<p>superclass 超类，subclass 子类；通用方法放超类，特殊用途放子类</p>
<h3 id="覆盖-override">覆盖 override</h3>
<pre><code class="language-java">public class Manager extends Employee {	
		... 
		public double getSalary() {	
				return salary + bonus; // won't work	
				return getSalary() + bonus; // still won't work	
				return super.getSalary() + bonus; // works	
				... 
				} 
		...
}
</code></pre>
<ul>
<li>使用 super 调用超类的方法</li>
<li>不是引用，不能赋给另一个对象变量</li>
<li>也可用 super 调用超类的构造器</li>
</ul>
<h2 id="多态">多态</h2>
<ul>
<li>同一个变量可以引用一个超类对象，也可以引用它的任一子类对象</li>
<li>置换法则：程序中出现超类对象的任何地方都可以用子类对象置换</li>
<li>子类的引用可以转为超类的引用，但超类的引用无法赋给子类变量</li>
<li>子类数组引用可以转换为超类数组引用，再赋值为超类时会导致类型错误</li>
<li>private、static、final 方法时，准确知道调用哪个方法，称为静态绑定（static binding）</li>
<li>动态绑定（dynamic binding），VM 维护一个方法表（method table）查找调用方法</li>
<li>子类方法不能低于超类方法的可见性，尽量将通用域和方法都放在超类中</li>
<li>调用方法过程：VM 提取类的实际类型的<em>方法表</em>，然后搜索定义该方法签名的类（此时）</li>
</ul>
<h3 id="抽象类">抽象类</h3>
<ul>
<li>占位，不可实例化，具体实现在子类中</li>
<li>抽象类对象只能引用非抽象子类对象；</li>
</ul>
<h3 id="object-所有类的超类">Object 所有类的超类</h3>
<p>定义子类 equals 需要先调用超类的 equals，再比较子类中的实例域</p>
<p>防止可能为 null，使用 Objects.equals 方法判断</p>
<p>equals 要求：自反性、对称性、传递性、一致性</p>
<p>覆盖超类方法时使用 @Override 进行标记</p>
<p>默认的 hashCode 散列码为对象的存储地址（String 有着相同的散列码，StringBuilder 没有定义所以不同）；Objects.hash 可以提供多个参数；Arrays.hashCode</p>
<p>toString：类名 + [域值]；x.toString == &quot;&quot;+x 会自动调用 toString；Arrays.toString / Array.deepToString 多维数组</p>
<h3 id="泛型数组列表">泛型数组列表</h3>
<p>ArrayList&lt;type_parameter&gt;() 采用类型参数的泛型类，类似 C++ 中的 vector 模版，确认大小不再变化后可以调用 trimToSize 方法，让 GC 回收多余的存储空间；使用 add、get、set 访问和修改</p>
<h3 id="包装器-自动装箱">包装器 &amp; 自动装箱</h3>
<p>前六个有共同的超类 Number，Void 即 null</p>
<p>可自动拆箱、装箱；包装器对象比较时调用 equals 方法；装箱时 null 会报空指针异常；包装器都是 final 不可变的</p>
<h3 id="参数数量可变的方法">参数数量可变的方法</h3>
<p>fuction(String mine, Object... args) {}</p>
<p>防止重载相同的错误 <a href="https://www.cnblogs.com/lanxuezaipiao/p/3190673.html">https://www.cnblogs.com/lanxuezaipiao/p/3190673.html</a></p>
<h1 id="几个小问题">几个小问题</h1>
<ol>
<li>什么时候用继承，继承和组合的关系是什么：is、has聚合/contain组合</li>
<li>什么是多态，在继承的体系中是怎么样的，为什么要用多态：同样方法，不同对象，不同实现；子类方法被超类所用，维护扩展</li>
<li>重载和重写的区别：都是多态</li>
<li>值传递和引用传递：基本类型传值，对象传地址（值）</li>
<li>自动拆装箱的使用（什么时候）：表达式计算——先拆再算后装，类型转换 toString</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java 基础｜Java 集合]]></title>
        <id>https://yao177.github.io/post/java-ji-chu-orjava-ji-he/</id>
        <link href="https://yao177.github.io/post/java-ji-chu-orjava-ji-he/">
        </link>
        <updated>2020-09-15T10:09:15.000Z</updated>
        <content type="html"><![CDATA[<h1 id="总述">总述</h1>
<ul>
<li><em>Collection</em>
<ul>
<li><em>List</em>：有序可重
<ul>
<li><em>LinkedList</em></li>
<li><em>ArrayList</em></li>
</ul>
</li>
<li><em>Set</em>：不可重
<ul>
<li><em>HashSet</em>：无序；类 HashMap</li>
<li><em>LinkedHashSet</em>：有序；类 LinkedHashMap</li>
<li><em>TreeSet</em>：无序；类 TreeMap</li>
</ul>
</li>
</ul>
</li>
<li><em>Map</em>：不可重
<ul>
<li><em>HashMap</em>：无序</li>
<li><em>LinkedHashMap</em>：有序</li>
<li><em>TreeMap</em>：无序</li>
</ul>
</li>
</ul>
<hr>
<h1 id="单独详解">单独详解</h1>
<h2 id="linkedlist">LinkedList</h2>
<figure data-type="image" tabindex="1"><img src="https://yao177.github.io/post-images/1600164949835.png" alt="LinkedList 类图" loading="lazy"></figure>
<h3 id="基本介绍">基本介绍</h3>
<ol>
<li>双向链表，头尾双指针</li>
<li>队列使用：头进尾出，FIFO；栈使用：头进头出，FILO</li>
<li>无限扩容</li>
<li>功能上类似 ArrayList + ArrayDeque</li>
</ol>
<h3 id="是否有虚拟头节点">是否有虚拟头节点？</h3>
<ol>
<li>无</li>
<li>添加和删除时会判断是否为唯一节点</li>
</ol>
<h3 id="反转链表操作">反转链表操作</h3>
<ol>
<li>
<p>递归，空间复杂度 O(1)</p>
<pre><code class="language-java">public ListNode Reverse(ListNode list) {
    if (list == null) return null; // first question

    if (list.next == null) return list; // second question

    // third question - in Lisp this is easy, but we don't have cons
    // so we grab the second element (which will be the last after we reverse it)

    ListNode secondElem = list.next;

    // bug fix - need to unlink list from the rest or you will get a cycle
    list.next = null;

    // then we reverse everything from the second element on
    ListNode reverseRest = Reverse(secondElem);

    // then we join the two lists
    secondElem.Next = list;

    return reverseRest;
}
</code></pre>
</li>
<li>
<p>双指针</p>
</li>
<li>
<p>当成栈，推入另一个栈，空间复杂度 O(N)</p>
</li>
</ol>
<h3 id="时间复杂度">时间复杂度</h3>
<ul>
<li>随机访问：O(N)</li>
<li>查找：O(N)</li>
<li>插入删除
<ul>
<li>头尾：O(1)</li>
<li>中部：O(N)</li>
</ul>
</li>
</ul>
<h2 id="arraylist">ArrayList</h2>
<figure data-type="image" tabindex="2"><img src="https://yao177.github.io/post-images/1600164973242.png" alt="ArrayList 类图" loading="lazy"></figure>
<h3 id="基本介绍-2">基本介绍</h3>
<ol>
<li>较普通数组来讲，具有动态扩展的能力，因此也可称之为「动态数组」</li>
<li>默认长度为 10，扩容每次是 1.5 倍（<code>oldCapacity + (oldCapacity &gt;&gt; 1)</code>）</li>
<li>删除元素不会缩容，最后一位置 <code>nul</code>便于 GC 回收</li>
<li>并集<code>addAll()</code>，交集<code>retainAll()</code>，单向差集<code>removeAll()</code></li>
</ol>
<h3 id="初始化">初始化</h3>
<ul>
<li>new ArrayList()：从 10 开始，逐步扩容</li>
<li>new ArrayList(0)：从 0 开始，到 1，逐步扩容</li>
</ul>
<h3 id="如何插入元素如何扩容">如何插入元素？如何扩容</h3>
<ol>
<li>检查是否需要扩容</li>
<li><code>elementData</code>为<code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code>则初始化容量为<code>DEFAULT_CAPACITY</code>也就是 10</li>
<li>新容量是老容量的1.5倍（<code>oldCapacity + (oldCapacity &gt;&gt; 1)</code>）；如果加了这么多容量发现比需要的容量还小，则以需要的容量为准；如果超过新容量超过最大容量，则使用最大容量</li>
<li>创建新容量的数组并把老数组拷贝到新数组</li>
</ol>
<p>PS：有个注意点，扩容函数传入的是 oldCap + 1，保证了数组大小小于 2 的情况下不会不扩容</p>
<h2 id="hashset">HashSet</h2>
<figure data-type="image" tabindex="3"><img src="https://yao177.github.io/post-images/1600165004129.png" alt="HashSet 类图" loading="lazy"></figure>
<p>一个 HashMap，key 为值、value 为<code>PRESENT</code></p>
<h2 id="linkedhashset">LinkedHashSet</h2>
<p>一个 LinkedHashMap，key 为值、value 为<code>PRESENT</code></p>
<h2 id="treeset">TreeSet</h2>
<p>一个 TreeMap，key 为值、value 为<code>PRESENT</code></p>
<h2 id="hashmap">HashMap</h2>
<figure data-type="image" tabindex="4"><img src="https://yao177.github.io/post-images/1600165019290.png" alt="HashMap 类图" loading="lazy"></figure>
<h3 id="基本介绍-3">基本介绍</h3>
<ol>
<li>key-value 存储结构，数组 + 链表 + 红黑树的结构</li>
<li>查询和修改速度很快，能达到 O(1) 的平均时间复杂度</li>
<li>容量为数组长度，默认 16，最大为 2^30，达到 64 时可以树化；装载因子用来计算容量达到多少时进行扩容，默认装载因子为 0.75</li>
<li>数组容量≥64 &amp; 链表长度≥8 进行树化，链表长度≤6 时反树化</li>
</ol>
<h3 id="节点">节点</h3>
<ul>
<li>
<p>链表节点<code>Node</code></p>
<pre><code class="language-java">static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {
    final int hash;
    final K key;
    V value;
    Node&lt;K,V&gt; next;
}
</code></pre>
</li>
<li>
<p>红黑树节点<code>TreeNode</code></p>
<pre><code class="language-java">// 位于HashMap中
static final class TreeNode&lt;K,V&gt; extends LinkedHashMap.Entry&lt;K,V&gt; {
    TreeNode&lt;K,V&gt; parent;  // red-black tree links
    TreeNode&lt;K,V&gt; left;
    TreeNode&lt;K,V&gt; right;
    TreeNode&lt;K,V&gt; prev;    // needed to unlink next upon deletion
    boolean red;
}

// 位于LinkedHashMap中，典型的双向链表节点
static class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; {
    Entry&lt;K,V&gt; before, after;
    Entry(int hash, K key, V value, Node&lt;K,V&gt; next) {
        super(hash, key, value, next);
    }
}
</code></pre>
</li>
</ul>
<h3 id="hash-过程">Hash 过程</h3>
<p>key 为 null，hash 值为 0</p>
<p>高 16 位与整个 hash 值异或，为了使计算出的 hash 更分散</p>
<p><code>n % k == n &amp; (k - 1)</code></p>
<p>解决 hash 冲突的办法是「拉链法」，而 Java 的 ThreadLocalMap、Python 的 dict 则使用了开放寻址法</p>
<h3 id="插入节点过程">插入节点过程</h3>
<ol>
<li>计算 key 的 hash</li>
<li>桶数量为 0，则初始化桶</li>
<li>三种情况
<ol>
<li>key 所在桶无元素，直接插入</li>
<li>key 所在桶的第一个元素的 key 与待插入的 key 相同，说明找到了元素，转到「5」</li>
<li>第一个元素为树节点，调用<code>putTreeVal()</code></li>
</ol>
</li>
<li>不是这三种情况，则遍历桶对应的链表查找 key 是否存在
<ol>
<li>找到了对应 key 的元素，转到「5」</li>
<li>没找到对应 key 的元素，则在链表最后插入一个新节点并判断是否需要树化</li>
</ol>
</li>
<li>找到了对应 key 的元素，则判断是否需要替换旧值，并直接返回旧值</li>
<li>如果插入了元素，则数量 +1 并判断是否需要扩容</li>
</ol>
<h3 id="尾插法">尾插法</h3>
<p>Java 7 及之前是头插法：后面的值被查找的概率更大一些</p>
<p>尾插法：扩容分链前后链表顺序不变，保持了之前节点的引用关系，防止 1-&gt;2-&gt;1 的死链产生</p>
<p>依旧不是线程安全的，put / get 依旧没有同步锁，会出现 ABA 的问题</p>
<h3 id="扩容机制">扩容机制</h3>
<p>桶为空的话，第一次加入元素时进行初始化</p>
<p>扩容门槛为传入的初始容量往上取最近的 2^n</p>
<p>拷贝原数组</p>
<h2 id="linkedhashmap">LinkedHashMap</h2>
<figure data-type="image" tabindex="5"><img src="https://yao177.github.io/post-images/1600165037900.png" alt="LinkedHashMap 类图" loading="lazy"></figure>
<h3 id="accessorder-是什么">accessOrder 是什么</h3>
<p>先看看在哪里使用了</p>
<pre><code class="language-java">public V get(Object key) {
    Node&lt;K,V&gt; e;
    if ((e = getNode(hash(key), key)) == null)
        return null;
    if (accessOrder)
        afterNodeAccess(e);
    return e.value;
}
</code></pre>
<p>看一下 <code>afterNodeAccess()</code>的代码，可以看到最大的不同就是，调用 get 方法时，都会将访问的 Node 移动到尾部，成为尾节点，也就是控制了访问顺序。</p>
<p>因此，置为 true 后，则使用 LRU 调度算法（最近最少使用）。</p>
<h2 id="treemap">TreeMap</h2>
<figure data-type="image" tabindex="6"><img src="https://yao177.github.io/post-images/1600165054964.png" alt="TreeMap 类图" loading="lazy"></figure>
<h3 id="基本介绍-4">基本介绍</h3>
<ul>
<li>实现了 SortedMap 接口，因此是经过排序的</li>
<li>只使用到了红黑树，所以时间复杂度为 O(log N)</li>
</ul>
<h3 id="排序问题">排序问题</h3>
<p>红黑树根据 key 进行排序，有两种方式</p>
<ol>
<li>key 实现 Comparable 接口</li>
<li>构造时传入比较器</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java 基础｜Java String]]></title>
        <id>https://yao177.github.io/post/java-ji-chu-orjava-string/</id>
        <link href="https://yao177.github.io/post/java-ji-chu-orjava-string/">
        </link>
        <updated>2020-09-15T10:05:50.000Z</updated>
        <content type="html"><![CDATA[<h1 id="string-字符串">String 字符串</h1>
<p>Unicode 字符序列</p>
<p>C++ 中的 <code>char*</code></p>
<pre><code class="language-java">substring(start_index, first_excluded_index)
length(substring(a, b)) = b - a
str_a.equals(str_b) = (str_a.compareTo(str_b) == 0)
str_a.equalsIgnore(str_b)
</code></pre>
<h2 id="不可变">不可变</h2>
<ul>
<li>用 <code>String.substring()</code> 和 <code>+</code> 拼接后重新赋值</li>
<li>效率？→ 字符串共享
<ul>
<li>仅字符串常量，其他+/substring 生成的不共享 → <code>==</code> 不能用来测试相等性</li>
</ul>
</li>
<li>怎么不可变？（用 C++ 的 <code>char*</code> 比较好理解）</li>
<li>指向的位置上的字符串内存不可变，</li>
</ul>
<h2 id="vs-equals-vs-compareto"><code>==</code> VS <code>equals()</code> VS <code>compareTo()</code></h2>
<pre><code class="language-java">// equals 源码
public boolean equals(Object anObject) {
    if (this == anObject) { // 内存位置一致
        return true;
    }
    if (anObject instanceof String) {
        String anotherString = (String) anObject; // 其它类型先转换为 String 类型
        int n = value.length;
        if (n == anotherString.value.length) {
            char v1[] = value;
            char v2[] = anotherString.value;
            int i = 0;
            while (n-- != 0) {
                if (v1[i] != v2[i]) return false;
                i++;
            }
            return true;
        }
    }
    return false;
}

// compareTo 源码
public int compareTo(String anotherString) {
		int len1 = value.length; int len2 = anotherString.value.length; 
		int lim = Math.min(len1, len2); 
		char v1[] = value; char v2[] = anotherString.value; 
		int k = 0; 
		while (k &lt; lim) { // 字典序大小比较 
				char c1 = v1[k]; 
				char c2 = v2[k]; 
				if (c1 != c2) { 
							return c1 - c2; 
				} 
				k++; 
		} 
		return len1 - len2;
}
</code></pre>
<p>equals 类似 C++ 中的 <code>==</code>，compareTo 类似 <code>strcmp</code></p>
<ul>
<li>返回值不同
<ul>
<li>equals 只判断是否相同</li>
<li>compareTo 判断大小比较，正大负小=同</li>
</ul>
</li>
<li>比较类型不同
<ul>
<li>equals 可以和非字符串进行比较，转换为 String 类型</li>
<li>compareTo 只能和字符串变量比较</li>
</ul>
</li>
<li>效率
<ul>
<li>equals 比 compareTo 稍微快一些（加了一些前置判断），如果只判断是否相等建议使用 equals</li>
</ul>
</li>
<li>使用范围
<ul>
<li>Object 自带 equals 方法，基本都可用（默认实现为 <code>==</code>）</li>
<li>实现了 Comparable 接口的类才有 compareTo 方法</li>
</ul>
</li>
</ul>
<h2 id="空串和-null-串">空串（&quot;&quot;）和 null 串</h2>
<p>空串，长度为「0」、内容为「空」的 String 对象</p>
<p>null 串，无对象（类似于“空指针”），不是 String 对象，不可以使用 String 的方法</p>
<p><code>if (str != null &amp;&amp; str.length() != 0) {...} if (str != null &amp;&amp; !str.equals(&quot;&quot;)) {...}</code></p>
<h2 id="码点-代码单元">码点、代码单元</h2>
<p>char 是「一个采用 UTF-16 编码表示的代码单元」，用来表示 Unicode 码点。</p>
<p>UTF-16 有一些用两个字节表示一个符号的情况，</p>
<p>编号为 U+D800 至 U+DBFF 的规定为「High Surrogates」，共 102 4个；编号为 U+DC00 至 U+DFFF 的规定为「Low Surrogates」，也是 1024 个；他们组合出现，就又可以多表示 1048576 种字符。</p>
<p>一个字符对应一个码点，因此有可能是 1 也有可能是 2 个字节</p>
<h2 id="stringbuilder-vs-stringbuffer">StringBuilder vs StringBuffer</h2>
<p>用于 String 拼接的 <code>+</code> 即是 SringBuilder，查看字节码可知</p>
<pre><code class="language-java">LINENUMBER 28 L3
NEW java/lang/StringBuilder
DUP
INVOKESPECIAL java/lang/StringBuilder.&lt;init&gt; ()V
ALOAD 0
INVOKEVIRTUAL java/lang/StringBuilder.append (Ljava/lang/String;)Ljava/lang/StringBuilder;
ALOAD 1
INVOKEVIRTUAL java/lang/StringBuilder.append (Ljava/lang/String;)Ljava/lang/StringBuilder;
INVOKEVIRTUAL java/lang/StringBuilder.toString ()Ljava/lang/String;
ASTORE 3
</code></pre>
<p>也就是说，调用了</p>
<pre><code class="language-java">c = a + b;
c = new StringBuilder().append(a).append(b).toString();
// 如果有性能需求
c = new StringBuilder(a.length() + b.length()).append(a).append(b).toString();
// 可正确调整缓冲区大小，并防止 JVM 重新调整缓冲区大小并创建垃圾以进行收集
</code></pre>
<p>顺便看一下StringBuilder.append()的源码：</p>
<pre><code class="language-java">public AbstractStringBuilder append(String str) {
    if (str == null) {
        return appendNull();
    }
    int len = str.length();
    ensureCapacityInternal(count + len);
    putStringAt(count, str);
    count += len;
    return this;
}

private final void putStringAt(int index, String str) {
    if (getCoder() != str.coder()) {
        inflate();
    }
    str.getBytes(value, index, coder);
}

void getBytes(byte dst[], int dstBegin, byte coder) {
    if (coder() == coder) {
        System.arraycopy(value, 0, dst, dstBegin &lt;&lt; coder, value.length);
    } else { // this.coder == LATIN &amp;&amp; coder == UTF16 
        StringLatin1.inflate(value, 0, dst, dstBegin, value.length);
    }
}
</code></pre>
<p>有点类似 C++ 中 strcpy 的做法，直接拷贝内存地址上的内容</p>
<p>关于<em>线程安全</em>，StringBuilder 是不安全的，StringBuffer 是安全的；StringBuffer 源码中每个方法都添加了 <strong>synchronized</strong> 关键字，举个例子</p>
<pre><code class="language-java">public synchronized StringBuffer append(String str) {
    toStringCache = null;
    super.append(str);
    return this;
}
</code></pre>
<p>~~如果手动添加 <strong>synchronized</strong> 关键字呢？~~不要这样使用</p>
<pre><code class="language-java">public class Foo { // safe ? 
    private final static StringBuilder builder;

    public static void foo() { // safe ? 
        builder = new StringBuilder();
    }

    public static void foo(final String a) { // unsafe ? 
        builder.append(a);
    }

    public synchronized void bar(final String a) { // safe ? 
        builder.append(a);
    }
}
</code></pre>
<h1 id="结论">结论</h1>
<p><strong>直接使用 StringBuilder 局部变量，用完即销毁就可以！</strong></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数据库｜ES 基础]]></title>
        <id>https://yao177.github.io/post/es-ji-chu/</id>
        <link href="https://yao177.github.io/post/es-ji-chu/">
        </link>
        <updated>2020-09-15T10:00:34.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/5.1/index.html">Elasticsearch Reference</a></p>
<h1 id="安装">安装</h1>
<pre><code class="language-bash">curl -L -O https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-5.3.3.tar.gz
tar -xvf elasticsearch-5.3.3.tar.gz
cd elasticsearch-5.3.3/bin
./elasticsearch
</code></pre>
<p>当看到 &quot;[node_name] started&quot;，代表 node 已经启动了</p>
<h1 id="使用">使用</h1>
<p>node -&gt; indice -&gt; document</p>
<p>ES 使用 RESTful API 的风格进行操作</p>
<pre><code class="language-bash">curl -X &lt;action&gt; '&lt;protocol&gt;://:/?&lt;query_string&gt;' -H'&lt;content_type&gt;' -d'&lt;body&gt;'
</code></pre>
<p><action> 主要有 GET、PUT、POST、DELETE</p>
<p><protocol> 服务器 IP/domain+port</p>
<p>&lt;query_string&gt; 查询语句</p>
<p>&lt;content_type&gt; 主要是 json 格式</p>
<body> 一个 json 字符串
<pre><code class="language-bash"># example
curl -X PUT &quot;localhost:9200/customer/external/1?pretty&amp;pretty&quot; -H 'Content-Type: application/json' -d'
{ &quot;name&quot;: &quot;John Doe&quot;
}
'
</code></pre>
<h2 id="看">看</h2>
<h3 id="查看节点">查看节点</h3>
<pre><code class="language-bash">curl -X GET &quot;localhost:9200/_cat/nodes?v&amp;pretty&quot;
</code></pre>
<ul>
<li>green：完全正常，有备份</li>
<li>yellow：单机状态，可以使用（one node, no replica）</li>
<li>red：存在故障</li>
</ul>
<h3 id="查看索引">查看索引</h3>
<pre><code class="language-bash">curl -X GET &quot;localhost:9200/_cat/indices?v&amp;pretty&quot;
</code></pre>
<h3 id="查看数据">查看数据</h3>
<p>indice + id</p>
<pre><code class="language-bash">curl -X GET &quot;localhost:9200/&lt;indice_name&gt;/external/&lt;id&gt;?pretty&amp;pretty&quot;
</code></pre>
<h2 id="增">增</h2>
<h3 id="创建索引">创建索引</h3>
<pre><code class="language-bash">curl -X PUT &quot;localhost:9200/&lt;indice_name&gt;?pretty&amp;pretty&quot;
</code></pre>
<h3 id="存入数据">存入数据</h3>
<p>indice + id + json</p>
<pre><code class="language-bash">curl -X PUT &quot;localhost:9200/&lt;indice_name&gt;/external/&lt;id&gt;?pretty&amp;pretty&quot; -H 'Content-Type: application/json' -d'
{ &quot;name&quot;: &quot;John Doe&quot;
}
'
</code></pre>
<p>无索引的话 es 会自动生成一个</p>
<h2 id="删">删</h2>
<h3 id="删除索引">删除索引</h3>
<pre><code class="language-bash">curl -X DELETE &quot;localhost:9200/&lt;indice_name&gt;?pretty&amp;pretty&quot;
</code></pre>
<h3 id="删除数据">删除数据</h3>
<p>indice + id</p>
<pre><code class="language-bash">curl -X DELETE &quot;localhost:9200/&lt;indice_name&gt;/external/&lt;id&gt;?pretty&amp;pretty&quot;
</code></pre>
<p>也可使用 delete_by_query API</p>
<h2 id="改">改</h2>
<h3 id="修改替换值">修改/替换值</h3>
<pre><code class="language-bash">curl -X POST &quot;localhost:9200/&lt;indice_name&gt;/external/1/_update?pretty&amp;pretty&quot; -H 'Content-Type: application/json' -d'
{ &quot;doc&quot;: { &quot;name&quot;: &quot;Jane Doe&quot; }
}
'
</code></pre>
<p>PUT 也可</p>
<h3 id="增加-field">增加 field</h3>
<pre><code class="language-bash">curl -X POST &quot;localhost:9200/customer/external/1/_update?pretty&amp;pretty&quot; -H 'Content-Type: application/json' -d'
{ &quot;doc&quot;: { &quot;name&quot;: &quot;Jane Doe&quot;, &quot;age&quot;: 20 }
}
'
</code></pre>
<h3 id="使用-script-修改">使用 script 修改</h3>
<pre><code class="language-bash">curl -X POST &quot;localhost:9200/customer/external/1/_update?pretty&amp;pretty&quot; -H 'Content-Type: application/json' -d'
{ &quot;script&quot; : &quot;ctx._source.age += 5&quot;
}
'
</code></pre>
<h2 id="查">查</h2>
<h3 id="使用-_bulk-批量操作">使用 _bulk 批量操作</h3>
<p>POST <indice>/doc/_bulk</p>
<p>错误不会暂停，返回每个操作的成功与否</p>
<pre><code class="language-bash">curl -X POST &quot;localhost:9200/customer/external/_bulk?pretty&amp;pretty&quot; -H 'Content-Type: application/json' -d'
{&quot;index&quot;:{&quot;_id&quot;:&quot;1&quot;}}
{&quot;name&quot;: &quot;John Doe&quot; }
{&quot;index&quot;:{&quot;_id&quot;:&quot;2&quot;}}
{&quot;name&quot;: &quot;Jane Doe&quot; }
'
</code></pre>
<h3 id="_search-查询接口">_search 查询接口</h3>
<p>GET <indice>/_search</p>
<ul>
<li>sort：排序输出</li>
<li>分页：from + size</li>
<li>_source：返回指定字段</li>
<li>must == &amp;，should == |，同理 not，且可嵌套</li>
</ul>
<h3 id="query-dsl">Query DSL</h3>
<p>匹配用</p>
<ul>
<li>match_all</li>
<li>match</li>
</ul>
<p>计算出 score（匹配度）也就是相关度</p>
<pre><code class="language-bash">curl -X GET &quot;localhost:9200/bank/_search?pretty&quot; -H 'Content-Type: application/json' -d'
{ &quot;query&quot;: { &quot;bool&quot;: { &quot;must&quot;: [ { &quot;match&quot;: { &quot;address&quot;: &quot;mill lane&quot; } } ] } }
}
'
</code></pre>
<h3 id="filter-dsl">Filter DSL</h3>
<p>筛选用，速度快效率高，可复用</p>
<pre><code class="language-bash">curl -X GET &quot;localhost:9200/bank/_search?pretty&quot; -H 'Content-Type: application/json' -d'
{ &quot;query&quot;: { &quot;bool&quot;: { &quot;filter&quot;: [ { &quot;match&quot;: { &quot;address&quot;: &quot;mill lane&quot; } } ] } }
}
'
</code></pre>
<h3 id="agg-聚合搜索">agg 聚合搜索</h3>
<p>类似 group by，可嵌套</p>
<p>排序在 agg 里进行实现</p>
<pre><code class="language-bash">PUT /ecommerce/_mapping/product
{ &quot;properties&quot;: { &quot;tags&quot;:{ &quot;type&quot;: &quot;text&quot;, &quot;fielddata&quot;: true } }
}
GET /ecommerce/product/_search
{ &quot;size&quot;: 0, &quot;aggs&quot;: { &quot;all_tags&quot;: { &quot;terms&quot;: { &quot;field&quot;: &quot;tags&quot;, &quot;order&quot;: { &quot;avg_price&quot;: &quot;asc&quot; } }, &quot;aggs&quot;: { &quot;avg_price&quot;: { &quot;avg&quot;: { &quot;field&quot;: &quot;price&quot; } } } } }
}
</code></pre>
<p>tag 需要先自定义 fielddata / keyword</p>
<p>在 order 里进行排序，asc/desc</p>
<p>可实现「分组-统计-排序」</p>
<h1 id="解惑">解惑</h1>
<h2 id="version-的作用">version 的作用</h2>
<ul>
<li><s>保留历史记录</s></li>
<li><s>版本控制</s></li>
<li>解决数据冲突——乐观锁（更新时判断数据有没有被修改，即无锁）</li>
</ul>
<p>通过**「引用计数」**解决 CAS（内存位置值 == 预期原值 ? 更新值 : 不操作）机制导致的 ABA（值更改后再变回原值）问题（还可以使用时间戳）。</p>
<h2 id="多种查询语句">多种查询语句</h2>
<ul>
<li>match：分词后模糊搜索</li>
<li>term：不分词，精确查找</li>
<li>match_phase：包含所有分词 + 顺序一致</li>
<li>query_string：所有字段进行 match</li>
</ul>
<h2 id="agg-聚合搜索后排序">agg 聚合搜索后排序</h2>
<p>排序选项在 agg 内：&quot;order&quot;</p>
<p>ElasticSearch</p>
<p>ElasticSearch</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java 集合｜Integer 在 HashSet 为何“有序”]]></title>
        <id>https://yao177.github.io/post/integer-zai-hashset-wei-he-you-xu/</id>
        <link href="https://yao177.github.io/post/integer-zai-hashset-wei-he-you-xu/">
        </link>
        <updated>2020-09-15T07:54:55.000Z</updated>
        <content type="html"><![CDATA[<h1 id="现象">现象</h1>
<p>今天试着把 Integer 作为 key 添加进 HashSet，居然……</p>
<pre><code class="language-java">import java.util.*;
  
public class HashSetDemo {
    public static void main(String[] args) {
        
        Set&lt;Integer&gt; hs = new HashSet&lt;Integer&gt;();

        for (int i = 0; i &lt; 10000; i++) {
            hs.add(i);
        }

        for (Integer s : hs) {
            System.out.print(s + &quot; &quot;);
        }
    }
}
  
// Results
0 1 2 3 ... 9997 9998 9999
</code></pre>
<h1 id="分析">分析</h1>
<p>很奇怪！</p>
<p>Integer 的 hashCode 方法返回值就是本身（整数的值与整数本身一样唯一，所以它是一个足够好的散列）</p>
<p>因此 (h = key.hashCode()) ^ (h &gt;&gt; 16) 和 key ^ (key &gt;&gt; 16) 的值是一样的，经过扰动函数（低位的随机性加强，更好地避免冲突）后。</p>
<pre><code>a = 2         | 0000 0000 0000 0000 0000 0000 0000 0010
a.hashCode()  | 0000 0000 0000 0000 0000 0000 0000 0010
a &gt;&gt; 16       |                     0000 0000 0000 0000
a ^ (a &gt;&gt; 16) | 0000 0000 0000 0000 0000 0000 0000 0010
n = 2 ^ 4 - 1 | 0000 0000 0000 0000 0000 0000 0000 1111
a &amp; n         | 0000 0000 0000 0000 0000 0000 0000 0010 ---- 2
-----
a = 18        | 0000 0000 0000 0000 0000 0000 0001 0010
a.hashCode()  | 0000 0000 0000 0000 0000 0000 0001 0010
a &gt;&gt; 16       |                     0000 0000 0000 0000
a ^ (a &gt;&gt; 16) | 0000 0000 0000 0000 0000 0000 0001 0010
n = 2 ^ 4 - 1 | 0000 0000 0000 0000 0000 0000 0000 1111
a &amp; n         | 0000 0000 0000 0000 0000 0000 0000 0010 ---- 2
</code></pre>
<p>发现 2 和 18 的 hash 值都是 2，按理说应该要冲突的，却正常输出了</p>
<pre><code class="language-java">import java.util.*;
  
public class HashSetDemo {
    public static void main(String[] args) {
        
        Set&lt;Integer&gt; hs = new HashSet&lt;Integer&gt;();

        for (int i = 0; i &lt;= 18; i++) {
            hs.add(i);
        
        for (Integer s : hs) {
            System.out.print(s + &quot; &quot;);
        }
    }
}
  
// Results
0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18
</code></pre>
<p>再试试</p>
<pre><code class="language-java">import java.util.*;
  
public class HashSetDemo {
    public static void main(String[] args) {
        
        Set&lt;Integer&gt; hs = new HashSet&lt;Integer&gt;();

        hs.add(1);
		hs.add(2);
		hs.add(3);
		hs.add(4);
		hs.add(18);
        
        for (Integer s : hs) {
            System.out.print(s + &quot; &quot;);
        }
    }
}
  
// Results
1 18 2 3 4
</code></pre>
<p>恍然大悟，我忽略了数组长度问题</p>
<p>重新计算了下，扩容之后 2 和 18 就没有 hash 碰撞了</p>
<h1 id="结论">结论</h1>
<p>其实 HashSet 就是无序的，插入 1-n 后有序输出其实就是因为 Integer 的 hashCode 就是自身，取模后自然按照自然序在数组中排列，也就出现了开头「有序输出」的现象</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java 集合｜HashMap 扩容时的 rehash 过程]]></title>
        <id>https://yao177.github.io/post/hashmap-kuo-rong-shi-de-rehash-guo-cheng/</id>
        <link href="https://yao177.github.io/post/hashmap-kuo-rong-shi-de-rehash-guo-cheng/">
        </link>
        <updated>2020-09-15T05:36:23.000Z</updated>
        <content type="html"><![CDATA[<h1 id="分化链表">分化链表</h1>
<p><code>(e.hash &amp; oldCap) == 0</code>的元素放在低位链表，<code>(e.hash &amp; oldCap) != 0</code>的元素放在高位链表；低位链表在新桶的位置和旧桶中一样，高位链表在新桶的位置是原来的位置+旧容量</p>
<pre><code class="language-java">Node&lt;K,V&gt; loHead = null, loTail = null;
Node&lt;K,V&gt; hiHead = null, hiTail = null;
Node&lt;K,V&gt; next;
do {
    next = e.next;
    if ((e.hash &amp; oldCap) == 0) {
        if (loTail == null)
            loHead = e;
        else
            loTail.next = e;
        loTail = e;
    }
    else {
        if (hiTail == null)
            hiHead = e;
        else
            hiTail.next = e;
        hiTail = e;
    }
} while ((e = next) != null);
if (loTail != null) {
    loTail.next = null;
    newTab[j] = loHead;
}
if (hiTail != null) {
    hiTail.next = null;
    newTab[j + oldCap] = hiHead;
}
</code></pre>
<h3 id="原理">原理</h3>
<p>首先，一个基础知识，对 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span> 取模可以优化为对 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">2^{n-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span> 进行与运算，比较好理解，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">2^{n-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span> 也就是 n-1 个 1 的二进制数，与运算之后就得到了原数二进制的后 n-1 位结果，也就是取模</p>
<p>其次，分链时不需要像 JDK 1.7 那样重新计算 hash，只需要看新增的 bit 是 0 还是 1 就好了，0 的话索引不变，1 的话变为原索引 + 原容量，下面是一些计算</p>
<pre><code class="language-java">oldCap = 1 &lt;&lt; k
oldCap - 1 = 0b11...1 // k-1 个 1
oldIndex = e.hash % oldCap
				 = e.hash &amp; (oldCap - 1)
newCap = oldCap &lt;&lt; 1
newIndex = e.hash % newCap 
				 = e.hash &amp; (newCap - 1) 
				 = e.hash &amp; ((oldCap &lt;&lt; 1) - 1) 
				 = e.hash &amp; (oldCap - 1) + e.hash &amp; oldCap
</code></pre>
<h1 id="拆树">拆树</h1>
<p>拆树时本质上和分链是一样的，<code>HashMap.TreeNode</code>继承于<code>LinkedHashMap.Entry</code>继承于<code>HashMap.Node</code>，也就是说是有<code>next</code>引用的，而不是普通二叉树的前序/中序/后序遍历</p>
<p>同样，拆树后也会和分链一样变成两个链表，然后再进行判断是否需要将新链表树化</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java 集合｜试验 new ArrayList(0) 初始化]]></title>
        <id>https://yao177.github.io/post/shi-yan-new-arraylist0-chu-shi-hua/</id>
        <link href="https://yao177.github.io/post/shi-yan-new-arraylist0-chu-shi-hua/">
        </link>
        <updated>2020-09-15T05:27:28.000Z</updated>
        <content type="html"><![CDATA[<p>只知道 new ArrayList(0) 的不同点在于 new ArrayList() 在添加第一个元素时会初始化为 10 个空间，但只知晓前者的概念，而我又想探究一下到底如何扩容</p>
<p>正好最近刚学习了反射，就用反射来看一下 <code>elementData</code> 的实际大小</p>
<pre><code class="language-java">import java.lang.reflect.Field;
import java.util.ArrayList;

public class Main {

    public static void main( String[] args )
    {
        int pre;
        final int max = 30;

        ArrayList&lt;Integer&gt; arrayList1 = new ArrayList&lt;&gt;();
        pre = -1;
        for (int i = 0; i &lt; max; ++i) {
            int now = getArrayListCapacity(arrayList1);
            if (now != pre) {
                pre = now;
                System.out.print(pre + &quot; &quot;);
            }
            arrayList1.add(0);
        }
        System.out.println();

        ArrayList&lt;Integer&gt; arrayList2 = new ArrayList&lt;&gt;(0);
        pre = -1;
        for (int i = 0; i &lt; max; ++i) {
            int now = getArrayListCapacity(arrayList2);
            if (now != pre) {
                pre = now;
                System.out.print(pre + &quot; &quot;);
            }
            arrayList2.add(0);
        }
    }

    public static int getArrayListCapacity(ArrayList&lt;?&gt; arrayList) {
        Class&lt;ArrayList&gt; arrayListClass = ArrayList.class;
        try {
            Field field = arrayListClass.getDeclaredField(&quot;elementData&quot;);
            field.setAccessible(true);
            Object[] objects = (Object[])field.get(arrayList);
            return objects.length;
        } catch (NoSuchFieldException e) {
            e.printStackTrace();
            return -1;
        } catch (IllegalAccessException e) {
            e.printStackTrace();
            return -1;
        }
    }
}

---
Results:
0 10 15 22 33
0 1 2 3 4 6 9 13 19 28 42
</code></pre>
<p>都说是 1.5 倍扩容，甚至展示出了源码 <code>oldCapacity + (oldCapacity &gt;&gt; 1)</code>，但是按理说 0 应该也会扩容为 0 呀（0 的 1.5 倍不是 0 吗，1 的 1.5 倍不是 1 吗，都不对）</p>
<p>不过，这些教程都忽略了一个重要的点，传入的不是 <code>size</code> 而是 <code>size + 1</code>，从而解决了这个问题，再拿 <code>size + 1</code> vs <code>newCapacity</code>。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java 集合｜ArrayList 扩容参数为什么是 1.5]]></title>
        <id>https://yao177.github.io/post/arraylist-kuo-rong-can-shu-wei-shi-me-shi-15/</id>
        <link href="https://yao177.github.io/post/arraylist-kuo-rong-can-shu-wei-shi-me-shi-15/">
        </link>
        <updated>2020-09-15T05:22:46.000Z</updated>
        <content type="html"><![CDATA[<h1 id="结论">结论</h1>
<p>实际上比较好的扩容参数就是 JDK 1.8 中的 1.5</p>
<p>理论上最好的扩容参数为黄金分割率 1.618（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>+</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mo>(</mo><mn>1</mn><mo>+</mo><msqrt><mn>5</mn></msqrt><mo>)</mo></mrow><annotation encoding="application/x-tex">1+\frac{1}{2}(1+\sqrt{5})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.1572200000000001em;vertical-align:-0.25em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.90722em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord">5</span></span></span><span style="top:-2.86722em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,
-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,
-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,
35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,
-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467
s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422
s-65,47,-65,47z M834 80H400000v40H845z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.13278em;"><span></span></span></span></span></span><span class="mclose">)</span></span></span></span>）</p>
<h1 id="为什么">为什么</h1>
<h2 id="扩容参数为-1-2-之间比较好">扩容参数为 (1, 2) 之间比较好</h2>
<p>大于 1 自然非常好理解不需要证明，否则直接缩容了</p>
<p>假设扩容参数为 x，当 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>≥</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">x\geq{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span></span></span></span></span> 时，每次扩容后，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mo>⋅</mo><mo>(</mo><mn>1</mn><mo>+</mo><mi>x</mi><mo>+</mo><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><mo>⋯</mo><mo>+</mo><msup><mi>x</mi><mrow><mi>n</mi><mo>−</mo><mn>2</mn></mrow></msup><mo>)</mo><mo>≤</mo><mi>c</mi><mo>⋅</mo><msup><mi>x</mi><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">c\cdot(1+x+x^2+\dots+x^{n-2})\leq c\cdot x^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.44445em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.44445em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span>，也就是说扩容后的内存占用空间都要大于之前所有的扩容空间之和，也就是说之前的内存空间都不能进行复用，以下举个例子：</p>
<pre><code>IF x = 2 :
caps: 1 2 4 8 16 32
---
1
 12
   1234
       12345678
               123456789012345
                              12345678901234567890123456789012

IF x = 1.5 :
caps: 1 2 3 4 6 9 13 19 28
---
1
 12
   123
      1234
123456
      123456789
               1234567890123
                            1234567890123456789
1234567890123456789012345678
</code></pre>
<h2 id="到底多大最好">到底多大最好</h2>
<p>先来找几个值试一试</p>
<p>第三次肯定不能塞入第一次的空间，因此从第四次开始测试，也就是说第四次空间小于等于第一次与第二次空间的和</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>+</mo><mi>x</mi><mo>=</mo><msup><mi>x</mi><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">1+x=x^3
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8641079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>得出结果为 1.3247，如果想再等一等呢</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>+</mo><mi>x</mi><mo>+</mo><msup><mi>x</mi><mn>2</mn></msup><mo>=</mo><msup><mi>x</mi><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">1+x+x^2=x^4
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8641079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8641079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>得出结果为 1.4656</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>+</mo><mi>x</mi><mo>+</mo><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><msup><mi>x</mi><mn>3</mn></msup><mo>=</mo><msup><mi>x</mi><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">1+x+x^2+x^3=x^5
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.9474379999999999em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8641079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8641079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>得出结果为 1.5341</p>
<p>假设我们愿意等待 n 次空间，也就是</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>+</mo><mi>x</mi><mo>+</mo><mo>⋯</mo><mo>+</mo><msup><mi>x</mi><mrow><mi>n</mi><mo>−</mo><mn>2</mn></mrow></msup><mo>=</mo><msup><mi>x</mi><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">1+x+\dots+x^{n-2}=x^n
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.864108em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.864108em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7143919999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7143919999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>可以看到等式左侧是个几何级数，可以得到</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>x</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msup><mo>−</mo><mn>1</mn><mo>=</mo><msup><mi>x</mi><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msup><mo>−</mo><msup><mi>x</mi><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">x^{n-1}-1=x^{n+1}-x^n
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.947438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.864108em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.947438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.864108em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.7143919999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7143919999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>两边求极限可得</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>x</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msup><mo>=</mo><msup><mi>x</mi><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msup><mo>−</mo><msup><mi>x</mi><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">x^{n-1}=x^{n+1}-x^n
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.864108em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.864108em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.947438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.864108em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.7143919999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7143919999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>求解可得 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>=</mo><mn>1</mn><mo>+</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mo>(</mo><mn>1</mn><mo>+</mo><msqrt><mn>5</mn></msqrt><mo>)</mo></mrow><annotation encoding="application/x-tex">x=1+\frac{1}{2}(1+\sqrt{5})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.1572200000000001em;vertical-align:-0.25em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.90722em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord">5</span></span></span><span style="top:-2.86722em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,
-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,
-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,
35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,
-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467
s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422
s-65,47,-65,47z M834 80H400000v40H845z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.13278em;"><span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，也就是黄金分割数 1+0.618</p>
<p>当然，这只是理想情况，考虑到 int 需要作取整操作，因此源码作者 Simon 建议设为 1.5 比较好</p>
<p>根据上面可以看到，可以看到 1.5 在三次到四次之间，可以自己做个实验，在 (0, 2^31-8) 空间内跑一遍试试</p>
]]></content>
    </entry>
</feed>